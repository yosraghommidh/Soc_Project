{"ast":null,"code":"import { __awaiter } from 'tslib';\nimport * as i0 from '@angular/core';\nimport { Injectable, NgModule } from '@angular/core';\nimport { HttpHeaders, HTTP_INTERCEPTORS } from '@angular/common/http';\nimport { Subject, from, combineLatest } from 'rxjs';\nimport { map, mergeMap } from 'rxjs/operators';\nimport Keycloak from 'keycloak-js';\nimport { CommonModule } from '@angular/common';\nvar KeycloakEventType = /*#__PURE__*/(() => {\n  (function (KeycloakEventType) {\n    KeycloakEventType[KeycloakEventType[\"OnAuthError\"] = 0] = \"OnAuthError\";\n    KeycloakEventType[KeycloakEventType[\"OnAuthLogout\"] = 1] = \"OnAuthLogout\";\n    KeycloakEventType[KeycloakEventType[\"OnAuthRefreshError\"] = 2] = \"OnAuthRefreshError\";\n    KeycloakEventType[KeycloakEventType[\"OnAuthRefreshSuccess\"] = 3] = \"OnAuthRefreshSuccess\";\n    KeycloakEventType[KeycloakEventType[\"OnAuthSuccess\"] = 4] = \"OnAuthSuccess\";\n    KeycloakEventType[KeycloakEventType[\"OnReady\"] = 5] = \"OnReady\";\n    KeycloakEventType[KeycloakEventType[\"OnTokenExpired\"] = 6] = \"OnTokenExpired\";\n    KeycloakEventType[KeycloakEventType[\"OnActionUpdate\"] = 7] = \"OnActionUpdate\";\n  })(KeycloakEventType || (KeycloakEventType = {}));\n\n  return KeycloakEventType;\n})();\n\nclass KeycloakAuthGuard {\n  constructor(router, keycloakAngular) {\n    this.router = router;\n    this.keycloakAngular = keycloakAngular;\n  }\n\n  canActivate(route, state) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        this.authenticated = yield this.keycloakAngular.isLoggedIn();\n        this.roles = yield this.keycloakAngular.getUserRoles(true);\n        return yield this.isAccessAllowed(route, state);\n      } catch (error) {\n        throw new Error('An error happened during access validation. Details:' + error);\n      }\n    });\n  }\n\n}\n\nlet KeycloakService = /*#__PURE__*/(() => {\n  class KeycloakService {\n    constructor() {\n      this._keycloakEvents$ = new Subject();\n    }\n\n    bindsKeycloakEvents() {\n      this._instance.onAuthError = errorData => {\n        this._keycloakEvents$.next({\n          args: errorData,\n          type: KeycloakEventType.OnAuthError\n        });\n      };\n\n      this._instance.onAuthLogout = () => {\n        this._keycloakEvents$.next({\n          type: KeycloakEventType.OnAuthLogout\n        });\n      };\n\n      this._instance.onAuthRefreshSuccess = () => {\n        this._keycloakEvents$.next({\n          type: KeycloakEventType.OnAuthRefreshSuccess\n        });\n      };\n\n      this._instance.onAuthRefreshError = () => {\n        this._keycloakEvents$.next({\n          type: KeycloakEventType.OnAuthRefreshError\n        });\n      };\n\n      this._instance.onAuthSuccess = () => {\n        this._keycloakEvents$.next({\n          type: KeycloakEventType.OnAuthSuccess\n        });\n      };\n\n      this._instance.onTokenExpired = () => {\n        this._keycloakEvents$.next({\n          type: KeycloakEventType.OnTokenExpired\n        });\n      };\n\n      this._instance.onActionUpdate = state => {\n        this._keycloakEvents$.next({\n          args: state,\n          type: KeycloakEventType.OnActionUpdate\n        });\n      };\n\n      this._instance.onReady = authenticated => {\n        this._keycloakEvents$.next({\n          args: authenticated,\n          type: KeycloakEventType.OnReady\n        });\n      };\n    }\n\n    loadExcludedUrls(bearerExcludedUrls) {\n      const excludedUrls = [];\n\n      for (const item of bearerExcludedUrls) {\n        let excludedUrl;\n\n        if (typeof item === 'string') {\n          excludedUrl = {\n            urlPattern: new RegExp(item, 'i'),\n            httpMethods: []\n          };\n        } else {\n          excludedUrl = {\n            urlPattern: new RegExp(item.url, 'i'),\n            httpMethods: item.httpMethods\n          };\n        }\n\n        excludedUrls.push(excludedUrl);\n      }\n\n      return excludedUrls;\n    }\n\n    initServiceValues({\n      enableBearerInterceptor = true,\n      loadUserProfileAtStartUp = false,\n      bearerExcludedUrls = [],\n      authorizationHeaderName = 'Authorization',\n      bearerPrefix = 'Bearer',\n      initOptions,\n      updateMinValidity = 20,\n      shouldAddToken = () => true,\n      shouldUpdateToken = () => true\n    }) {\n      this._enableBearerInterceptor = enableBearerInterceptor;\n      this._loadUserProfileAtStartUp = loadUserProfileAtStartUp;\n      this._authorizationHeaderName = authorizationHeaderName;\n      this._bearerPrefix = bearerPrefix.trim().concat(' ');\n      this._excludedUrls = this.loadExcludedUrls(bearerExcludedUrls);\n      this._silentRefresh = initOptions ? initOptions.flow === 'implicit' : false;\n      this._updateMinValidity = updateMinValidity;\n      this.shouldAddToken = shouldAddToken;\n      this.shouldUpdateToken = shouldUpdateToken;\n    }\n\n    init(options = {}) {\n      return __awaiter(this, void 0, void 0, function* () {\n        this.initServiceValues(options);\n        const {\n          config,\n          initOptions\n        } = options;\n        this._instance = new Keycloak(config);\n        this.bindsKeycloakEvents();\n        const authenticated = yield this._instance.init(initOptions);\n\n        if (authenticated && this._loadUserProfileAtStartUp) {\n          yield this.loadUserProfile();\n        }\n\n        return authenticated;\n      });\n    }\n\n    login(options = {}) {\n      return __awaiter(this, void 0, void 0, function* () {\n        yield this._instance.login(options);\n\n        if (this._loadUserProfileAtStartUp) {\n          yield this.loadUserProfile();\n        }\n      });\n    }\n\n    logout(redirectUri) {\n      return __awaiter(this, void 0, void 0, function* () {\n        const options = {\n          redirectUri\n        };\n        yield this._instance.logout(options);\n        this._userProfile = undefined;\n      });\n    }\n\n    register(options = {\n      action: 'register'\n    }) {\n      return __awaiter(this, void 0, void 0, function* () {\n        yield this._instance.register(options);\n      });\n    }\n\n    isUserInRole(role, resource) {\n      let hasRole;\n      hasRole = this._instance.hasResourceRole(role, resource);\n\n      if (!hasRole) {\n        hasRole = this._instance.hasRealmRole(role);\n      }\n\n      return hasRole;\n    }\n\n    getUserRoles(allRoles = true) {\n      let roles = [];\n\n      if (this._instance.resourceAccess) {\n        for (const key in this._instance.resourceAccess) {\n          if (this._instance.resourceAccess.hasOwnProperty(key)) {\n            const resourceAccess = this._instance.resourceAccess[key];\n            const clientRoles = resourceAccess['roles'] || [];\n            roles = roles.concat(clientRoles);\n          }\n        }\n      }\n\n      if (allRoles && this._instance.realmAccess) {\n        const realmRoles = this._instance.realmAccess['roles'] || [];\n        roles.push(...realmRoles);\n      }\n\n      return roles;\n    }\n\n    isLoggedIn() {\n      return __awaiter(this, void 0, void 0, function* () {\n        if (!this._instance) {\n          return false;\n        }\n\n        return this._instance.authenticated;\n      });\n    }\n\n    isTokenExpired(minValidity = 0) {\n      return this._instance.isTokenExpired(minValidity);\n    }\n\n    updateToken(minValidity = this._updateMinValidity) {\n      return __awaiter(this, void 0, void 0, function* () {\n        if (this._silentRefresh) {\n          if (this.isTokenExpired()) {\n            throw new Error('Failed to refresh the token, or the session is expired');\n          }\n\n          return true;\n        }\n\n        if (!this._instance) {\n          throw new Error('Keycloak Angular library is not initialized.');\n        }\n\n        try {\n          return yield this._instance.updateToken(minValidity);\n        } catch (error) {\n          return false;\n        }\n      });\n    }\n\n    loadUserProfile(forceReload = false) {\n      return __awaiter(this, void 0, void 0, function* () {\n        if (this._userProfile && !forceReload) {\n          return this._userProfile;\n        }\n\n        if (!this._instance.authenticated) {\n          throw new Error('The user profile was not loaded as the user is not logged in.');\n        }\n\n        return this._userProfile = yield this._instance.loadUserProfile();\n      });\n    }\n\n    getToken() {\n      return __awaiter(this, void 0, void 0, function* () {\n        return this._instance.token;\n      });\n    }\n\n    getUsername() {\n      if (!this._userProfile) {\n        throw new Error('User not logged in or user profile was not loaded.');\n      }\n\n      return this._userProfile.username;\n    }\n\n    clearToken() {\n      this._instance.clearToken();\n    }\n\n    addTokenToHeader(headers = new HttpHeaders()) {\n      return from(this.getToken()).pipe(map(token => token ? headers.set(this._authorizationHeaderName, this._bearerPrefix + token) : headers));\n    }\n\n    getKeycloakInstance() {\n      return this._instance;\n    }\n\n    get excludedUrls() {\n      return this._excludedUrls;\n    }\n\n    get enableBearerInterceptor() {\n      return this._enableBearerInterceptor;\n    }\n\n    get keycloakEvents$() {\n      return this._keycloakEvents$;\n    }\n\n  }\n\n  KeycloakService.ɵfac = function KeycloakService_Factory(t) {\n    return new (t || KeycloakService)();\n  };\n\n  KeycloakService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: KeycloakService,\n    factory: KeycloakService.ɵfac\n  });\n  return KeycloakService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet KeycloakBearerInterceptor = /*#__PURE__*/(() => {\n  class KeycloakBearerInterceptor {\n    constructor(keycloak) {\n      this.keycloak = keycloak;\n    }\n\n    conditionallyUpdateToken(req) {\n      return __awaiter(this, void 0, void 0, function* () {\n        if (this.keycloak.shouldUpdateToken(req)) {\n          return yield this.keycloak.updateToken();\n        }\n\n        return true;\n      });\n    }\n\n    isUrlExcluded({\n      method,\n      url\n    }, {\n      urlPattern,\n      httpMethods\n    }) {\n      const httpTest = httpMethods.length === 0 || httpMethods.join().indexOf(method.toUpperCase()) > -1;\n      const urlTest = urlPattern.test(url);\n      return httpTest && urlTest;\n    }\n\n    intercept(req, next) {\n      const {\n        enableBearerInterceptor,\n        excludedUrls\n      } = this.keycloak;\n\n      if (!enableBearerInterceptor) {\n        return next.handle(req);\n      }\n\n      const shallPass = !this.keycloak.shouldAddToken(req) || excludedUrls.findIndex(item => this.isUrlExcluded(req, item)) > -1;\n\n      if (shallPass) {\n        return next.handle(req);\n      }\n\n      return combineLatest([this.conditionallyUpdateToken(req), this.keycloak.isLoggedIn()]).pipe(mergeMap(([_, isLoggedIn]) => isLoggedIn ? this.handleRequestWithTokenHeader(req, next) : next.handle(req)));\n    }\n\n    handleRequestWithTokenHeader(req, next) {\n      return this.keycloak.addTokenToHeader(req.headers).pipe(mergeMap(headersWithBearer => {\n        const kcReq = req.clone({\n          headers: headersWithBearer\n        });\n        return next.handle(kcReq);\n      }));\n    }\n\n  }\n\n  KeycloakBearerInterceptor.ɵfac = function KeycloakBearerInterceptor_Factory(t) {\n    return new (t || KeycloakBearerInterceptor)(i0.ɵɵinject(KeycloakService));\n  };\n\n  KeycloakBearerInterceptor.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: KeycloakBearerInterceptor,\n    factory: KeycloakBearerInterceptor.ɵfac\n  });\n  return KeycloakBearerInterceptor;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet CoreModule = /*#__PURE__*/(() => {\n  class CoreModule {}\n\n  CoreModule.ɵfac = function CoreModule_Factory(t) {\n    return new (t || CoreModule)();\n  };\n\n  CoreModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: CoreModule\n  });\n  CoreModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [KeycloakService, {\n      provide: HTTP_INTERCEPTORS,\n      useClass: KeycloakBearerInterceptor,\n      multi: true\n    }],\n    imports: [CommonModule]\n  });\n  return CoreModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet KeycloakAngularModule = /*#__PURE__*/(() => {\n  class KeycloakAngularModule {}\n\n  KeycloakAngularModule.ɵfac = function KeycloakAngularModule_Factory(t) {\n    return new (t || KeycloakAngularModule)();\n  };\n\n  KeycloakAngularModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: KeycloakAngularModule\n  });\n  KeycloakAngularModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [CoreModule]\n  });\n  return KeycloakAngularModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nexport { CoreModule, KeycloakAngularModule, KeycloakAuthGuard, KeycloakBearerInterceptor, KeycloakEventType, KeycloakService }; //# sourceMappingURL=keycloak-angular.mjs.map","map":null,"metadata":{},"sourceType":"module"}