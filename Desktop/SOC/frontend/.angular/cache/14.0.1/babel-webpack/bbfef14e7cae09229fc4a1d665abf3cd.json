{"ast":null,"code":"import { Injectable, Directive, Input, Inject, LOCALE_ID, TemplateRef, ViewContainerRef, forwardRef, ElementRef, Renderer2, NgModule } from '@angular/core';\nimport { getLocaleNumberSymbol, NumberSymbol, DecimalPipe, CommonModule } from '@angular/common';\nimport { FormArray, FormControl, FormGroup, FormBuilder, NG_VALIDATORS, NG_VALUE_ACCESSOR, NG_ASYNC_VALIDATORS, FormsModule, ReactiveFormsModule, AbstractControl } from '@angular/forms';\nimport { of } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common';\nconst CONTROLS_ERROR = \"controlsError\";\nconst VALUE_CHANGED_SYNC = \"valueChangedSync\";\nconst FUNCTION_STRING = \"function\";\nconst OBJECT_STRING = \"object\";\nconst RX_WEB_VALIDATOR = \"rxwebValidator\";\nconst NUMBER = \"number\";\nconst BOOLEAN$1 = \"boolean\";\nconst CUSTOM = \"custom\";\nconst TEMPLATE_VALIDATION_CONFIG = \"template-validation-config\";\nconst CONDITIONAL_VALIDATOR = \"conditionalValidator\";\nconst VALIDATOR_CONFIG$2 = \"validatorConfig\";\nconst THIS = \"this\";\nconst RXCODE = \"-rxw-\";\nconst MODEL = \"model\";\nconst MODEL_INSTANCE = \"modelInstance\";\nconst PATCH = \"patch\";\n\nclass Linq {\n  static functionCreator(expression) {\n    var functionSetter = [];\n    var match = expression.match(/^\\s*\\(?\\s*([^)]*)\\s*\\)?\\s*=>(.*)/);\n    var splitSelect = match[2].split(\",\");\n\n    for (var i = 0; i < splitSelect.length; i++) {\n      var equalToOperator = splitSelect[i].match(/^\\s*\\(?\\s*([^)]*)\\s*\\)?\\s*|===|!==|==|!=|>=|>|<=|<|(.*)/);\n\n      if (equalToOperator !== null) {\n        functionSetter = new Function(match[1], \"return \" + equalToOperator.input);\n      } else {\n        equalToOperator = splitSelect[i].match(/^\\s*\\(?\\s*([^)]*)\\s*\\)?\\s*=(.*)/);\n\n        if (equalToOperator === null) {\n          functionSetter = new Function(match[1], \"return \" + splitSelect.input);\n        } else {\n          functionSetter = new Function(match[1], \"return \" + equalToOperator.input);\n        }\n      }\n    }\n\n    if (splitSelect.length == 0) functionSetter = {\n      accessFunction: new Function(match[1], \"return \" + match[2])\n    };\n    return functionSetter;\n  }\n\n  static execute(jObject, config, parentObject, modelInstance, isDynamicConfig) {\n    let expressionFunction = isDynamicConfig ? config.dynamicConfig : config.conditionalExpression;\n    let lastParam = isDynamicConfig ? config : modelInstance;\n    if (parentObject && typeof expressionFunction == \"string\") expressionFunction = Linq.functionCreator(expressionFunction);\n    if (parentObject && expressionFunction) return modelInstance && modelInstance.constructor !== Object ? expressionFunction.call(modelInstance, parentObject, jObject, lastParam) : expressionFunction(parentObject, jObject, lastParam);\n    return true;\n  }\n\n  static getConditionPath(texts) {\n    let path = \"\";\n\n    for (var i = 1; i < texts.length; i++) path += texts.length - 1 == i ? texts[i].trim() : `${texts[i].trim()}.`;\n\n    return path;\n  }\n\n  static expressionParser(expression, isNonValidationExpression) {\n    let splitExpressions = [];\n    let columns = [];\n    let expressionString = expression.toString();\n    let expressionArguments = Linq.extractArguments(expressionString);\n\n    if (expressionArguments.length > 0) {\n      let splitTexts = [];\n      expressionString.replace(/\\s/g, '').replace(new RegExp(/{|}/, \"g\"), \"\").split(new RegExp(/return|===|!==|==|!=|>=|>|<=|<|&&/)).forEach(t => {\n        let texts = t.replace(/\\(|\\)/g, \"\").split(\"||\");\n\n        for (let text of texts) splitTexts.push(text);\n      });\n      splitTexts.forEach(t => {\n        expressionArguments.forEach((x, i) => {\n          t = t.trim();\n\n          if (t.startsWith(x + '.')) {\n            var splitText = t.split('.');\n            if (splitText.length == 2 || splitText.length >= 2 && isNonValidationExpression) {\n              if (!isNonValidationExpression) columns.push({\n                propName: splitText[1].trim(),\n                argumentIndex: i == 3 ? 0 : i == 2 ? 1 : i == 1 ? -1 : i\n              });else columns.push({\n                propName: this.getConditionPath(splitText),\n                argumentIndex: i == 3 ? 0 : i == 2 ? 1 : i == 1 ? -1 : i\n              });\n            } else {\n              var arrayProp = splitText[1].split('[');\n              let jObject = {\n                propName: splitText[splitText.length - 1].trim(),\n                objectPropName: arrayProp[0],\n                arrayIndex: arrayProp.length > 1 ? arrayProp[1].replace(\"]\", \"\") : undefined,\n                argumentIndex: i === 3 ? 0 : i === 2 ? 1 : i\n              };\n              columns.push(jObject);\n            }\n          }\n        });\n      });\n    }\n\n    return columns;\n  }\n\n  static extractArguments(splitText) {\n    let expressionArguments = [THIS];\n\n    if (splitText[0].trim() !== \"(\" && !splitText.trim().startsWith(\"function\")) {\n      let text = splitText[0].split(\"=>\")[0];\n      expressionArguments.push(text.trim().replace(\"(\", \"\").replace(\")\", \"\"));\n    } else {\n      let splitTexts = splitText.match(/\\(([^)]+)\\)/g);\n      if (splitTexts && splitTexts[0]) splitTexts[0].split(\",\").forEach(t => expressionArguments.push(t.trim().replace(\"(\", \"\").replace(\")\", \"\")));\n    }\n\n    return expressionArguments;\n  }\n\n  static expressionColumns(expression, isNonValidationExpression = false) {\n    var columns = [];\n    let splitExpressions = [];\n\n    if (typeof expression == \"string\") {\n      expression.split(\"=>\")[1].split(\" && \").forEach(t => {\n        t.split(\" || \").forEach(x => {\n          splitExpressions.push(x.trim().split(' ')[0]);\n        });\n      });\n      splitExpressions.forEach(t => {\n        var splitText = t.split('.');\n        if (splitText.length == 2) columns.push({\n          propName: splitText[1].trim()\n        });else {\n          var arrayProp = splitText[1].split('[');\n          let jObject = {\n            propName: splitText[splitText.length - 1].trim(),\n            objectPropName: arrayProp[0],\n            arrayIndex: arrayProp.length > 1 ? arrayProp[1].replace(\"]\", \"\") : undefined\n          };\n          columns.push(jObject);\n        }\n      });\n    } else {\n      columns = Linq.expressionParser(expression, isNonValidationExpression);\n    }\n\n    return columns;\n  }\n\n  static dynamicConfigParser(expression, propName) {\n    let controlNames = [];\n    let expressionString = expression.toString();\n    let expressionArguments = Linq.extractArguments(expressionString);\n    let splitString = expressionString.replace(new RegExp(/\\r?\\n|\\r|;/g), ' ').replace(/[\"%()\\{}=\\\\?�`'#<>|,;:+-]+/g, \" \").split(/ /g);\n    if (expressionArguments.length > 3) expressionArguments.splice(expressionArguments.length - 1, 1);\n    expressionArguments.forEach(t => {\n      splitString.filter(x => x != `${t}.${propName}` && x.startsWith(`${t}.`)).forEach(x => {\n        let split = x.split('.');\n        if (split.length == 2) controlNames.push({\n          propName: x.replace(`${t}.`, '')\n        });else {\n          var arrayProp = split[1].split('[');\n          let jObject = {\n            propName: split[split.length - 1].trim(),\n            objectPropName: arrayProp[0],\n            arrayIndex: arrayProp.length > 1 ? arrayProp[1].replace(\"]\", \"\") : undefined\n          };\n          controlNames.push(jObject);\n        }\n      });\n    });\n    return controlNames;\n  }\n\n}\n\nconst AnnotationTypes = {\n  numeric: 'numeric',\n  required: 'required',\n  minLength: 'minLength',\n  maxLength: 'maxLength',\n  minNumber: 'minNumber',\n  maxNumber: 'maxNumber',\n  pattern: 'pattern',\n  password: 'password',\n  compare: 'compare',\n  minDate: 'minDate',\n  maxDate: 'maxDate',\n  alpha: 'alpha',\n  alphaNumeric: 'alphaNumeric',\n  email: 'email',\n  hexColor: 'hexColor',\n  lowerCase: 'lowerCase',\n  url: 'url',\n  upperCase: 'upperCase',\n  nested: 'nested',\n  propArray: 'propArray',\n  propObject: 'propObject',\n  contains: 'contains',\n  range: 'range',\n  custom: 'custom',\n  digit: \"digit\",\n  creditCard: \"creditCard\",\n  time: \"time\",\n  json: \"json\",\n  greaterThan: \"greaterThan\",\n  greaterThanEqualTo: \"greaterThanEqualTo\",\n  lessThan: \"lessThan\",\n  lessThanEqualTo: \"lessThanEqualTo\",\n  choice: \"choice\",\n  different: \"different\",\n  even: \"even\",\n  odd: \"odd\",\n  factor: \"factor\",\n  leapYear: \"leapYear\",\n  allOf: \"allOf\",\n  oneOf: \"oneOf\",\n  noneOf: \"noneOf\",\n  mac: \"mac\",\n  ascii: \"ascii\",\n  dataUri: \"dataUri\",\n  port: \"port\",\n  latLong: \"latLong\",\n  extension: \"extension\",\n  fileSize: \"fileSize\",\n  endsWith: \"endsWith\",\n  startsWith: \"startsWith\",\n  primeNumber: \"primeNumber\",\n  latitude: \"latitude\",\n  longitude: \"longitude\",\n  compose: \"compose\",\n  rule: \"rule\",\n  file: \"file\",\n  image: \"image\",\n  unique: \"unique\",\n  notEmpty: \"notEmpty\",\n  ip: \"ip\",\n  cusip: \"cusip\",\n  grid: \"grid\",\n  date: 'date',\n  and: 'and',\n  or: 'or',\n  not: 'not',\n  minTime: 'minTime',\n  maxTime: 'maxTime',\n  requiredTrue: 'requiredTrue',\n  mask: 'mask',\n  iban: 'iban',\n  updateOn: 'updateOn'\n};\nconst INVALID = \"INVALID\";\nconst PROPERTY = \"property\";\nconst OBJECT_PROPERTY = \"objectProperty\";\nconst ARRAY_PROPERTY = \"arrayProperty\";\nconst STRING = \"string\";\nconst MESSAGE = \"message\";\nconst BLANK = \"\";\nconst KEYPRESS = \"onkeypress\";\nconst ONCHANGE = \"onchange\";\nconst ONCLICK = \"onclick\";\nconst ONKEYUP = \"onkeyup\";\nconst ONBLUR = \"onblur\";\nconst ONFOCUS = \"onfocus\";\nconst ELEMENT_VALUE = \"value\";\nconst BLUR = \"blur\";\nconst FOCUS = \"focus\";\nconst CHANGE = \"change\";\nconst KEY_DOWN = \"keydown\";\nconst KEY_PRESS = \"keypress\";\nconst PASTE = \"paste\";\nconst INPUT = \"INPUT\";\nconst SELECT = \"SELECT\";\nconst CHECKBOX = \"checkbox\";\nconst RADIO = \"radio\";\nconst FILE = \"file\";\nconst TEXTAREA = \"textarea\";\nconst ValidationAlphabetLocale = {\n  'danish': 'danish',\n  'french': 'french',\n  'german': 'german',\n  'greek': 'greek',\n  'spanish': 'spanish',\n  'russian': 'russian'\n};\nconst DECORATORS = {\n  disabled: 'disabled',\n  error: 'error',\n  trim: 'trim',\n  ltrim: 'ltrim',\n  rtrim: 'rtrim',\n  blacklist: 'blacklist',\n  stripLow: 'stripLow',\n  toBoolean: 'toBoolean',\n  toDate: 'toDate',\n  toDouble: 'toDouble',\n  toFloat: 'toFloat',\n  toInt: 'toInt',\n  string: 'toString',\n  whitelist: 'whitelist',\n  escape: 'escape',\n  prefix: 'prefix',\n  suffix: 'suffix',\n  sanitize: 'sanitize',\n  elementClass: 'elementClass',\n  updateOn: 'updateOn'\n};\nconst defaultContainer = new class {\n  constructor() {\n    this.instances = [];\n    this.modelIncrementCount = 0;\n  }\n\n  get(instanceFunc) {\n    let instance = this.instances.filter(instance => instance.instance === instanceFunc)[0];\n    return instance;\n  }\n\n  getInstance(target, parameterIndex, propertyKey, decoratorType) {\n    let isPropertyKey = propertyKey != undefined;\n    let instanceFunc = !isPropertyKey ? target : target.constructor;\n    let instance = this.instances.filter(instance => instance.instance === instanceFunc)[0];\n    if (!instance) instance = this.addInstanceContainer(instanceFunc);\n    return instance;\n  }\n\n  addPropsConfig(target, configs) {\n    let instanceContainer = this.instances.filter(instance => instance.instance == target)[0];\n\n    if (instanceContainer) {\n      for (let config of configs) {\n        for (let prop of config.propNames) {\n          let propertyInfo = instanceContainer.properties.filter(t => t.name == prop && t.propertyType !== OBJECT_PROPERTY && t.propertyType !== ARRAY_PROPERTY)[0];\n\n          if (propertyInfo) {\n            this.addPropConfig(target, [propertyInfo], config);\n          } else if (prop === \":all:\") this.addPropConfig(target, instanceContainer.properties.filter(t => t.propertyType !== OBJECT_PROPERTY && t.propertyType !== ARRAY_PROPERTY), config);\n        }\n      }\n    } else if (configs === undefined) this.addInstanceContainer(target);\n  }\n\n  addPropConfig(target, properties, config) {\n    for (var propertyInfo of properties) {\n      let excludeProp = false;\n      if (config.excludePropNames) excludeProp = config.excludePropNames.filter(t => t == propertyInfo.name)[0] !== undefined;\n\n      if (!excludeProp) {\n        if (config.validationConfig) for (let typeName in config.validationConfig) {\n          this.init({\n            constructor: target\n          }, 0, propertyInfo.name, typeName, config.validationConfig[typeName] === true ? undefined : config.validationConfig[typeName], false);\n        }\n        if (config.error) this.addDecoratorConfig({\n          constructor: target\n        }, 0, propertyInfo.name, config.error, DECORATORS.error);\n        if (config.disable) this.addDecoratorConfig({\n          constructor: target\n        }, 0, propertyInfo.name, config.disable, DECORATORS.disabled);\n        if (config.elementClass) this.addDecoratorConfig({\n          constructor: target\n        }, 0, propertyInfo.name, config.elementClass, DECORATORS.elementClass);\n        if (config.ignore) propertyInfo.ignore = config.ignore;\n      }\n    }\n  }\n\n  addSanitizer(target, parameterIndex, propertyKey, decoratorType, value) {\n    let instance = this.getInstance(target, parameterIndex, propertyKey, decoratorType);\n\n    if (instance) {\n      if (!instance.sanitizers[propertyKey]) instance.sanitizers[propertyKey] = [];\n      instance.sanitizers[propertyKey].push({\n        name: decoratorType,\n        config: value\n      });\n    }\n  }\n\n  addDecoratorConfig(target, parameterIndex, propertyKey, config, decoratorType) {\n    let isPropertyKey = propertyKey != undefined;\n    let instanceFunc = !isPropertyKey ? target : target.constructor;\n    let instance = this.instances.filter(instance => instance.instance === instanceFunc)[0];\n    if (!instance) instance = this.addInstanceContainer(instanceFunc);\n    instance.nonValidationDecorators[decoratorType].conditionalExpressions[propertyKey] = config.conditionalExpression;\n    let columns = Linq.expressionColumns(config.conditionalExpression, true);\n    columns.forEach(column => {\n      if (column.argumentIndex !== -1) {\n        let columnName = !column.objectPropName ? `${column.propName}${RXCODE}${column.argumentIndex}` : `${column.objectPropName}.${column.propName}${RXCODE}${column.argumentIndex}`;\n        if (!instance.nonValidationDecorators[decoratorType].changeDetection[columnName]) instance.nonValidationDecorators[decoratorType].changeDetection[columnName] = [];\n        let disabledColumns = instance.nonValidationDecorators[decoratorType].changeDetection[columnName];\n        if (disabledColumns.indexOf(columnName) === -1) disabledColumns.push(propertyKey);\n      } else {\n        if (!instance.nonValidationDecorators[decoratorType].controlProp[propertyKey]) instance.nonValidationDecorators[decoratorType].controlProp[propertyKey] = {};\n        instance.nonValidationDecorators[decoratorType].controlProp[propertyKey][column.propName.replace(\";\", \"\")] = true;\n      }\n    });\n  }\n\n  init(target, parameterIndex, propertyKey, annotationType, config, isAsync) {\n    var decoratorConfiguration = {\n      propertyIndex: parameterIndex,\n      propertyName: propertyKey,\n      annotationType: annotationType,\n      config: config,\n      isAsync: isAsync,\n      isValidator: annotationType !== \"updateOn\"\n    };\n    let isPropertyKey = propertyKey != undefined;\n    this.addAnnotation(!isPropertyKey ? target : target.constructor, decoratorConfiguration);\n  }\n\n  initPropertyObject(name, propertyType, entity, target, config) {\n    var propertyInfo = {\n      name: name,\n      propertyType: propertyType,\n      entity: entity,\n      dataPropertyName: config ? config.name : undefined,\n      entityProvider: config ? config.entityProvider : undefined,\n      defaultValue: config ? config.defaultValue : undefined,\n      objectConfig: config && config.autoCreate ? {\n        autoCreate: config.autoCreate\n      } : undefined\n    };\n    defaultContainer.addProperty(target.constructor, propertyInfo);\n  }\n\n  addInstanceContainer(instanceFunc) {\n    let instanceContainer = {\n      instance: instanceFunc,\n      propertyAnnotations: [],\n      properties: [],\n      nonValidationDecorators: {\n        disabled: {\n          conditionalExpressions: {},\n          changeDetection: {},\n          controlProp: {}\n        },\n        error: {\n          conditionalExpressions: {},\n          changeDetection: {},\n          controlProp: {}\n        },\n        elementClass: {\n          conditionalExpressions: {},\n          changeDetection: {},\n          controlProp: {}\n        }\n      },\n      sanitizers: {}\n    };\n    this.instances.push(instanceContainer);\n    return instanceContainer;\n  }\n\n  addProperty(instanceFunc, propertyInfo, isFromAnnotation = false) {\n    let instance = this.instances.filter(instance => instance.instance === instanceFunc)[0];\n\n    if (instance) {\n      this.addPropertyInfo(instance, propertyInfo, !isFromAnnotation);\n    } else {\n      instance = this.addInstanceContainer(instanceFunc);\n      this.addPropertyInfo(instance, propertyInfo);\n    }\n  }\n\n  addPropertyInfo(instance, propertyInfo, isAddProperty = false) {\n    var property = this.getProperty(instance, propertyInfo);\n    if (!property) instance.properties.push(propertyInfo);else if (isAddProperty) this.updateProperty(property, propertyInfo);\n    if (property && propertyInfo.messageNexus) property.messageNexus = propertyInfo.messageNexus;\n  }\n\n  addAnnotation(instanceFunc, decoratorConfiguration) {\n    this.addProperty(instanceFunc, {\n      propertyType: PROPERTY,\n      name: decoratorConfiguration.propertyName\n    }, true);\n    let instance = this.instances.filter(instance => instance.instance === instanceFunc)[0];\n    if (instance) instance.propertyAnnotations.push(decoratorConfiguration);else {\n      instance = this.addInstanceContainer(instanceFunc);\n      instance.propertyAnnotations.push(decoratorConfiguration);\n    }\n\n    if (decoratorConfiguration.config && decoratorConfiguration.config.conditionalExpression) {\n      let columns = Linq.expressionColumns(decoratorConfiguration.config.conditionalExpression);\n      this.addChangeValidation(instance, decoratorConfiguration.propertyName, columns);\n    }\n\n    if (decoratorConfiguration.config && decoratorConfiguration.config.dynamicConfig) {\n      let columns = Linq.dynamicConfigParser(decoratorConfiguration.config.dynamicConfig, decoratorConfiguration.propertyName);\n      this.addChangeValidation(instance, decoratorConfiguration.propertyName, columns);\n    }\n\n    this.setConditionalColumns(instance, decoratorConfiguration);\n  }\n\n  setConditionalColumns(instance, decoratorConfiguration) {\n    if (instance && decoratorConfiguration.config) {\n      if (decoratorConfiguration.annotationType == AnnotationTypes.and || decoratorConfiguration.annotationType == AnnotationTypes.or || decoratorConfiguration.annotationType == AnnotationTypes.not) {\n        Object.keys(decoratorConfiguration.config.validation).forEach(t => {\n          if (typeof decoratorConfiguration.config.validation[t] !== \"boolean\") this.setLogicalConditional(instance, t, decoratorConfiguration.config.validation[t].fieldName, decoratorConfiguration.propertyName);\n        });\n      } else this.setLogicalConditional(instance, decoratorConfiguration.annotationType, decoratorConfiguration.config.fieldName, decoratorConfiguration.propertyName);\n    }\n  }\n\n  setLogicalConditional(instance, annotationType, fieldName, propertyName) {\n    if (instance && (annotationType == AnnotationTypes.compare || annotationType == AnnotationTypes.greaterThan || annotationType == AnnotationTypes.greaterThanEqualTo || annotationType == AnnotationTypes.lessThan || annotationType == AnnotationTypes.lessThanEqualTo || annotationType == AnnotationTypes.different || annotationType == AnnotationTypes.factor || annotationType == AnnotationTypes.minTime || annotationType == AnnotationTypes.maxTime || annotationType == AnnotationTypes.creditCard && fieldName || (annotationType == AnnotationTypes.minDate || annotationType == AnnotationTypes.maxDate) && fieldName)) {\n      this.setConditionalValueProp(instance, fieldName, propertyName);\n    }\n  }\n\n  setConditionalValueProp(instance, propName, refPropName) {\n    if (propName) {\n      let splitProps = propName.split ? propName.split('.') : '';\n\n      if (splitProps.length < 2) {\n        if (!instance.conditionalValidationProps) instance.conditionalValidationProps = {};\n        if (!instance.conditionalValidationProps[propName]) instance.conditionalValidationProps[propName] = [];\n        if (instance.conditionalValidationProps[propName].indexOf(refPropName) == -1) instance.conditionalValidationProps[propName].push(refPropName);\n      } else this.addChangeValidation(instance, refPropName, [{\n        argumentIndex: 1,\n        objectPropName: splitProps[0],\n        propName: splitProps[1],\n        referencePropName: refPropName\n      }]);\n    }\n  }\n\n  addChangeValidation(instance, propertyName, columns) {\n    if (instance) {\n      if (!instance.conditionalValidationProps) instance.conditionalValidationProps = {};\n      columns.forEach(t => {\n        if (t.propName && !t.objectPropName) {\n          if (!instance.conditionalValidationProps[t.propName]) instance.conditionalValidationProps[t.propName] = [];\n          if (instance.conditionalValidationProps[t.propName].indexOf(propertyName) == -1) instance.conditionalValidationProps[t.propName].push(propertyName);\n        } else {\n          if (t.propName && t.objectPropName) {\n            if (!instance.conditionalObjectProps) instance.conditionalObjectProps = [];\n            t.referencePropName = propertyName;\n            instance.conditionalObjectProps.push(t);\n          }\n        }\n      });\n    }\n  }\n\n  clearInstance(instanceFunc) {\n    let instance = this.instances.filter(instance => instance.instance === instanceFunc)[0];\n\n    if (instance) {\n      let indexOf = this.instances.indexOf(instance);\n      this.instances.splice(indexOf, 1);\n    }\n  }\n\n  getProperty(instance, propertyInfo) {\n    return instance.properties.filter(t => t.name == propertyInfo.name)[0];\n  }\n\n  updateProperty(property, currentProperty) {\n    property.dataPropertyName = currentProperty.dataPropertyName;\n    property.defaultValue = currentProperty.defaultValue;\n  }\n\n}();\nconst RegExRule = {\n  alpha: /^[a-zA-Z]+$/,\n  alphaExits: /[a-zA-Z]/,\n  alphaWithSpace: /^[a-zA-Z\\s]+$/,\n  macId: /^([0-9a-fA-F][0-9a-fA-F]:){5}([0-9a-fA-F][0-9a-fA-F])$/,\n  onlyDigit: /^[0-9]+$/,\n  isDigitExits: /[0-9]/,\n  lowerCase: /[a-z]/,\n  upperCase: /[A-Z]/,\n  specialCharacter: /[`~!@#$%^&*()_|+\\-=?;:'\",.<>\\{\\}\\[\\]\\\\\\/]/gi,\n  advancedEmail: /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/,\n  basicEmail: /^(([^<>()\\[\\]\\\\.,,:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/,\n  alphaNumeric: /^[0-9a-zA-Z]+$/,\n  alphaNumericWithSpace: /^[0-9a-zA-Z\\s]+$/,\n  hexColor: /^#?([0-9A-F]{3}|[0-9A-F]{6})$/i,\n  strictHexColor: /^#?([0-9A-F]{3}|[0-9A-F]{6})$/i,\n  float: /^(?:[-+]?(?:[0-9]+))?(?:\\.[0-9]*)?(?:[eE][\\+\\-]?(?:[0-9]+))?$/,\n  decimal: /^[-+]?([0-9]+|\\.[0-9]+|[0-9]+\\.[0-9]+)$/,\n  hexaDecimal: /^[0-9A-F]+$/i,\n  date: /^(?:(?:31(\\/|-|\\.)(?:0?[13578]|1[02]))\\1|(?:(?:29|30)(\\/|-|\\.)(?:0?[1,3-9]|1[0-2])\\2))(?:(?:1[6-9]|[2-9]\\d)?\\d{2})$|^(?:29(\\/|-|\\.)0?2\\3(?:(?:(?:1[6-9]|[2-9]\\d)?(?:0[48]|[2468][048]|[13579][26])|(?:(?:16|[2468][048]|[3579][26])00))))$|^(?:0?[1-9]|1\\d|2[0-8])(\\/|-|\\.)(?:(?:0?[1-9])|(?:1[0-2]))\\4(?:(?:1[6-9]|[2-9]\\d)?\\d{2})$/,\n  time: /^([01]?[0-9]|2[0-3]):[0-5][0-9]$/,\n  timeWithSeconds: /^([01]?[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]$/,\n  url: /^(https?:\\/\\/(?:www\\.|(?!www)|(?!a-zA-Z))[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9]\\.[^\\s]{2,}|www\\.[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9]\\.[^\\s]{2,}|https?:\\/\\/(?:www\\.|(?!www)|(?!a-zA-Z))[a-zA-Z0-9]\\.[^\\s]{2,}|www\\.[a-zA-Z0-9]\\.[^\\s]{2,})$/,\n  localhostUrl: /^(https?:\\/\\/localhost\\:([1-9][0-9]{0,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5])|localhost\\::([1-9][0-9]{0,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5])|https?:\\/\\/localhost\\::([1-9][0-9]{0,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5]))$/,\n  interanetUrl: /^(https?:\\/\\/[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9])$/,\n  ascii: /^[\\x00-\\x7F]+$/,\n  dataUri: /^data:([a-z]+\\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\\-._~:@\\/?%\\s]*?)$/i,\n  lat: /^\\(?[+-]?(90(\\.0+)?|[1-8]?\\d(\\.\\d+)?)$/,\n  long: /^\\s?[+-]?(180(\\.0+)?|1[0-7]\\d(\\.\\d+)?|\\d{1,2}(\\.\\d+)?)\\)?$/,\n  ipV4: /^(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})$/,\n  ipV6: /^((?:[a-fA-F\\d]{1,4}:){7}(?:[a-fA-F\\d]{1,4}|:)|(?:[a-fA-F\\d]{1,4}:){6}(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|:[a-fA-F\\d]{1,4}|:)|(?:[a-fA-F\\d]{1,4}:){5}(?::(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(:[a-fA-F\\d]{1,4}){1,2}|:)|(?:[a-fA-F\\d]{1,4}:){4}(?:(:[a-fA-F\\d]{1,4}){0,1}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(:[a-fA-F\\d]{1,4}){1,3}|:)|(?:[a-fA-F\\d]{1,4}:){3}(?:(:[a-fA-F\\d]{1,4}){0,2}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(:[a-fA-F\\d]{1,4}){1,4}|:)|(?:[a-fA-F\\d]{1,4}:){2}(?:(:[a-fA-F\\d]{1,4}){0,3}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(:[a-fA-F\\d]{1,4}){1,5}|:)|(?:[a-fA-F\\d]{1,4}:){1}(?:(:[a-fA-F\\d]{1,4}){0,4}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(:[a-fA-F\\d]{1,4}){1,6}|:)|(?::((?::[a-fA-F\\d]{1,4}){0,5}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,7}|:)))(%[0-9a-zA-Z]{1,})?$/,\n  cidrV4: /^(3[0-2]|[12]?[0-9])$/,\n  cidrV6: /^(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,\n  cusip: /^[0-9A-Z]{9}$/,\n  grid: /^[GRID:]*([0-9A-Z]{2})[-\\s]*([0-9A-Z]{5})[-\\s]*([0-9A-Z]{10})[-\\s]*([0-9A-Z]{1})$/g\n};\nconst ALPHABET = \"alphabet\";\nconst DIGIT = \"digit\";\nconst CONTAINS = \"contains\";\nconst LOWERCASE = \"lowerCase\";\nconst UPPERCASE = \"upperCase\";\nconst SPECIAL_CHARACTER = \"specialCharacter\";\nconst MIN_LENGTH = \"minLength\";\nconst MAX_LENGTH = \"maxLength\";\n\nclass RegexValidator {\n  static isExits(value, regex) {\n    return value.match(regex) != null;\n  }\n\n  static isValid(value, regex) {\n    return regex.test(value);\n  }\n\n  static isNotBlank(value, isRemoveSpace = false) {\n    return !isRemoveSpace ? value === 0 || value !== undefined && value !== null && value !== \"\" : value === 0 || value !== undefined && value !== null && String(value).trim() !== \"\";\n  }\n\n  static isValidPassword(passwordValidation, value) {\n    let isValid = false;\n    let jObject = {};\n    let keyName = \"status\";\n    let objectProperties = Object.getOwnPropertyNames(passwordValidation);\n\n    for (let propertyName of objectProperties) {\n      switch (propertyName) {\n        case ALPHABET:\n          isValid = RegexValidator.isExits(value, RegExRule.alphaExits);\n          keyName = ALPHABET;\n          break;\n\n        case DIGIT:\n          isValid = RegexValidator.isValid(value, RegExRule.isDigitExits);\n          keyName = DIGIT;\n          break;\n\n        case CONTAINS:\n          isValid = value.indexOf(passwordValidation[CONTAINS]) != -1;\n          keyName = CONTAINS;\n          break;\n\n        case LOWERCASE:\n          isValid = RegexValidator.isValid(value, RegExRule.lowerCase);\n          keyName = LOWERCASE;\n          break;\n\n        case UPPERCASE:\n          isValid = RegexValidator.isValid(value, RegExRule.upperCase);\n          keyName = UPPERCASE;\n          break;\n\n        case SPECIAL_CHARACTER:\n          isValid = RegexValidator.isExits(value, RegExRule.specialCharacter);\n          keyName = SPECIAL_CHARACTER;\n          break;\n\n        case MIN_LENGTH:\n          isValid = value.length >= passwordValidation[propertyName];\n          keyName = MIN_LENGTH;\n          break;\n\n        case MAX_LENGTH:\n          isValid = value.length <= passwordValidation[propertyName];\n          keyName = MAX_LENGTH;\n          break;\n      }\n\n      if (!isValid) break;\n    }\n\n    return {\n      isValid: isValid,\n      keyName: keyName\n    };\n  }\n\n  static isZero(value) {\n    return value == 0;\n  }\n\n  static commaRegex() {\n    return new RegExp(\",\", \"g\");\n  }\n\n}\n\nlet ReactiveFormConfig = /*#__PURE__*/(() => {\n  class ReactiveFormConfig {\n    static set(jObject) {\n      if (jObject) ReactiveFormConfig.json = jObject;\n    }\n\n    static get(path) {\n      let jObject;\n\n      if (ReactiveFormConfig.json) {\n        let splitPath = path.split('.');\n\n        for (let columnName of splitPath) {\n          jObject = !jObject ? ReactiveFormConfig.json[columnName] : jObject[columnName];\n          if (!jObject) break;\n        }\n      }\n\n      return jObject;\n    }\n\n  }\n\n  ReactiveFormConfig.i18n = {};\n  ReactiveFormConfig.number = {};\n  ReactiveFormConfig.json = {};\n  ReactiveFormConfig.autoInstancePush = false;\n  return ReactiveFormConfig;\n})();\n\nfunction isObjectType(value) {\n  return !(typeof value == \"string\" || typeof value === \"number\" || typeof value === \"boolean\" || value instanceof Date);\n}\n\nfunction isObject(value) {\n  return Object.prototype.toString.call(value) === '[object Object]';\n}\n\nfunction clone(jsonObject) {\n  let jObject = {};\n\n  if (isObjectType(jsonObject)) {\n    for (var columnName in jsonObject) {\n      if (columnName != \"formGroup\") {\n        if (Array.isArray(jsonObject[columnName])) {\n          jObject[columnName] = [];\n\n          for (let row of jsonObject[columnName]) {\n            if (isObject(row)) jObject[columnName].push(clone(row));else jObject[columnName].push(row);\n          }\n        } else if (typeof jsonObject[columnName] == \"object\" && !(jsonObject[columnName] instanceof RegExp)) jObject[columnName] = clone(jsonObject[columnName]);else jObject[columnName] = jsonObject[columnName];\n      }\n    }\n\n    return jObject;\n  } else return jsonObject;\n}\n\nfunction merge(firstObject, secondObject) {\n  for (var columnName in secondObject) {\n    if (Array.isArray(secondObject[columnName])) {\n      if (!firstObject[columnName]) firstObject[columnName] = [];\n\n      for (let row of secondObject[columnName]) firstObject[columnName].push(clone(row));\n    } else if (typeof firstObject[columnName] == \"object\" && !(firstObject[columnName] instanceof RegExp)) firstObject[columnName] = merge(firstObject[columnName], secondObject[columnName]);else firstObject[columnName] = secondObject[columnName];\n  }\n\n  return firstObject;\n}\n\nfunction isMatched(jsonObject, compareObject) {\n  let isModified = false;\n\n  for (var columnName in compareObject) {\n    if (Array.isArray(jsonObject[columnName])) {\n      for (var i = 0; i < jsonObject[columnName].length; i++) {\n        isModified = isMatched(jsonObject[columnName][i], compareObject[columnName][i]);\n      }\n    } else if (typeof jsonObject[columnName] == \"object\" && !(jsonObject[columnName] instanceof RegExp)) isModified = isMatched(jsonObject[columnName], compareObject[columnName]);else isModified = !(jsonObject[columnName] == compareObject[columnName]);\n\n    if (isModified) break;\n  }\n\n  return isModified;\n}\n\nlet ObjectMaker = /*#__PURE__*/(() => {\n  class ObjectMaker {\n    static toJson(key, config, values) {\n      ObjectMaker.setMessage();\n      let message = config ? config.message : null;\n      let messageKey = undefined;\n      if (!message && config && config.messageKey) messageKey = config.messageKey;\n      let messageText = message ? message : ReactiveFormConfig && ReactiveFormConfig.json && ReactiveFormConfig.json.validationMessage && ReactiveFormConfig.json.validationMessage[messageKey || key] ? ReactiveFormConfig.json.validationMessage[messageKey || key] : '';\n      values.forEach((t, index) => {\n        if (t instanceof Date) t = this.getDateString(t);\n        messageText = messageText.replace(`{{${index}}}`, t);\n      });\n      if (config && config.messageNexus) Object.keys(config.messageNexus).forEach(propName => {\n        messageText = messageText.replace(`{{${propName}}}`, config.messageNexus[propName]);\n      });\n      let jObject = {};\n      jObject[key] = {\n        message: messageText,\n        refValues: values\n      };\n      if (config && config.isAddMessageKey) jObject[\"messageKey\"] = messageKey;\n      return jObject;\n    }\n\n    static null() {\n      return null;\n    }\n\n    static getPasswordMessage() {\n      let messageKey = \"password\";\n      return ReactiveFormConfig && ReactiveFormConfig.json && ReactiveFormConfig.json.validationMessage && ReactiveFormConfig.json.validationMessage[messageKey] ? ReactiveFormConfig.json.validationMessage[messageKey] : '';\n    }\n\n    static setMessage() {\n      if (ReactiveFormConfig.i18n && ReactiveFormConfig.i18n.validationMessage && ObjectMaker.language !== ReactiveFormConfig.i18n.language) {\n        if (!ReactiveFormConfig.json) ReactiveFormConfig.json = {};\n        ReactiveFormConfig.json.validationMessage = ReactiveFormConfig.i18n.validationMessage();\n        ObjectMaker.language = ReactiveFormConfig.i18n.language;\n      }\n    }\n\n    static getDateString(value) {\n      let seperator = ReactiveFormConfig && ReactiveFormConfig.json && ReactiveFormConfig.json.baseConfig && ReactiveFormConfig.json.baseConfig.seperator ? ReactiveFormConfig.json.baseConfig.seperator : \"/\";\n      let dateFormat = ReactiveFormConfig && ReactiveFormConfig.json && ReactiveFormConfig.json.baseConfig && ReactiveFormConfig.json.baseConfig.dateFormat ? ReactiveFormConfig.json.baseConfig.dateFormat : \"mdy\";\n\n      if (ReactiveFormConfig && ReactiveFormConfig.json && ReactiveFormConfig.json.internationalization && ReactiveFormConfig.json.internationalization.dateFormat && ReactiveFormConfig.json.internationalization.seperator) {\n        seperator = ReactiveFormConfig.json.internationalization.seperator;\n        dateFormat = ReactiveFormConfig.json.internationalization.dateFormat;\n      }\n\n      let result = '';\n      let year = value.getFullYear().toString();\n      let month = String(value.getMonth() + 1);\n      let day = String(value.getDay());\n\n      switch (dateFormat) {\n        case 'ymd':\n          result = \"\".concat(year, seperator, month, seperator, day);\n          break;\n\n        case 'dmy':\n          result = \"\".concat(day, seperator, month, seperator, year);\n          break;\n\n        case 'mdy':\n          result = \"\".concat(month, seperator, day, seperator, year);\n          break;\n      }\n\n      return result;\n    }\n\n  }\n\n  ObjectMaker.language = \"\";\n  return ObjectMaker;\n})();\nconst PROP_ARRAY = \"propArray\";\n\nclass RxFormArray extends FormArray {\n  constructor(arrayObject, controls, validatorOrOpts, asyncValidator, arrayConfig) {\n    super(controls, validatorOrOpts, asyncValidator);\n    this.arrayObject = arrayObject;\n    this.arrayConfig = arrayConfig;\n    this._isModified = false;\n    this._modified = [];\n    this.cloneObject(arrayObject);\n  }\n\n  get isModified() {\n    return this._isModified;\n  }\n\n  push(control, options = {\n    isAddedInstance: false\n  }) {\n    let formGroup = this.root;\n    if (this.arrayObject) if (control.modelInstance) {\n      if (!options.isAddedInstance) this.arrayObject.push(control.modelInstance);else this.arrayObject[this.arrayObject.length] = control.modelInstance;\n    }\n    super.push(control);\n    if (formGroup[VALUE_CHANGED_SYNC]) formGroup.valueChangedSync();\n    this.patch();\n    this.checkValidation();\n  }\n\n  patch() {\n    this.checkModification();\n    if (this.parent) this.parent[PATCH]();\n  }\n\n  resetForm(options) {\n    if (options && options.index >= 0 && options.groupOption) {\n      this.controls[options.index].resetForm(options.groupOption);\n    } else {\n      for (var i = 0; i < this._baseValue.length; i++) {\n        if (this.controls[i] !== undefined) this.controls[i].resetForm({\n          value: this._baseValue[i]\n        });else if (options && options.pushFunction) {\n          let formGroup = options.pushFunction(this._baseValue[i]);\n          this.push(formGroup);\n        }\n      }\n    }\n  }\n\n  commit() {\n    this._baseValue = [];\n\n    for (let formGroup of this.controls) {\n      formGroup.commit();\n\n      this._baseValue.push(clone(formGroup.value));\n    }\n\n    this.patch();\n  }\n\n  removeAt(index, options = {\n    isRemovedInstance: false\n  }) {\n    let formGroup = this.root;\n    if (!options.isRemovedInstance) this.arrayObject.splice(index, 1);else {\n      for (var i = index; i < this.arrayObject.length - 1; i++) this.arrayObject[i] = this.arrayObject[i + 1];\n\n      this.arrayObject.pop();\n    }\n    super.removeAt(index, options);\n    if (formGroup[VALUE_CHANGED_SYNC]) formGroup.valueChangedSync();\n    this.patch();\n    this.checkValidation();\n  }\n\n  checkValidation() {\n    setTimeout(() => {\n      if (this.arrayConfig != undefined && this.arrayConfig.allowMaxIndex && this.length > this.arrayConfig.allowMaxIndex) this.setErrors(ObjectMaker.toJson(PROP_ARRAY, this.arrayConfig, [this.length, this.arrayConfig.allowMaxIndex]));else if (this.errors && this.errors[PROP_ARRAY]) delete this.errors[PROP_ARRAY];\n    });\n  }\n\n  checkModification() {\n    this._isModified = !(this._baseValue.length == this.controls.length);\n    if (!this._isModified) for (var i = 0; i < this.controls.length; i++) {\n      this._isModified = isMatched(this._baseValue[i], this.controls[i].value);\n      if (this._isModified) break;\n    }\n  }\n\n  cloneObject(value) {\n    this._baseValue = [];\n\n    for (let row of value) {\n      this._baseValue.push(clone(row));\n    }\n  }\n\n}\n\nvar NumericValueType = /*#__PURE__*/(() => {\n  (function (NumericValueType) {\n    NumericValueType[NumericValueType[\"PositiveNumber\"] = 1] = \"PositiveNumber\";\n    NumericValueType[NumericValueType[\"NegativeNumber\"] = 2] = \"NegativeNumber\";\n    NumericValueType[NumericValueType[\"Both\"] = 3] = \"Both\";\n  })(NumericValueType || (NumericValueType = {}));\n\n  return NumericValueType;\n})();\nvar IpVersion = /*#__PURE__*/(() => {\n  (function (IpVersion) {\n    IpVersion[IpVersion[\"V4\"] = 1] = \"V4\";\n    IpVersion[IpVersion[\"V6\"] = 2] = \"V6\";\n    IpVersion[IpVersion[\"AnyOne\"] = 3] = \"AnyOne\";\n  })(IpVersion || (IpVersion = {}));\n\n  return IpVersion;\n})();\nvar ErrorMessageBindingStrategy = /*#__PURE__*/(() => {\n  (function (ErrorMessageBindingStrategy) {\n    ErrorMessageBindingStrategy[ErrorMessageBindingStrategy[\"None\"] = 0] = \"None\";\n    ErrorMessageBindingStrategy[ErrorMessageBindingStrategy[\"OnSubmit\"] = 1] = \"OnSubmit\";\n    ErrorMessageBindingStrategy[ErrorMessageBindingStrategy[\"OnDirty\"] = 2] = \"OnDirty\";\n    ErrorMessageBindingStrategy[ErrorMessageBindingStrategy[\"OnTouched\"] = 3] = \"OnTouched\";\n    ErrorMessageBindingStrategy[ErrorMessageBindingStrategy[\"OnDirtyOrTouched\"] = 4] = \"OnDirtyOrTouched\";\n    ErrorMessageBindingStrategy[ErrorMessageBindingStrategy[\"OnDirtyOrSubmit\"] = 5] = \"OnDirtyOrSubmit\";\n    ErrorMessageBindingStrategy[ErrorMessageBindingStrategy[\"OnTouchedOrSubmit\"] = 6] = \"OnTouchedOrSubmit\";\n  })(ErrorMessageBindingStrategy || (ErrorMessageBindingStrategy = {}));\n\n  return ErrorMessageBindingStrategy;\n})();\nvar ResetFormType = /*#__PURE__*/(() => {\n  (function (ResetFormType) {\n    ResetFormType[ResetFormType[\"ControlsOnly\"] = 1] = \"ControlsOnly\";\n    ResetFormType[ResetFormType[\"FormGroupsOnly\"] = 2] = \"FormGroupsOnly\";\n    ResetFormType[ResetFormType[\"FormArraysOnly\"] = 3] = \"FormArraysOnly\";\n    ResetFormType[ResetFormType[\"ControlsAndFormGroupsOnly\"] = 4] = \"ControlsAndFormGroupsOnly\";\n    ResetFormType[ResetFormType[\"DefinedPropsOnly\"] = 5] = \"DefinedPropsOnly\";\n    ResetFormType[ResetFormType[\"All\"] = 6] = \"All\";\n  })(ResetFormType || (ResetFormType = {}));\n\n  return ResetFormType;\n})();\nconst MODEL_INSTANCE_VALUE = \"modelInstanceValue\";\n\nclass ApplicationUtil {\n  static getParentObjectValue(control) {\n    if (control.parent) {\n      let parent = this.parentObjectValue(control.parent);\n      return parent.value;\n    }\n\n    return {};\n  }\n\n  static getParentModelInstanceValue(control) {\n    if (control.parent) {\n      let parent = this.parentObjectValue(control.parent);\n      return parent[MODEL_INSTANCE_VALUE];\n    }\n\n    return {};\n  }\n\n  static getRootFormGroup(control) {\n    if (control.parent) {\n      return this.getRootFormGroup(control.parent);\n    }\n\n    return control;\n  }\n\n  static getParentControl(control) {\n    if (control.parent) {\n      let parent = this.parentObjectValue(control.parent);\n      return parent;\n    }\n\n    return control;\n  }\n\n  static getFormControlName(control) {\n    let controlName = '';\n\n    if (control.parent) {\n      for (var formControlName in control.parent.controls) {\n        if (control.parent.controls[formControlName] == control) {\n          controlName = formControlName;\n          break;\n        }\n      }\n    }\n\n    return controlName;\n  }\n\n  static getParentFormArray(control) {\n    if (control.parent && !(control.parent instanceof FormArray || control.parent instanceof RxFormArray)) {\n      let parent = this.getParentFormArray(control.parent);\n      return parent;\n    }\n\n    return control.parent;\n  }\n\n  static toLower(value) {\n    if (value) return String(value).toLowerCase().trim();\n    return value;\n  }\n\n  static getControl(fieldName, formGroup) {\n    let splitText = fieldName.split('.');\n\n    if (splitText.length > 1) {\n      var formControl = formGroup;\n      splitText.forEach((name, index) => {\n        formControl = formControl.controls[name];\n      });\n      return formControl;\n    } else return formGroup.controls[fieldName];\n  }\n\n  static getFormControl(fieldName, control) {\n    let splitText = fieldName.split('.');\n\n    if (splitText.length > 1 && control.parent) {\n      var formControl = this.getParentControl(control);\n      splitText.forEach((name, index) => {\n        formControl = formControl.controls[name];\n      });\n      return formControl;\n    }\n\n    return control.parent ? control.parent.get([fieldName]) : undefined;\n  }\n\n  static parentObjectValue(control) {\n    if (!control.parent) return control;else control = this.parentObjectValue(control.parent);\n    return control;\n  }\n\n  static isNumeric(value) {\n    return value - parseFloat(value) + 1 >= 0;\n  }\n\n  static notEqualTo(primaryValue, secondaryValue) {\n    let firstValue = primaryValue === undefined || primaryValue === null ? \"\" : primaryValue;\n    let secondValue = secondaryValue === undefined || secondaryValue === null ? \"\" : secondaryValue;\n    if (firstValue instanceof Date && secondValue instanceof Date) return +firstValue != +secondValue;\n    return firstValue != secondValue;\n  }\n\n  static numericValidation(allowDecimal, acceptValue) {\n    let decimalSymbol;\n\n    if (ReactiveFormConfig && ReactiveFormConfig.number) {\n      decimalSymbol = ReactiveFormConfig.json && ReactiveFormConfig.json.allowDecimalSymbol ? ReactiveFormConfig.json.allowDecimalSymbol : ReactiveFormConfig.number.decimalSymbol;\n    } else {\n      decimalSymbol = \".\";\n    }\n\n    acceptValue = acceptValue == undefined ? NumericValueType.PositiveNumber : acceptValue;\n    let regex = /^[0-9]+$/;\n\n    switch (acceptValue) {\n      case NumericValueType.PositiveNumber:\n        regex = !allowDecimal ? /^[0-9]+$/ : decimalSymbol == \".\" || decimalSymbol == undefined ? /^[0-9\\.]+$/ : /^[0-9\\,]+$/;\n        break;\n\n      case NumericValueType.NegativeNumber:\n        regex = !allowDecimal ? /^[-][0-9]+$/ : decimalSymbol == \".\" || decimalSymbol == undefined ? /^[-][0-9\\.]+$/ : /^[-][0-9\\,]+$/;\n        break;\n\n      case NumericValueType.Both:\n        regex = !allowDecimal ? /^[-|+]?[0-9]+$/ : decimalSymbol == \".\" || decimalSymbol == undefined ? /^[-|+]?[0-9\\.]+$/ : /^[-|+]?[0-9\\,]+$/;\n        break;\n    }\n\n    return regex;\n  }\n\n  static configureControl(control, config, type) {\n    if (!control.validatorConfig) {\n      let jObject = {};\n      jObject[type] = config;\n      Object.assign(control, {\n        validatorConfig: jObject\n      });\n    } else control.validatorConfig[type] = config;\n  }\n\n  static lowerCaseWithTrim(value) {\n    return typeof value === \"string\" ? value.toLowerCase().trim() : String(value).toLowerCase().trim();\n  }\n  /** Check if a value is an object */\n\n\n  static isObject(value) {\n    return Object.prototype.toString.call(value) === '[object Object]';\n  }\n  /** Check if a value is an object */\n\n\n  static isArray(value) {\n    return Array.isArray(value);\n  }\n\n  static cloneValue(value) {\n    return ApplicationUtil.isObject(value) ? ApplicationUtil.isArray(value) ? [...value] : Object.assign({}, value) : value;\n  }\n\n}\n\nconst ISO_DATE_REGEX = /^(?:[\\+-]?\\d{4}(?!\\d{2}\\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\\1(?:[12]\\d|0[1-9]|3[01]))?|W(?:[0-4]\\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\\d|[12]\\d{2}|3(?:[0-5]\\d|6[1-6])))(?:[T\\s](?:(?:(?:[01]\\d|2[0-3])(?:(:?)[0-5]\\d)?|24\\:?00)(?:[\\.,]\\d+(?!:))?)?(?:\\2[0-5]\\d(?:[\\.,]\\d+)?)?(?:[zZ]|(?:[\\+-])(?:[01]\\d|2[0-3]):?(?:[0-5]\\d)?)?)?)?$/;\n\nclass DateProvider {\n  isDate(value) {\n    return value instanceof Date && !isNaN(value.valueOf());\n  }\n\n  getRegex(dateFormat) {\n    var regExp;\n\n    switch (dateFormat) {\n      case 'ymd':\n        regExp = \"^(?:[0-9]{4})-(1[0-2]|0?[1-9])-(3[01]|[12][0-9]|0?[1-9])$\";\n        break;\n\n      case 'dmy':\n        regExp = \"^(3[01]|[12][0-9]|0?[1-9])-(1[0-2]|0?[1-9])-(?:[0-9]{2})?[0-9]{2}$\";\n        break;\n\n      case 'mdy':\n        regExp = \"^(1[0-2]|0?[1-9])-(3[01]|[12][0-9]|0?[1-9])-(?:[0-9]{2})?[0-9]{2}$\";\n        break;\n    }\n\n    return new RegExp(regExp);\n  }\n\n  regex(config) {\n    var regExp;\n    if (ReactiveFormConfig && ReactiveFormConfig.json && ReactiveFormConfig.json.internationalization && ReactiveFormConfig.json.internationalization.dateFormat && ReactiveFormConfig.json.internationalization.seperator) regExp = this.getRegex(config.dateFormat || ReactiveFormConfig.json.internationalization.dateFormat);else regExp = ReactiveFormConfig && ReactiveFormConfig.json && ReactiveFormConfig.json.baseConfig && ReactiveFormConfig.json.baseConfig.dateFormat ? this.getRegex(config.dateFormat || ReactiveFormConfig.json.baseConfig.dateFormat) : this.getRegex(config.dateFormat || \"mdy\");\n    return regExp;\n  }\n\n  getDate(value, configDateFormat = undefined, isBaseFormat = false) {\n    let year, month, day;\n\n    if (!this.isDate(value)) {\n      let seperator;\n      let dateFormat;\n\n      if (ISO_DATE_REGEX.test(value)) {\n        return new Date(value);\n      } else {\n        seperator = ReactiveFormConfig && ReactiveFormConfig.json && ReactiveFormConfig.json.baseConfig && ReactiveFormConfig.json.baseConfig.seperator ? ReactiveFormConfig.json.baseConfig.seperator : \"/\";\n        dateFormat = configDateFormat || ReactiveFormConfig && ReactiveFormConfig.json && ReactiveFormConfig.json.baseConfig && ReactiveFormConfig.json.baseConfig.dateFormat ? ReactiveFormConfig.json.baseConfig.dateFormat : \"mdy\";\n      }\n\n      if (!isBaseFormat && ReactiveFormConfig && ReactiveFormConfig.json && ReactiveFormConfig.json.internationalization && ReactiveFormConfig.json.internationalization.dateFormat && ReactiveFormConfig.json.internationalization.seperator) {\n        seperator = ReactiveFormConfig.json.internationalization.seperator;\n        dateFormat = configDateFormat || ReactiveFormConfig.json.internationalization.dateFormat;\n      }\n\n      switch (dateFormat) {\n        case 'ymd':\n          [year, month, day] = value.split(seperator).map(val => +val);\n          break;\n\n        case 'dmy':\n          [day, month, year] = value.split(seperator).map(val => +val);\n          break;\n\n        case 'mdy':\n          [month, day, year] = value.split(seperator).map(val => +val);\n          break;\n      }\n\n      return new Date(year, month - 1, day);\n    } else return value;\n  }\n\n  isValid(value, config) {\n    if (config && config.isValid) return config.isValid(value);\n\n    if (typeof value == \"string\") {\n      // Fixed issue : https://github.com/rxweb/rxweb/issues/280 & feature request : https://github.com/rxweb/rxweb/issues/295\n      if (config && config.allowISODate && ISO_DATE_REGEX.test(value)) return true;\n      let seperator = '/';\n      if (ReactiveFormConfig && ReactiveFormConfig.json && ReactiveFormConfig.json.baseConfig && ReactiveFormConfig.json.baseConfig.seperator) seperator = ReactiveFormConfig.json.baseConfig.seperator;\n      if (ReactiveFormConfig.json && ReactiveFormConfig.json.internationalization && ReactiveFormConfig.json.internationalization.seperator) seperator = ReactiveFormConfig.json.internationalization.seperator;\n      if (value.split(seperator).length !== 3) return false;\n      value = value.replace(seperator, '-').replace(seperator, '-');\n      return this.regex(config).test(value);\n    } else return this.isDate(value);\n  }\n\n  getConfigDateValue(config) {\n    let date = config.value;\n\n    if (config.value && typeof config.value == \"string\") {\n      date = this.getDate(config.value, config.dateFormat, true);\n    }\n\n    return date;\n  }\n\n  getCompareDate(config, control) {\n    let date = this.getConfigDateValue(config);\n\n    if (config.fieldName) {\n      let checkControl = ApplicationUtil.getFormControl(config.fieldName, control);\n\n      if (checkControl && checkControl.value) {\n        date = this.getDate(checkControl.value, config.dateFormat);\n      }\n    }\n\n    return date;\n  }\n\n}\n\nfunction isNotBlank(value) {\n  return value !== undefined && value !== null && value !== \"\";\n}\n\nfunction trim$1(value) {\n  if (isNotBlank(value)) if (typeof value === \"string\") return value.trim();\n  return value;\n}\n\n;\n\nfunction ltrim$1(value) {\n  if (isNotBlank(value)) if (typeof value === \"string\") return value.replace(/^\\s+/g, '');\n  return value;\n}\n\nfunction rtrim$1(value) {\n  if (isNotBlank(value)) if (typeof value === \"string\") return value.replace(/\\s+$/g, '');\n  return value;\n}\n\nfunction blacklist$1(value, chars) {\n  if (isNotBlank(value)) if (typeof value === \"string\") return value.replace(new RegExp('[$' + chars + ']+', 'g'), '');\n  return value;\n}\n\n;\n\nfunction stripLow$1(value, keepNewLines) {\n  let chars = keepNewLines === true ? '\\x00-\\x09\\x0B\\x0C\\x0E-\\x1F\\x7F' : '\\x00-\\x1F\\x7F';\n  return blacklist$1(value, chars);\n}\n\nfunction toBoolean$1(value, strict) {\n  if (isNotBlank(value)) {\n    if (strict) {\n      return value === '1' || value === 'true';\n    }\n\n    return value !== '0' && value !== 'false' && value !== '';\n  }\n\n  return value;\n}\n\nfunction toFloat$1(value) {\n  if (isNotBlank(value)) {\n    var decimalSymbol = '.';\n\n    if (ReactiveFormConfig && ReactiveFormConfig.number) {\n      decimalSymbol = ReactiveFormConfig.json && ReactiveFormConfig.json.allowDecimalSymbol ? ReactiveFormConfig.json.allowDecimalSymbol : ReactiveFormConfig.number.decimalSymbol;\n    }\n\n    if (decimalSymbol == ',' && typeof value == \"string\") value = value.replace(',', '.');\n    if (ApplicationUtil.isNumeric(value)) return parseFloat(value);\n  }\n\n  return null;\n}\n\nfunction toDouble$1(value) {\n  return toFloat$1(value);\n}\n\nfunction toInt$1(value, radix) {\n  if (isNotBlank(value)) if (ApplicationUtil.isNumeric(value)) return parseInt(value, radix || 10);\n  return null;\n}\n\nfunction toString$1(value, radix) {\n  if (isNotBlank(value)) return String(value);\n  return value;\n}\n\nfunction whitelist$1(value, chars) {\n  if (isNotBlank(value)) if (typeof value === \"string\") return value.replace(new RegExp(`[^${chars}]+`, 'g'), '');\n  return value;\n}\n\nfunction toDate$1(value, config) {\n  var dateProvider = new DateProvider();\n  if (isNotBlank(value)) if (typeof value === \"string\" && dateProvider.isValid(value, config)) {\n    value = dateProvider.getDate(value);\n    return value;\n  }\n  return null;\n}\n\nfunction escape$1(value) {\n  if (isNotBlank(value)) return value.replace(/&/g, '&amp;').replace(/\"/g, '&quot;').replace(/'/g, '&#x27;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\\//g, '&#x2F;').replace(/\\\\/g, '&#x5C;').replace(/`/g, '&#96;');\n  return value;\n}\n\nfunction prefix$1(value, text) {\n  if (isNotBlank(value)) return `${text}${value}`;\n  return value;\n}\n\nfunction suffix$1(value, text) {\n  if (isNotBlank(value)) return `${value}${text}`;\n  return value;\n}\n\nfunction sanitize$1(value, config) {\n  return config.custom(value);\n}\n\nconst SANITIZERS = {\n  trim: trim$1,\n  ltrim: ltrim$1,\n  rtrim: rtrim$1,\n  blacklist: blacklist$1,\n  stripLow: stripLow$1,\n  toBoolean: toBoolean$1,\n  toDouble: toDouble$1,\n  toFloat: toFloat$1,\n  toInt: toInt$1,\n  'toString': toString$1,\n  whitelist: whitelist$1,\n  toDate: toDate$1,\n  escape: escape$1,\n  prefix: prefix$1,\n  suffix: suffix$1,\n  sanitize: sanitize$1\n};\n\nfunction instanceProvider(instanceFunc, entityObject) {\n  let instance = defaultContainer.get(instanceFunc);\n  let prototype = entityObject ? entityObject.__proto__ : getInstance(instanceFunc, []).__proto__;\n\n  if (prototype.__proto__) {\n    let isLoop = false;\n\n    do {\n      isLoop = prototype.__proto__.constructor != Object;\n\n      if (isLoop) {\n        let extendClassInstance = defaultContainer.get(prototype.__proto__.constructor);\n        instance = merge(clone(instance), clone(extendClassInstance));\n        prototype = prototype.__proto__;\n      }\n    } while (isLoop);\n  }\n\n  return instance;\n}\n\nfunction getInstance(model, objectArguments) {\n  let classInstance = Object.create(model.prototype);\n\n  try {\n    model.apply(classInstance, objectArguments);\n  } catch (ex) {\n    ///resolution of issue https://github.com/rxweb/rxweb/issues/188\n    classInstance = Reflect.construct(model, objectArguments);\n  }\n\n  return classInstance;\n}\n\nclass BaseFormBuilder {\n  constructor() {}\n\n  createInstance() {\n    let instance = {};\n    defaultContainer.modelIncrementCount = defaultContainer.modelIncrementCount + 1;\n    let modelName = `RxWebModel${defaultContainer.modelIncrementCount}`;\n    instance.constructor = Function(`\"use strict\";return(function ${modelName}(){ })`)();\n    return instance;\n  }\n\n  createClassObject(model, formBuilderConfiguration, classInstance) {\n    let instanceContainer = defaultContainer.get(model);\n    let autoInstanceConfig = formBuilderConfiguration ? formBuilderConfiguration.autoInstanceConfig : undefined;\n\n    if (!autoInstanceConfig) {\n      return classInstance && typeof classInstance != \"function\" ? classInstance : getInstance(model, []);\n    } else {\n      classInstance = classInstance && typeof classInstance != \"function\" ? classInstance : getInstance(model, autoInstanceConfig.arguments || []);\n\n      if (autoInstanceConfig.objectPropInstanceConfig && autoInstanceConfig.objectPropInstanceConfig.length > 0) {\n        autoInstanceConfig.objectPropInstanceConfig.forEach(t => {\n          let objectProperty = instanceContainer.properties.filter(property => property.name == t.propertyName && property.propertyType == OBJECT_PROPERTY)[0];\n\n          if (objectProperty) {\n            let data = classInstance[t.propertyName];\n            classInstance[t.propertyName] = getInstance(objectProperty.entity, t.arguments || []);\n            if (data) this.setObjectValue(data, classInstance[t.propertyName]);\n          }\n        });\n      }\n\n      if (autoInstanceConfig.arrayPropInstanceConfig && autoInstanceConfig.arrayPropInstanceConfig.length > 0) {\n        autoInstanceConfig.arrayPropInstanceConfig.forEach(t => {\n          let property = instanceContainer.properties.filter(property => property.name == t.propertyName && property.propertyType == ARRAY_PROPERTY)[0];\n\n          if (property) {\n            let data = classInstance[t.propertyName];\n            classInstance[t.propertyName] = [];\n\n            for (var i = 0; i < t.rowItems; i++) {\n              let instance = getInstance(property.entity, t.arguments || []);\n              if (data && data[i]) this.setObjectValue(data[i], instance);\n              classInstance[t.propertyName].push(instance);\n            }\n          }\n        });\n      }\n\n      return classInstance;\n    }\n  }\n\n  updateObject(model, entityObject, formBuilderConfiguration) {\n    let instanceContainer = instanceProvider(model);\n    let classInstance = getInstance(model, []);\n\n    if (instanceContainer) {\n      instanceContainer.properties.forEach(t => {\n        let entity = (t.propertyType == OBJECT_PROPERTY || t.propertyType == ARRAY_PROPERTY) && t.entity ? t.entity : formBuilderConfiguration && formBuilderConfiguration.genericEntities ? formBuilderConfiguration.genericEntities[t.name] : undefined;\n        if (!entity && t.entityProvider) entity = t.entityProvider.call(entityObject);\n\n        switch (t.propertyType) {\n          case PROPERTY:\n            classInstance[t.name] = this.getValue(entityObject, t, formBuilderConfiguration);\n            break;\n\n          case OBJECT_PROPERTY:\n            let objectValue = this.getValue(entityObject, t, formBuilderConfiguration);\n            if (objectValue) classInstance[t.name] = this.updateObject(entity, objectValue, formBuilderConfiguration);\n            break;\n\n          case ARRAY_PROPERTY:\n            let arrayObjectValue = this.getValue(entityObject, t, formBuilderConfiguration);\n\n            if (arrayObjectValue && Array.isArray(arrayObjectValue)) {\n              classInstance[t.name] = [];\n\n              for (let row of arrayObjectValue) {\n                let instanceObject = this.updateObject(entity, row, formBuilderConfiguration);\n                classInstance[t.name].push(instanceObject);\n              }\n            }\n\n            break;\n        }\n      });\n    }\n\n    return classInstance;\n  }\n\n  instaceProvider(instanceFunc, entityObject) {\n    return instanceProvider(instanceFunc, entityObject);\n  }\n\n  getDefaultValue(propertyInfo, value, formBuilderConfiguration) {\n    let defaultValue = formBuilderConfiguration && formBuilderConfiguration.propsConfig && formBuilderConfiguration.propsConfig[propertyInfo.name] && formBuilderConfiguration.propsConfig[propertyInfo.name].defaultValue && !RegexValidator.isNotBlank(value) ? formBuilderConfiguration.propsConfig[propertyInfo.name].defaultValue : propertyInfo.defaultValue != undefined && !RegexValidator.isNotBlank(value) ? propertyInfo.defaultValue : value;\n    return defaultValue;\n  }\n\n  sanitizeValue(instanceContainer, propertyName, value, entityObject, baseObject) {\n    if (instanceContainer.sanitizers && instanceContainer.sanitizers[propertyName]) {\n      for (let sanitizer of instanceContainer.sanitizers[propertyName]) value = SANITIZERS[sanitizer.name](value, sanitizer.config);\n    }\n\n    if (entityObject[propertyName] !== undefined && entityObject[propertyName] !== value) entityObject[propertyName] = value;\n    if (baseObject[propertyName] !== undefined && baseObject[propertyName] !== value) baseObject[propertyName] = value;\n    return value;\n  }\n\n  getValue(entityObject, propertyInfo, formBuilderConfiguration) {\n    let propValue = propertyInfo.dataPropertyName ? entityObject[propertyInfo.dataPropertyName] : entityObject[propertyInfo.name];\n    return this.getDefaultValue(propertyInfo, propValue, formBuilderConfiguration);\n  }\n\n  setObjectValue(entityObject, classInstance) {\n    for (var column in entityObject) {\n      classInstance[column] = entityObject[column];\n    }\n  }\n\n}\n\nclass FormBuilderConfiguration {\n  constructor(formBuilderConfiguration) {\n    if (formBuilderConfiguration) for (var column in formBuilderConfiguration) this[column] = formBuilderConfiguration[column];\n  }\n\n}\n\nclass DisableProvider {\n  constructor(decoratorType, entityObject) {\n    this.decoratorType = decoratorType;\n    this.entityObject = entityObject;\n  }\n\n  getFormGroupName(currentFormGroup) {\n    let keyName = '';\n    if (currentFormGroup.parent) for (var controlName of Object.keys(currentFormGroup.parent.controls)) if (currentFormGroup.parent.controls[controlName] == currentFormGroup) {\n      keyName = controlName;\n      break;\n    }\n    return keyName;\n  }\n\n  zeroArgumentProcess(control, columnName) {\n    let disabledColumns = [];\n    this.getDisabledColumns(control.parent, `${columnName}${RXCODE}0`, false).forEach(t => disabledColumns.push(t));\n    let path = this.topControlPath(control, columnName);\n    let splitPath = path.split(\".\");\n\n    if (splitPath.length > 1) {\n      let rootFormGroup = ApplicationUtil.getRootFormGroup(control);\n      this.getDisabledColumns(rootFormGroup, `${path}${RXCODE}0`, true).forEach(t => disabledColumns.push(t));\n      let controlPath = '';\n\n      for (var i = 0; i < splitPath.length - 2; i++) {\n        let controlName = splitPath[i];\n        controlPath = `${path.replace(`${controlName}.`, '')}${RXCODE}-0`;\n\n        if (rootFormGroup.controls[controlName]) {\n          this.getDisabledColumns(rootFormGroup.controls[controlName], controlPath, true, controlName).forEach(t => disabledColumns.push(t));\n          rootFormGroup = rootFormGroup.controls[controlName];\n        }\n      }\n    }\n\n    return disabledColumns;\n  }\n\n  getDisabledColumns(formGroup, columnName, isRoot, pathName = \"\") {\n    if (formGroup[MODEL_INSTANCE]) {\n      let instanceContainer = instanceProvider(formGroup[MODEL_INSTANCE].constructor, this.entityObject);\n      return this.getChangeDetectionColumns(instanceContainer, columnName, isRoot, pathName);\n    }\n\n    return [];\n  }\n\n  getChangeDetectionColumns(instanceContainer, columnName, isRoot, pathName = \"\") {\n    let conditionalDisableControls = [];\n    let columns = instanceContainer.nonValidationDecorators[this.decoratorType].changeDetection[columnName];\n\n    if (columns) {\n      columns.forEach(t => {\n        conditionalDisableControls.push({\n          controlPath: pathName ? `${pathName}.${t}` : t,\n          conditionalExpression: instanceContainer.nonValidationDecorators[this.decoratorType].conditionalExpressions[t],\n          isRoot: isRoot\n        });\n      });\n    }\n\n    return conditionalDisableControls;\n  }\n\n  topControlPath(control, columnName) {\n    if (control.parent) {\n      let name = this.getFormGroupName(control.parent);\n\n      if (name) {\n        columnName = `${name}.${columnName}`;\n        return this.topControlPath(control.parent, columnName);\n      }\n    }\n\n    return columnName;\n  }\n\n  childControlDisabledExpression(formGroup, columnName, path = \"\") {\n    let disabledColumns = [];\n\n    if (formGroup[MODEL_INSTANCE]) {\n      let instanceContainer = defaultContainer.get(formGroup[MODEL_INSTANCE].constructor);\n\n      if (instanceContainer) {\n        this.getChangeDetectionColumns(instanceContainer, columnName, true, path).forEach(t => disabledColumns.push(t));\n        var props = instanceContainer.properties.filter(t => t.propertyType == OBJECT_PROPERTY);\n        props.forEach(t => {\n          if (formGroup.controls[t.name]) {\n            let columns = this.getDisabledColumns(formGroup.controls[t.name], columnName, true, path ? `${path}.${t.name}` : `${t.name}`);\n            columns.forEach(x => disabledColumns.push(x));\n            this.childControlDisabledExpression(formGroup.controls[t.name], columnName, path ? `${path}.${t.name}` : `${t.name}`).forEach(y => disabledColumns.push(y));\n          }\n        });\n      }\n    }\n\n    return disabledColumns;\n  }\n\n  oneArgumentProcess(control, columnName) {\n    let path = this.topControlPath(control, columnName);\n    let rootFormGroup = ApplicationUtil.getRootFormGroup(control);\n    let childColumns = this.childControlDisabledExpression(rootFormGroup, path);\n    return childColumns;\n  }\n\n}\n\nconst DIRTY = \"dirty\";\nconst TOUCHED = \"touched\";\nconst UNTOUCHED = \"untouched\";\nconst PRISTINE = \"pristine\";\nconst PENDING = \"pending\";\n\nclass RxFormControl extends FormControl {\n  constructor(formState, validator, asyncValidator, entityObject, baseObject, controlName, _sanitizers) {\n    super(formState, validator, asyncValidator);\n    this.entityObject = entityObject;\n    this.baseObject = baseObject;\n    this._sanitizers = _sanitizers;\n    this._errorMessages = [];\n    this._childColumns = [];\n    this._refDisableControls = [];\n    this._refMessageControls = [];\n    this._refClassNameControls = [];\n    this._isPassedExpression = false;\n    this._dirty = false;\n    this.backEndErrors = {};\n    this.defineErrorsProperty();\n    this._baseValue = formState === undefined ? null : this.getFormState(formState);\n    this._isModified = false;\n    this.keyName = controlName;\n    this._validators = validator.validators;\n    this._asyncValidators = validator.asyncValidators;\n    this._errorMessageBindingStrategy = ReactiveFormConfig.get(\"reactiveForm.errorMessageBindingStrategy\");\n\n    if (this._sanitizers) {\n      var floatSanitizer = this._sanitizers.filter(t => t.name == \"toFloat\")[0];\n\n      if (floatSanitizer && this._baseValue && ReactiveFormConfig.number && ReactiveFormConfig.number.decimalSymbol == \",\") {\n        let baseValue = String(this._baseValue);\n\n        if (baseValue.indexOf('.') != -1) {\n          this._baseValue = baseValue.replace(\".\", ReactiveFormConfig.number.decimalSymbol);\n          super.setValue(this._baseValue);\n        }\n      }\n    }\n  }\n\n  get errorMessages() {\n    if (!this._messageExpression) {\n      if (this._errorMessages.length == 0 && this.errors) this.setControlErrorMessages();\n    } else if (this._messageExpression && !this._isPassedExpression) return [];\n\n    if (!this.errors && this._errorMessages.length > 0) this.setControlErrorMessages();\n    if (this._language != this.getLanguage()) this.setControlErrorMessages();\n    return this._errorMessages;\n  }\n\n  get errorMessage() {\n    if (!this._messageExpression) {\n      if (this._errorMessage == undefined && this.errors) this.setControlErrorMessages();\n    } else if (this._messageExpression && !this._isPassedExpression) return undefined;\n\n    if (!this.errors && this._errorMessage) this.setControlErrorMessages();\n    if (this._language != this.getLanguage()) this.setControlErrorMessages();\n    return this._errorMessage;\n  }\n\n  defineErrorsProperty() {\n    Object.defineProperty(this, \"errors\", {\n      configurable: true,\n\n      get() {\n        if (this._language && this._language != this.getLanguage() && this.validator) {\n          this[\"errors\"] = this.validator(this);\n        }\n\n        return this._errors;\n      },\n\n      set(value) {\n        this._errors = value;\n      }\n\n    });\n  }\n\n  getFormState(value) {\n    let baseValue = value;\n\n    if (Array.isArray(value)) {\n      baseValue = [];\n      value.forEach(t => baseValue.push(t));\n    }\n\n    return baseValue;\n  }\n\n  get isModified() {\n    return this._isModified;\n  }\n\n  getValidators() {\n    return this.getValidatorSource(this._validators);\n  }\n\n  getAsyncValidators() {\n    return this.getValidatorSource(this._asyncValidators);\n  }\n\n  getValidatorSource(validators) {\n    if (validators) return Array.isArray(validators) ? [...validators] : [validators];\n    return [];\n  }\n\n  setValidators(newValidator) {\n    this._validators = newValidator;\n    super.setValidators(newValidator);\n  }\n\n  setAsyncValidators(newValidator) {\n    this._asyncValidators = newValidator;\n    super.setAsyncValidators(newValidator);\n  }\n\n  setValue(value, options) {\n    this.parent.changing = true;\n    let parsedValue = this.getSanitizedValue(value);\n    if (options && options.dirty) this.baseObject[this.keyName] = value;\n    this.entityObject[this.keyName] = parsedValue;\n    super.setValue(value, options);\n    this.bindError();\n    this.bindClassName();\n    this.executeExpressions();\n    this.callPatch();\n\n    if (options && !options.updateChanged && this.root[VALUE_CHANGED_SYNC]) {\n      this.root[VALUE_CHANGED_SYNC]();\n    }\n\n    this.parent.changing = false;\n  }\n\n  getControlValue() {\n    return this.getSanitizedValue(this.value);\n  }\n\n  bindError() {\n    if (this._messageExpression) this._isPassedExpression = this.executeExpression(this._messageExpression, this);\n    this.setControlErrorMessages();\n    var t = this;\n    t[\"errors\"] = this.errors;\n  }\n\n  bindClassName() {\n    if (this.updateOnElementClass && typeof this.updateOnElementClass === \"function\") {\n      let className = this.executeExpression(this._classNameExpression, this);\n      let updateElement = this.updateOnElementClass;\n      updateElement(className);\n    }\n  }\n\n  setBackEndErrors(error) {\n    Object.keys(error).forEach(key => this.backEndErrors[key] = error[key]);\n    this.setControlErrorMessages();\n  }\n\n  clearBackEndErrors(errors) {\n    if (!errors) this.backEndErrors = {};else Object.keys(errors).forEach(t => delete this.backEndErrors[t]);\n    this.setControlErrorMessages();\n  }\n\n  markAsTouched(opts) {\n    let currentState = this.touched;\n    super.markAsTouched(opts);\n    if (currentState != this.touched) this.runControlPropChangeExpression([TOUCHED, UNTOUCHED]);\n  }\n\n  markAsUntouched(opts) {\n    let currentState = this.untouched;\n    super.markAsUntouched(opts);\n    if (currentState != this.untouched) this.runControlPropChangeExpression([UNTOUCHED, TOUCHED]);\n  }\n\n  markAsDirty(opts) {\n    let currentState = this._dirty;\n    super.markAsDirty(opts);\n    this._dirty = true;\n    if (currentState != this._dirty) this.runControlPropChangeExpression([DIRTY]);\n  }\n\n  markAsPristine(opts) {\n    let currentState = this.pristine;\n    super.markAsPristine(opts);\n    if (currentState != this.pristine) this.runControlPropChangeExpression([PRISTINE]);\n  }\n\n  markAsPending(opts) {\n    let currentState = this.pending;\n    super.markAsDirty(opts);\n    if (currentState != this.pending) this.runControlPropChangeExpression([PENDING]);\n  }\n\n  runControlPropChangeExpression(propNames) {\n    propNames.forEach(name => {\n      if (this._controlProp && this._messageExpression && this._controlProp[name] || !this._messageExpression && this.checkErrorMessageStrategy()) this.bindError();\n      if (this._classNameControlProp && this._classNameControlProp[name]) this.bindClassName();\n    });\n  }\n\n  refresh() {\n    this.getMessageExpression(this.parent, this.keyName);\n    this.bindConditionalControls(DECORATORS.disabled, \"_refDisableControls\");\n    this.bindConditionalControls(DECORATORS.error, \"_refMessageControls\");\n    this.bindConditionalControls(DECORATORS.elementClass, \"_refClassNameControls\");\n    this.executeExpressions();\n    this.bindError();\n  }\n\n  reset(value, options = {}) {\n    if (value !== undefined) this.setValue(value, options);else this.setValue(this.getFormState(this._baseValue), options);\n    this._dirty = false;\n  }\n\n  commit() {\n    this._baseValue = this.value;\n    this.callPatch();\n  }\n\n  callPatch() {\n    this._isModified = this.getValue(this._baseValue) != this.getValue(this.value);\n    if (this.parent && this.parent[PATCH]) this.parent[PATCH](this.keyName);\n  }\n\n  checkErrorMessageStrategy() {\n    let isBind = true;\n\n    switch (this._errorMessageBindingStrategy) {\n      case ErrorMessageBindingStrategy.OnSubmit:\n        isBind = this.parent.submitted;\n        break;\n\n      case ErrorMessageBindingStrategy.OnDirty:\n        isBind = this._dirty;\n        break;\n\n      case ErrorMessageBindingStrategy.OnTouched:\n        isBind = this.touched;\n        break;\n\n      case ErrorMessageBindingStrategy.OnDirtyOrTouched:\n        isBind = this._dirty || this.touched;\n        break;\n\n      case ErrorMessageBindingStrategy.OnDirtyOrSubmit:\n        isBind = this._dirty || this.parent.submitted;\n        break;\n\n      case ErrorMessageBindingStrategy.OnTouchedOrSubmit:\n        isBind = this.touched || this.parent.submitted;\n        break;\n\n      default:\n        isBind = true;\n    }\n\n    return isBind;\n  }\n\n  executeExpressions() {\n    this.processExpression(\"_refDisableControls\", \"disabled\");\n    this.processExpression(\"_refMessageControls\", \"bindError\");\n    this.processExpression(\"_refClassNameControls\", \"bindClassName\");\n  }\n\n  getMessageExpression(formGroup, keyName) {\n    if (formGroup[MODEL_INSTANCE]) {\n      let instanceContainer = defaultContainer.get(formGroup[MODEL_INSTANCE].constructor);\n\n      if (instanceContainer) {\n        this._messageExpression = instanceContainer.nonValidationDecorators.error.conditionalExpressions[keyName];\n        this._controlProp = instanceContainer.nonValidationDecorators.error.controlProp[this.keyName];\n        this._classNameExpression = instanceContainer.nonValidationDecorators.elementClass.conditionalExpressions[keyName];\n        this._classNameControlProp = instanceContainer.nonValidationDecorators.elementClass.controlProp[keyName];\n        if (this._classNameExpression) this.updateOnElementClass = true;\n      }\n    }\n  }\n\n  getSanitizedValue(value) {\n    if (this._sanitizers) {\n      for (let sanitizer of this._sanitizers) {\n        value = SANITIZERS[sanitizer.name](value, sanitizer.config);\n      }\n    }\n\n    return value;\n  }\n\n  bindConditionalControls(decoratorType, refName) {\n    this._disableProvider = new DisableProvider(decoratorType, this.entityObject);\n    this[refName] = this._disableProvider.zeroArgumentProcess(this, this.keyName);\n\n    this._disableProvider.oneArgumentProcess(this, `${this.keyName}${RXCODE}1`).forEach(t => this[refName].push(t));\n  }\n\n  setControlErrorMessages() {\n    if (!this._messageExpression && this.checkErrorMessageStrategy() || this._isPassedExpression) {\n      this._errorMessages = [];\n\n      if (this.errors) {\n        Object.keys(this.errors).forEach(t => {\n          if (this.parent) {\n            this.parent[CONTROLS_ERROR][this.keyName] = this._errorMessage = this.getErrorMessage(this.errors, t);\n\n            if (!this._errorMessage) {\n              let errorObject = ObjectMaker.toJson(t, undefined, [this.errors[t][t]]);\n              this.parent[CONTROLS_ERROR][this.keyName] = this._errorMessage = this.getErrorMessage(errorObject, t);\n            }\n          } else this._errorMessage = this.getErrorMessage(this.errors, t);\n\n          this._errorMessages.push(this._errorMessage);\n        });\n      } else {\n        this._errorMessage = undefined;\n\n        if (this.parent) {\n          this.parent[CONTROLS_ERROR][this.keyName] = undefined;\n          delete this.parent[CONTROLS_ERROR][this.keyName];\n        }\n      }\n\n      let backEndErrors = Object.keys(this.backEndErrors);\n      if (backEndErrors.length > 0) backEndErrors.forEach(t => {\n        this._errorMessages.push(this._errorMessage = this.backEndErrors[t]);\n      });\n    } else {\n      this._errorMessages = [];\n      this._errorMessage = undefined;\n    }\n\n    this._language = this.getLanguage();\n  }\n\n  getLanguage() {\n    return ReactiveFormConfig.i18n && ReactiveFormConfig.i18n.language ? ReactiveFormConfig.i18n.language : undefined;\n  }\n\n  getErrorMessage(errorObject, keyName) {\n    if (errorObject[keyName][MESSAGE]) return errorObject[keyName][MESSAGE];\n    return;\n  }\n\n  processExpression(propName, operationType) {\n    if (this[propName]) for (var controlInfo of this[propName]) {\n      let control = controlInfo.isRoot ? ApplicationUtil.getControl(controlInfo.controlPath, ApplicationUtil.getRootFormGroup(this)) : ApplicationUtil.getFormControl(controlInfo.controlPath, this);\n\n      if (control) {\n        if (operationType == \"disabled\") {\n          let result = this.executeExpression(controlInfo.conditionalExpression, control);\n          if (result) control.disable();else control.enable();\n        } else if (operationType == \"bindError\") control.bindError();else if (operationType == \"bindClassName\") control.bindClassName();\n      }\n    }\n  }\n\n  executeExpression(expression, control) {\n    return expression.call(control.parent[MODEL_INSTANCE], control, ApplicationUtil.getParentModelInstanceValue(this), control.parent[MODEL_INSTANCE]);\n  }\n\n  getValue(value) {\n    return value !== undefined && value !== null && value !== \"\" ? value : \"\";\n  }\n\n}\n\nconst OBJECT = \"object\";\nconst BOOLEAN = \"boolean\";\n\nclass FormDataProvider {\n  convertToFormData(jObject, options) {\n    return this.convertFormData(jObject, undefined, undefined, options);\n  }\n\n  convertFormData(jObject, currentFormData, parentKey, options) {\n    let formData = currentFormData || new FormData();\n    let propName = '';\n\n    for (var columnName in jObject) {\n      propName = !parentKey ? columnName : `${parentKey}[${columnName}]`;\n\n      if (Array.isArray(jObject[columnName])) {\n        jObject[columnName].forEach((row, index) => {\n          propName = `${columnName}[${index}]`;\n          if (typeof row === OBJECT) this.convertFormData(row, formData, propName, options);else this.nonObjectValueBind(row, formData, propName, options);\n        });\n      } else if (jObject[columnName] !== null && !(jObject[columnName] instanceof Date) && typeof jObject[columnName] === OBJECT && !(jObject[columnName] instanceof File || jObject[columnName] instanceof FileList)) {\n        this.convertFormData(jObject[columnName], formData, propName, options);\n      } else {\n        this.nonObjectValueBind(jObject[columnName], formData, propName, options);\n      }\n    }\n\n    return formData;\n  }\n\n  nonObjectValueBind(value, formData, propName, options) {\n    if (typeof value === BOOLEAN) {\n      let formValue = value ? true : false;\n      formData.append(propName, formValue);\n    } else if (value instanceof FileList) {\n      for (var i = 0; i < value.length; i++) {\n        formData.append(options && options.excludeImageIndex && value.length === 1 ? propName : `${propName}[${i}]`, value.item(i));\n      }\n    } else {\n      if (RegexValidator.isNotBlank(value)) formData.append(propName, value);\n    }\n  }\n\n}\n\nfunction isResetControl(controlName, control, options) {\n  let isReset = true;\n\n  if (options) {\n    isReset = false;\n    if (options.resetType) switch (options.resetType) {\n      case ResetFormType.ControlsOnly:\n        isReset = control instanceof FormControl;\n        break;\n\n      case ResetFormType.ControlsAndFormGroupsOnly:\n        isReset = control instanceof FormControl || control instanceof FormGroup;\n        break;\n\n      case ResetFormType.FormGroupsOnly:\n        isReset = control instanceof FormGroup;\n        break;\n\n      case ResetFormType.FormArraysOnly:\n        isReset = control instanceof FormArray;\n        break;\n\n      case ResetFormType.DefinedPropsOnly:\n        isReset = options.value ? Object.keys(options.value).indexOf(controlName) != -1 : false;\n        break;\n\n      default:\n        isReset = true;\n        break;\n    }\n    if (!isReset && options.with) isReset = options.with.filter(x => x.split('.')[0] == controlName.split('.')[0])[0] !== undefined;\n    if (!isReset && options.value && (options.resetType === undefined || options.resetType !== ResetFormType.DefinedPropsOnly)) isReset = true;\n  }\n\n  return isReset;\n}\n\nfunction getNestedOptions(controlName, options) {\n  if (options) {\n    let jObjectOptions = {};\n    if (options.resetType) jObjectOptions.resetType = options.resetType == ResetFormType.FormGroupsOnly || options.resetType == ResetFormType.FormArraysOnly ? ResetFormType.ControlsOnly : options.resetType;\n\n    if (options.with) {\n      let nestedControls = options.with.filter(t => t.split('.')[0] == controlName);\n      let controlNames = nestedControls.map(x => {\n        let splitControls = x.split('.');\n        splitControls.splice(0, 1);\n        return splitControls.join('.');\n      });\n      jObjectOptions.with = controlNames;\n    }\n\n    if (options.value && options.value[controlName]) jObjectOptions.value = options.value[controlName];\n    jObjectOptions = Object.keys(jObjectOptions).length > 0 ? jObjectOptions : undefined;\n    return jObjectOptions;\n  }\n\n  return undefined;\n}\n\nclass RxFormGroup extends FormGroup {\n  constructor(model, entityObject, controls, validatorOrOpts, asyncValidator) {\n    super(controls, validatorOrOpts, asyncValidator);\n    this.model = model;\n    this.entityObject = entityObject;\n    this._modified = {};\n    this._isModified = false;\n    this.changing = false;\n    this.baseObject = {};\n\n    for (var column in this.entityObject) this.baseObject[column] = this.entityObject[column];\n\n    this.formDataProvider = new FormDataProvider();\n  }\n\n  bindPrimaryKey(modelInstance, jObject) {\n    let instanceContainer = defaultContainer.get(modelInstance.constructor);\n\n    if (instanceContainer) {\n      let primaryKeyProp = instanceContainer.properties.filter(x => x.isPrimaryKey)[0];\n      if (primaryKeyProp && this.modelInstance[primaryKeyProp.name]) jObject[primaryKeyProp.name] = this.modelInstance[primaryKeyProp.name];\n    }\n  }\n\n  get modifiedValue() {\n    let jObject = {};\n\n    if (Object.keys(this._modified).length > 0) {\n      this.bindPrimaryKey(this.modelInstance, jObject);\n\n      for (var columnName in this._modified) {\n        if (this.controls[columnName] instanceof RxFormGroup) jObject[columnName] = this.controls[columnName].modifiedValue;else if (this.controls[columnName] instanceof FormArray) {\n          let formArray = this.controls[columnName];\n          jObject[columnName] = [];\n\n          for (var i = 0; i < this._modified[columnName].length; i++) {\n            let modifiedValue = formArray.controls[i].modifiedValue;\n            if (Object.keys(modifiedValue).length > 0) jObject[columnName].push(modifiedValue);\n          }\n\n          if (jObject[columnName].length == 0) delete jObject[columnName];\n        } else jObject[columnName] = this._modified[columnName];\n      }\n\n      return jObject;\n    }\n\n    return this._modified;\n  }\n\n  get isModified() {\n    return this._isModified;\n  }\n\n  patch(controlName) {\n    if (controlName) {\n      let control = this.controls[controlName];\n      this.processModified(controlName, control);\n    } else {\n      this.nestedFormsModification();\n    }\n\n    this._isModified = Object.keys(this._modified).length > 0;\n    if (!this._isModified) this.nestedArrayIsModified();\n    if (this.parent && this.parent.patch) this.parent.patch();\n  }\n\n  isDirty() {\n    let isDirty = false;\n\n    for (let name in this.value) {\n      let currentValue = this.modelInstance[name];\n\n      if (!(this.controls[name] instanceof FormGroup || this.controls[name] instanceof FormArray)) {\n        isDirty = ApplicationUtil.notEqualTo(this.baseObject[name], currentValue);\n      } else if (this.controls[name] instanceof RxFormGroup) isDirty = this.controls[name].isDirty();else if (this.controls[name] instanceof FormArray) {\n        for (let formGroup of this.controls[name].controls) {\n          isDirty = formGroup.isDirty();\n        }\n      }\n\n      if (isDirty) break;\n    }\n\n    return isDirty;\n  }\n\n  resetForm(options) {\n    for (let name in this.controls) {\n      if (isResetControl(name, this.controls[name], options)) {\n        if (this.controls[name] instanceof FormGroup) this.controls[name].resetForm(getNestedOptions(name, options));else if (this.controls[name] instanceof FormArray) {\n          this.controls[name].resetForm(options && options.value ? options.value[name] : undefined);\n        } else {\n          if (options && options.value && RegexValidator.isNotBlank(options.value[name])) this.controls[name].reset(options.value[name]);else this.controls[name].reset();\n        }\n      }\n    }\n  }\n\n  commit() {\n    for (let name in this.controls) {\n      if (this.controls[name] instanceof FormGroup) this.controls[name].commit();else if (this.controls[name] instanceof FormArray) {\n        this.controls[name].commit();\n      } else {\n        this.controls[name].commit();\n      }\n    }\n  }\n\n  patchModelValue(value, options) {\n    if (value) {\n      for (let name in this.controls) {\n        if (this.controls[name] instanceof RxFormGroup && value[name]) this.controls[name].patchModelValue(value[name], options);else if (this.controls[name] instanceof FormArray && Array.isArray(value[name])) {\n          let index = 0;\n\n          for (let formGroup of this.controls[name].controls) {\n            if (value[name][index]) formGroup.patchModelValue(value[name][index], options);\n            index = index + 1;\n          }\n        } else if (value[name] !== undefined) this.controls[name].patchValue(value[name], options);\n      }\n    }\n  }\n\n  getErrorSummary(onlyMessage) {\n    let jObject = {};\n    Object.keys(this.controls).forEach(columnName => {\n      if (this.controls[columnName] instanceof FormGroup) {\n        let error = this.controls[columnName].getErrorSummary(false);\n        if (Object.keys(error).length > 0) jObject[columnName] = error;\n      } else if (this.controls[columnName] instanceof FormArray) {\n        let index = 0;\n\n        for (let formGroup of this.controls[columnName].controls) {\n          let error = formGroup.getErrorSummary(false);\n\n          if (Object.keys(error).length > 0) {\n            error.index = index;\n            if (!jObject[columnName]) jObject[columnName] = [];\n            jObject[columnName].push(error);\n          }\n\n          index++;\n        }\n      } else {\n        if (this.controls[columnName].errors) {\n          let error = this.controls[columnName].errors;\n          if (onlyMessage) for (let validationName in error) jObject[columnName] = error[validationName].message;else jObject[columnName] = error;\n        }\n      }\n    });\n    return jObject;\n  }\n\n  valueChangedSync() {\n    Object.keys(this.controls).forEach(columnName => {\n      if (!(this.controls[columnName] instanceof FormArray || this.controls[columnName] instanceof RxFormArray) && !(this.controls[columnName] instanceof FormGroup || this.controls[columnName] instanceof RxFormGroup) && !(this.entityObject[columnName] instanceof FormControl || this.entityObject[columnName] instanceof RxFormControl) && this.controls[columnName].getControlValue && ApplicationUtil.notEqualTo(this.controls[columnName].getControlValue(), this.entityObject[columnName])) {\n        this.controls[columnName].setValue(this.entityObject[columnName], {\n          updateChanged: true\n        });\n      } else if (this.controls[columnName] instanceof FormArray || this.controls[columnName] instanceof RxFormArray) {\n        for (let formGroup of this.controls[columnName].controls) {\n          formGroup.valueChangedSync();\n        }\n      } else if (this.controls[columnName] instanceof RxFormGroup) {\n        this.controls[columnName].valueChangedSync();\n      }\n    });\n  }\n\n  refreshDisable() {\n    Object.keys(this.controls).forEach(columnName => {\n      if (!(this.controls[columnName] instanceof FormArray || this.controls[columnName] instanceof RxFormArray) && !(this.controls[columnName] instanceof FormGroup || this.controls[columnName] instanceof RxFormGroup)) {\n        this.controls[columnName].refresh();\n      } else if (this.controls[columnName] instanceof RxFormGroup) {\n        this.controls[columnName].refreshDisable();\n      }\n    });\n  }\n\n  bindErrorMessages() {\n    Object.keys(this.controls).forEach(columnName => {\n      if (!(this.controls[columnName] instanceof FormArray || this.controls[columnName] instanceof RxFormArray) && !(this.controls[columnName] instanceof FormGroup || this.controls[columnName] instanceof RxFormGroup)) {\n        this.controls[columnName].bindError();\n      } else if (this.controls[columnName] instanceof RxFormGroup) {\n        this.controls[columnName].bindErrorMessages();\n      }\n    });\n  }\n\n  get submitted() {\n    return this._submitted;\n  }\n\n  set submitted(value) {\n    this._submitted = value;\n    Object.keys(this.controls).forEach(columnName => {\n      if (this.controls[columnName] instanceof FormArray) {\n        let formArray = this.controls[columnName];\n\n        for (let formGroup of formArray.controls) formGroup.submitted = value;\n      } else if (this.controls[columnName] instanceof FormGroup) {\n        this.controls[columnName].submitted = value;\n      } else this.controls[columnName].bindError();\n    });\n  }\n\n  get modelInstanceValue() {\n    return clone(this.entityObject);\n  }\n\n  get modelInstance() {\n    return this.entityObject;\n  }\n\n  get controlsError() {\n    return this.getErrorSummary(true);\n  }\n\n  toFormData(options) {\n    return this.formDataProvider.convertToFormData(this.value, options);\n  }\n\n  processModified(controlName, control) {\n    if (control.isModified) this._modified[controlName] = control.value;else delete this._modified[controlName];\n    this._isModified = Object.keys(this._modified).length > 0;\n  }\n\n  nestedArrayIsModified() {\n    for (var controlName in this.controls) {\n      if (this.controls[controlName] instanceof RxFormArray) this._isModified = this.controls[controlName].isModified;\n      if (this._isModified) break;\n    }\n  }\n\n  setBackEndErrors(errors) {\n    Object.keys(errors).forEach(controlName => {\n      if (this.controls[controlName]) {\n        if (this.controls[controlName] instanceof FormGroup) this.controls[controlName].setBackEndErrors(errors[controlName]);else this.controls[controlName].setBackEndErrors(errors[controlName]);\n      }\n    });\n  }\n\n  clearBackEndErrors(errors) {\n    let clearErrors = errors ? Object.keys(errors) : Object.keys(this.controls);\n    clearErrors.forEach(controlName => {\n      if (this.controls[controlName]) {\n        if (this.controls[controlName] instanceof FormGroup) errors ? this.controls[controlName].clearBackEndErrors(errors[controlName]) : this.controls[controlName].clearBackEndErrors();else errors ? this.controls[controlName].clearBackEndErrors(errors[controlName]) : this.controls[controlName].clearBackEndErrors();\n      }\n    });\n  }\n\n  nestedFormsModification() {\n    for (var controlName in this.controls) {\n      if (this.controls[controlName] instanceof RxFormGroup) this.processModified(controlName, this.controls[controlName]);else if (this.controls[controlName] instanceof RxFormArray) {\n        if (this.controls[controlName].isModified) {\n          let formGroups = this.controls[controlName].controls;\n          this._modified[controlName] = [];\n\n          for (var formGroup of formGroups) {\n            if (formGroup.isModified) {\n              if (!this._modified[controlName]) this._modified[controlName] = [];\n\n              this._modified[controlName].push(formGroup.modifiedValue);\n            }\n          }\n\n          if (this._modified[controlName].length == 0) delete this._modified[controlName];\n        } else if (this._modified[controlName]) delete this._modified[controlName];\n      }\n    }\n  }\n\n}\n\nclass FormProvider {\n  static ProcessRule(control, config, isDynamicConfig = false) {\n    if (config && config.expressionProcessed) return true;\n    const formGroupValue = ApplicationUtil.getParentObjectValue(control);\n    const parentObject = control.parent ? ApplicationUtil.cloneValue(control.parent.value) : undefined;\n    let modelInstance = undefined;\n    if (control.parent && control.parent instanceof RxFormGroup) modelInstance = control.parent.modelInstance;\n\n    if (parentObject) {\n      this.updateFormControlValue(parentObject, control.parent.controls, control, config);\n      this.forDisableUpdate(parentObject, config);\n    } else if (config.conditionalExpression) return false;\n\n    return Linq.execute(formGroupValue, config, parentObject, modelInstance, isDynamicConfig);\n  }\n\n  static updateFormControlValue(parentObject, controls, control, config) {\n    for (var controlName in parentObject) {\n      if (!(parentObject[controlName] instanceof Object)) if (controls[controlName] === control) {\n        parentObject[controlName] = control.value;\n        break;\n      }\n    }\n  }\n\n  static forDisableUpdate(parentObject, config) {\n    if (config.disableConfig) Object.keys(config.disableConfig).forEach(column => {\n      parentObject[column] = config.disableConfig[column];\n    });\n  }\n\n}\n\nconst DISABLED_EXPRESSION = \"disableExpression\";\n\nfunction conditionalChangeValidator(conditionalValidationProps) {\n  var timeOuts = [];\n  var oldValue = undefined;\n\n  var setTimeOut = (control, config) => {\n    if (control[DISABLED_EXPRESSION]) runDisabledExpression(control, config);\n    var timeOut = setTimeout(t => {\n      clearTimeout(timeOut);\n      control.updateValueAndValidity({\n        emitEvent: false\n      });\n    }, 100);\n  };\n\n  return control => {\n    let value = control.value;\n\n    if (control.parent && oldValue != value) {\n      const rootFormGroup = ApplicationUtil.getRootFormGroup(control);\n      const parentFormGroup = control.parent;\n      oldValue = value;\n      timeOuts = [];\n      let controlName = ApplicationUtil.getFormControlName(control);\n      let disabledConfig = {\n        [controlName]: value\n      };\n      conditionalValidationProps.forEach(t => {\n        let a = control;\n\n        if (t.indexOf(\"[]\") != -1) {\n          var splitText = t.split(\"[]\");\n          var formArray = rootFormGroup.get([splitText[0]]);\n          if (formArray) formArray.controls.forEach(formGroup => {\n            var abstractControl = formGroup.get(splitText[1]);\n\n            if (abstractControl) {\n              setTimeOut(abstractControl, disabledConfig);\n            }\n          });\n        } else {\n          let splitText = t.split('.');\n\n          if (splitText.length > 1) {\n            var control = null;\n            t.split('.').forEach((name, index) => {\n              control = index == 0 ? rootFormGroup.controls[name] : control.controls[name];\n            });\n          } else {\n            control = parentFormGroup.controls[t];\n          }\n\n          if (control) {\n            setTimeOut(control, disabledConfig);\n          }\n        }\n      });\n    }\n\n    return ObjectMaker.null();\n  };\n}\n\nfunction runDisabledExpression(control, config) {\n  let isDisabled = FormProvider.ProcessRule(control, {\n    conditionalExpression: control[DISABLED_EXPRESSION],\n    disableConfig: config\n  });\n  if (isDisabled && !control.disabled) control.disable();else if (control.disabled) control.enable();\n}\n\nclass ValidatorValueChecker {\n  static pass(control, config) {\n    if (FormProvider.ProcessRule(control, config)) return RegexValidator.isNotBlank(control.value);else return false;\n  }\n\n  static passArrayValue(control, config) {\n    if (FormProvider.ProcessRule(control, config)) return typeof control.value === \"string\" ? RegexValidator.isNotBlank(control.value) : control.value instanceof Array;else return false;\n  }\n\n}\n\nconst ARRAY_CONFIG = \"ArrayConfig\";\nconst FIELD_CONFIG = \"FieldConfig\";\nconst IP_CONFIG = \"IpConfig\";\nconst NUMBER_CONFIG = \"NumberConfig\";\nconst PASSWORD_CONFIG = \"PasswordConfig\";\nconst PATTERN_CONFIG = \"PatternConfig\";\nconst RANGE_CONFIG = \"RangeConfig\";\nconst RELATIONAL_OPERATOR_CONFIG = \"RelationalOperatorConfig\";\nconst CONFIG_REQUIRED_FIELDS = {\n  [ARRAY_CONFIG]: [\"matchValues\"],\n  [FIELD_CONFIG]: [\"fieldName\"],\n  [IP_CONFIG]: [\"version\"],\n  [PASSWORD_CONFIG]: [\"validation\"],\n  [NUMBER_CONFIG]: [\"value\"],\n  [PATTERN_CONFIG]: [\"expression\"],\n  [RANGE_CONFIG]: [\"minimumNumber\", \"maximumNumber\"]\n};\n\nfunction getConfigObject(config, control, configName = '') {\n  return config != undefined && config != true ? configProvider(control, config, configName) : {};\n}\n\nfunction configProvider(control, config, configName) {\n  if (config.dynamicConfig) {\n    let currentConfig = FormProvider.ProcessRule(control, clone(config), true);\n\n    if (typeof currentConfig != \"boolean\") {\n      currentConfig.conditionalExpression = config.conditionalExpression;\n      currentConfig.dynamicConfig = config.dynamicConfig;\n      Object.keys(config).forEach(t => {\n        if (t != \"conditionalExpression\" && t != \"dynamicConfig\" || currentConfig[t] === undefined) {\n          currentConfig[t] = config[t];\n        }\n      });\n      return currentConfig;\n    } else return config;\n  }\n\n  return checkRequiredProps(config, configName);\n}\n\nfunction checkRequiredProps(config, configName) {\n  let props = CONFIG_REQUIRED_FIELDS[configName];\n\n  if (configName) {\n    props.forEach(prop => {\n      if (config[prop] === undefined) throw new Error(`Pass the property of '${prop}' with value in the ${configName}, otherwise it won't work.`);\n    });\n  }\n\n  return config;\n}\n\nconst alphabet = {\n  'danish': /^[A-ZÆØÅ]+$/,\n  'french': /^[A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ]+$/,\n  'german': /^[A-ZÄÖÜß]+$/,\n  'spanish': /^[a-zñáéíóúü]+$/i,\n  'russian': /^[А-ЯЁ]+$/\n};\nconst alphaWithWhitespace = {\n  'danish': /^[A-ZÆØÅ\\s]+$/,\n  'french': /^[A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ\\s]+$/,\n  'german': /^[A-ZÄÖÜß\\s]+$/,\n  'spanish': /^[a-zñáéíóúü\\s]+$/i,\n  'russian': /^[А-ЯЁ\\s]+$/\n};\nconst alphanumeric = {\n  'danish': /^[0-9A-ZÆØÅ]+$/,\n  'french': /^[0-9A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ]+$/,\n  'german': /^[0-9A-ZÄÖÜß]+$/,\n  'spanish': /^[0-9a-zñáéíóúü]+$/i,\n  'russian': /^[0-9А-ЯЁ]+$/\n};\nconst alphanumericWithWitespace = {\n  'danish': /^[0-9A-ZÆØÅ]+$/,\n  'french': /^[0-9A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ]+$/,\n  'german': /^[0-9A-ZÄÖÜß]+$/,\n  'spanish': /^[0-9a-zñáéíóúü\\s]+$/i,\n  'russian': /^[0-9А-ЯЁ]+$/\n};\n\nfunction alphaValidation(configModel, control, regExps, key) {\n  let config = getConfigObject(configModel, control);\n\n  if (ValidatorValueChecker.pass(control, config)) {\n    regExps = getRegex(key, regExps, config);\n    var isValid = !config || !config.allowWhiteSpace ? RegexValidator.isValid(control.value, regExps[0]) : RegexValidator.isValid(control.value, regExps[1]);\n    if (!isValid) return ObjectMaker.toJson(key, config, [control.value]);\n  }\n\n  return ObjectMaker.null();\n}\n\nfunction getRegex(key, regExps, config) {\n  if (config.allowCharacters) if (config.allowWhiteSpace) regExps[1] = new RegExp(`^[0-9a-zA-Z @${config.allowCharacters}]+$`, ``);else regExps[0] = new RegExp(`^[0-9a-zA-Z @${config.allowCharacters}]+$`, ``);\n\n  switch (key) {\n    case \"alpha\":\n      var alphaLocale = config.locale ? config.locale : ReactiveFormConfig.json && ReactiveFormConfig.json.defaultValidationLocale && ReactiveFormConfig.json.defaultValidationLocale.alpha ? ReactiveFormConfig.json.defaultValidationLocale.alpha : \"\";\n      return [alphaLocale && alphaLocale in alphabet ? alphabet[alphaLocale] : regExps[0], alphaLocale && alphaLocale in alphaWithWhitespace ? alphaWithWhitespace[alphaLocale] : regExps[1]];\n      break;\n\n    case \"alphaNumeric\":\n      var alphaNumericLocale = config.locale ? config.locale : ReactiveFormConfig.json && ReactiveFormConfig.json.defaultValidationLocale && ReactiveFormConfig.json.defaultValidationLocale.alphaNumeric ? ReactiveFormConfig.json.defaultValidationLocale.alphaNumeric : \"\";\n      return [alphaNumericLocale && alphaNumericLocale in alphanumeric ? alphanumeric[alphaNumericLocale] : regExps[0], alphaNumericLocale && alphaNumericLocale in alphanumericWithWitespace ? alphanumericWithWitespace[alphaNumericLocale] : regExps[1]];\n      break;\n  }\n}\n\nfunction alphaValidator(configModel) {\n  return control => {\n    return alphaValidation(configModel, control, [RegExRule.alpha, RegExRule.alphaWithSpace], AnnotationTypes.alpha);\n  };\n}\n\nfunction alphaNumericValidator(configModel) {\n  return control => {\n    return alphaValidation(configModel, control, [RegExRule.alphaNumeric, RegExRule.alphaNumericWithSpace], AnnotationTypes.alphaNumeric);\n  };\n}\n\nfunction compareValidator(configModel) {\n  return control => {\n    let config = getConfigObject(configModel, control, FIELD_CONFIG);\n    const compareControl = ApplicationUtil.getFormControl(config.fieldName, control);\n    const controlValue = control.value;\n    const compareControlValue = compareControl ? compareControl.value : '';\n\n    if (RegexValidator.isNotBlank(controlValue) || RegexValidator.isNotBlank(compareControlValue)) {\n      if (!(compareControl && compareControl.value === controlValue)) return ObjectMaker.toJson(AnnotationTypes.compare, config, [controlValue, compareControlValue]);\n    }\n\n    return ObjectMaker.null();\n  };\n}\n\nfunction containsValidator(configModel) {\n  return control => {\n    let config = getConfigObject(configModel, control);\n\n    if (ValidatorValueChecker.pass(control, config)) {\n      let failed = false;\n      const values = config.values ? config.values : [config.value];\n\n      for (let value of values) {\n        failed = control.value.indexOf(value) == -1;\n        if (!failed) break;\n      }\n\n      if (failed) return ObjectMaker.toJson(AnnotationTypes.contains, config, [control.value, config.value]);\n    }\n\n    return ObjectMaker.null();\n  };\n}\n\nfunction checkLength(length, checks) {\n  let isPassed = false;\n\n  for (let check of checks) {\n    isPassed = check == length;\n    if (isPassed) break;\n  }\n\n  return isPassed;\n}\n\nfunction calculate(numbers) {\n  let numberSum = 0;\n\n  for (var i = 0; i < numbers.length; i++) numberSum += parseInt(numbers.substring(i, i + 1));\n\n  let deltas = new Array(0, 1, 2, 3, 4, -4, -3, -2, -1, 0);\n\n  for (var i = numbers.length - 1; i >= 0; i -= 2) {\n    numberSum += deltas[parseInt(numbers.substring(i, i + 1))];\n  }\n\n  let mod = numberSum % 10;\n  mod = 10 - mod;\n  if (mod == 10) mod = 0;\n  return mod;\n}\n\nfunction creditCardValidator(configModel) {\n  let cardDigits = {\n    AmericanExpress: [15],\n    DinersClub: [14, 16, 19],\n    Discover: [16, 19],\n    JCB: [16, 19],\n    Maestro: [12, 16, 19],\n    MasterCard: [16],\n    Visa: [13, 16, 19]\n  };\n\n  function validate(creditCardNumber) {\n    var digit = parseInt(creditCardNumber.substring(creditCardNumber.length - 1, creditCardNumber.length));\n    return calculate(creditCardNumber.substring(0, creditCardNumber.length - 1)) == parseInt(String(digit)) ? !0 : !1;\n  }\n\n  function getCardProviderName(cardNumber) {\n    var cardProviderName = \"\";\n    return /^(5018|5020|5038|5612|5893|6304|6759|6761|6762|6763|0604|6390)\\d+$/.test(cardNumber) ? cardProviderName = \"Maestro\" : /^5[1-5]/.test(cardNumber) ? cardProviderName = \"MasterCard\" : /^4/.test(cardNumber) ? cardProviderName = \"Visa\" : /^3[47]/.test(cardNumber) ? cardProviderName = \"AmericanExpress\" : /^(?:2131|1800|35)/.test(cardNumber) ? cardProviderName = \"JCB\" : /^3(?:0[0-5]|[68])/.test(cardNumber) ? cardProviderName = \"DinersClub\" : /^6(?:011|5)/.test(cardNumber) && (cardProviderName = \"Discover\"), cardProviderName;\n  }\n\n  return control => {\n    const controlValue = control.value;\n    let config = getConfigObject(configModel, control);\n    const parentObject = control.parent ? control.parent.value : undefined;\n\n    if (FormProvider.ProcessRule(control, config)) {\n      if (RegexValidator.isNotBlank(controlValue)) {\n        let isValid = false;\n        let cardTypes = config.fieldName && parentObject[config.fieldName] ? [parentObject[config.fieldName]] : config.creditCardTypes;\n        let cardType = '';\n\n        for (let creditCardType of cardTypes) {\n          isValid = checkLength(controlValue.length, cardDigits[creditCardType]) && getCardProviderName(controlValue) == creditCardType && validate(controlValue);\n          cardType = creditCardType;\n          if (isValid) break;\n        }\n\n        if (!isValid) return ObjectMaker.toJson(AnnotationTypes.creditCard, config, [controlValue, cardType]);\n      }\n    }\n\n    return ObjectMaker.null();\n  };\n}\n\nfunction regexValidation(configModel, control, regExp, key) {\n  let config = getConfigObject(configModel, control);\n  return validate(config, control, regExp, key);\n}\n\nfunction validate(config, control, regExp, key) {\n  if (ValidatorValueChecker.pass(control, config)) {\n    if (!RegexValidator.isValid(control.value, regExp)) return ObjectMaker.toJson(key, config, [control.value]);\n  }\n\n  return ObjectMaker.null();\n}\n\nfunction digitValidator(configModel) {\n  return control => {\n    return regexValidation(configModel, control, RegExRule.onlyDigit, AnnotationTypes.digit);\n  };\n}\n\nfunction emailValidator(configModel) {\n  return control => {\n    return regexValidation(configModel, control, RegExRule.basicEmail, AnnotationTypes.email);\n  };\n}\n\nfunction hexColorValidator(configModel) {\n  return control => {\n    return regexValidation(configModel, control, RegExRule.strictHexColor, AnnotationTypes.hexColor);\n  };\n}\n\nfunction lowercaseValidator(configModel) {\n  return control => {\n    let config = getConfigObject(configModel, control);\n\n    if (ValidatorValueChecker.pass(control, config)) {\n      if (!(control.value === control.value.toLowerCase())) return ObjectMaker.toJson(AnnotationTypes.lowerCase, config, [control.value]);\n    }\n\n    return ObjectMaker.null();\n  };\n}\n\nconst OPERATORS = {\n  lessThan: \"<\",\n  greaterThan: \">\",\n  lessThanEqualTo: \"<=\",\n  greaterThanEqualTo: \">=\"\n};\n\nfunction runCondition$1(leftValue, rightValue, operator) {\n  let result = false;\n\n  switch (operator) {\n    case OPERATORS.lessThan:\n    case OPERATORS.greaterThan:\n      result = leftValue > rightValue;\n      break;\n\n    case OPERATORS.lessThanEqualTo:\n    case OPERATORS.greaterThanEqualTo:\n      result = leftValue >= rightValue;\n      break;\n  }\n\n  return result;\n}\n\nfunction dateChecker(control, config, operationType) {\n  config = getConfigObject(config, control);\n  var dateProvider = new DateProvider();\n\n  if (FormProvider.ProcessRule(control, config)) {\n    if (RegexValidator.isNotBlank(control.value)) {\n      let checkDate = dateProvider.getCompareDate(config, control);\n\n      if (dateProvider.isDate(control.value) || dateProvider.isValid(control.value, config)) {\n        let currentControlValue = dateProvider.getDate(control.value);\n        let isValid = operationType == AnnotationTypes.minDate ? runCondition$1(currentControlValue, checkDate, config.operator || OPERATORS.greaterThanEqualTo) : runCondition$1(checkDate, currentControlValue, config.operator || OPERATORS.lessThanEqualTo);\n        if (!isValid) return ObjectMaker.toJson(operationType, config, [control.value, checkDate]);\n      } else return ObjectMaker.toJson(operationType, config, [control.value, checkDate]);\n    }\n  }\n\n  return ObjectMaker.null();\n}\n\nfunction validateDate(control, config, operationType) {\n  config = getConfigObject(config, control);\n  var dateProvider = new DateProvider();\n\n  if (FormProvider.ProcessRule(control, config)) {\n    if (RegexValidator.isNotBlank(control.value)) {\n      if (!dateProvider.isDate(control.value) && !dateProvider.isValid(control.value, config)) {\n        return ObjectMaker.toJson(operationType, config, [control.value]);\n      }\n    }\n  }\n\n  return ObjectMaker.null();\n}\n\nfunction maxDateValidator(configModel) {\n  return control => {\n    return dateChecker(control, configModel, AnnotationTypes.maxDate);\n  };\n}\n\nfunction maxLengthValidator(configModel) {\n  return control => {\n    let config = getConfigObject(configModel, control, NUMBER_CONFIG);\n\n    if (ValidatorValueChecker.pass(control, config)) {\n      if (!(control.value.length <= config.value)) return ObjectMaker.toJson(AnnotationTypes.maxLength, config, [control.value, config.value]);\n    }\n\n    return ObjectMaker.null();\n  };\n}\n\nfunction maxNumberValidator(configModel) {\n  return control => {\n    let config = getConfigObject(configModel, control, NUMBER_CONFIG);\n\n    if (ValidatorValueChecker.pass(control, config)) {\n      if (!(parseFloat(control.value) <= config.value)) return ObjectMaker.toJson(AnnotationTypes.maxNumber, config, [control.value, config.value]);\n    }\n\n    return ObjectMaker.null();\n  };\n}\n\nfunction minDateValidator(configModel) {\n  return control => {\n    return dateChecker(control, configModel, AnnotationTypes.minDate);\n  };\n}\n\nfunction minLengthValidator(configModel) {\n  return control => {\n    let config = getConfigObject(configModel, control, NUMBER_CONFIG);\n\n    if (ValidatorValueChecker.pass(control, config)) {\n      if (!(String(control.value).length >= config.value)) return ObjectMaker.toJson(AnnotationTypes.minLength, config, [control.value, config.value]);\n    }\n\n    return ObjectMaker.null();\n  };\n}\n\nfunction minNumberValidator(configModel) {\n  return control => {\n    let config = getConfigObject(configModel, control, NUMBER_CONFIG);\n\n    if (ValidatorValueChecker.pass(control, config)) {\n      if (!(parseFloat(control.value) >= config.value)) return ObjectMaker.toJson(AnnotationTypes.minNumber, config, [control.value, config.value]);\n    }\n\n    return ObjectMaker.null();\n  };\n}\n\nfunction passwordValidator(configModel) {\n  function getMessageObject(jObject, keyName) {\n    if (!jObject.message && !jObject.messageKey) {\n      let message = ObjectMaker.getPasswordMessage();\n      jObject.message = message && typeof message == \"string\" ? message : ApplicationUtil.isObject(message) ? message[keyName] : \"\";\n      if (!jObject.message) jObject.message = message[\"password\"];\n      jObject.messageKey = \"\";\n    }\n\n    return jObject;\n  }\n\n  return control => {\n    let config = getConfigObject(configModel, control, PASSWORD_CONFIG);\n    let controlValue = control.value;\n\n    if (RegexValidator.isNotBlank(controlValue)) {\n      let validation = RegexValidator.isValidPassword(config.validation, controlValue);\n      let jObject = {};\n      jObject.message = config.message && config.message[validation.keyName] ? config.message[validation.keyName] : typeof config.message == \"string\" ? config.message : '';\n      jObject.messageKey = config.messageKey && config.messageKey[validation.keyName] ? config.messageKey[validation.keyName] : typeof config.messageKey == \"string\" ? config.messageKey : \"\";\n      jObject = getMessageObject(jObject, validation.keyName);\n      if (!validation.isValid) return ObjectMaker.toJson(AnnotationTypes.password, jObject, [controlValue]);\n    }\n\n    return ObjectMaker.null();\n  };\n}\n\nfunction rangeValidator(configModel) {\n  return control => {\n    let config = getConfigObject(configModel, control, RANGE_CONFIG);\n\n    if (ValidatorValueChecker.pass(control, config)) {\n      if (!((control.value || control.value === 0) && parseFloat(control.value) >= config.minimumNumber && parseFloat(control.value) <= config.maximumNumber)) return ObjectMaker.toJson(AnnotationTypes.range, config, [control.value, config.minimumNumber, config.maximumNumber]);\n    }\n\n    return ObjectMaker.null();\n  };\n}\n\nfunction uppercaseValidator(configModel) {\n  return control => {\n    let config = getConfigObject(configModel, control);\n\n    if (ValidatorValueChecker.pass(control, config)) {\n      if (!(control.value === control.value.toUpperCase())) return ObjectMaker.toJson(AnnotationTypes.upperCase, config, [control.value]);\n    }\n\n    return ObjectMaker.null();\n  };\n}\n\nfunction requiredValidator(configModel) {\n  return control => {\n    let config = getConfigObject(configModel, control);\n\n    if (FormProvider.ProcessRule(control, config)) {\n      if (!RegexValidator.isNotBlank(control.value)) {\n        return ObjectMaker.toJson(AnnotationTypes.required, config, []);\n      }\n    }\n\n    return ObjectMaker.null();\n  };\n}\n\nfunction patternValidator(configModel) {\n  return control => {\n    let config = getConfigObject(configModel, control, PATTERN_CONFIG);\n\n    if (ValidatorValueChecker.pass(control, config)) {\n      for (var pattern in config.expression) if (!RegexValidator.isValid(control.value, config.expression[pattern])) return ObjectMaker.toJson(pattern, config, [control.value]);\n    }\n\n    return ObjectMaker.null();\n  };\n}\n\nfunction timeValidator(configModel) {\n  return control => {\n    let config = getConfigObject(configModel, control);\n\n    if (ValidatorValueChecker.pass(control, config)) {\n      let isValid = config.allowSeconds ? RegexValidator.isValid(control.value, RegExRule.timeWithSeconds) : RegexValidator.isValid(control.value, RegExRule.time);\n      if (!isValid) return ObjectMaker.toJson(AnnotationTypes.time, config, [control.value]);\n    }\n\n    return ObjectMaker.null();\n  };\n}\n\nfunction urlValidation(configModel, control) {\n  var regex = RegExRule.url;\n  let config = getConfigObject(configModel, control);\n\n  if (config && config.urlValidationType) {\n    switch (config.urlValidationType) {\n      case 1:\n        regex = RegExRule.url;\n        break;\n\n      case 2:\n        regex = RegExRule.localhostUrl;\n        break;\n\n      case 3:\n        regex = RegExRule.interanetUrl;\n        break;\n    }\n  }\n\n  return validate(config, control, regex, AnnotationTypes.url);\n}\n\nfunction urlValidator(configModel) {\n  return control => {\n    return urlValidation(configModel, control);\n  };\n}\n\nfunction jsonValidator(configModel) {\n  function process(value) {\n    var result = false;\n\n    try {\n      var json = JSON.parse(value);\n      result = !!json && typeof json === 'object';\n    } catch (ex) {\n      result = false;\n    }\n\n    return result;\n  }\n\n  return control => {\n    let config = getConfigObject(configModel, control);\n\n    if (ValidatorValueChecker.pass(control, config)) {\n      if (!process(control.value)) return ObjectMaker.toJson(AnnotationTypes.json, config, [control.value]);\n    }\n\n    return ObjectMaker.null();\n  };\n}\n\nconst operatorOpposite = {\n  [AnnotationTypes.greaterThan]: AnnotationTypes.lessThan,\n  [AnnotationTypes.lessThan]: AnnotationTypes.greaterThan,\n  [AnnotationTypes.greaterThanEqualTo]: AnnotationTypes.lessThanEqualTo,\n  [AnnotationTypes.lessThanEqualTo]: AnnotationTypes.greaterThanEqualTo\n};\n\nfunction relationalCheck(control, config, relationalOperatorName) {\n  config = getConfigObject(config, control);\n  const matchControl = config.fieldName ? ApplicationUtil.getFormControl(config.fieldName, control) : undefined;\n  const matchControlValue = matchControl ? matchControl.value : config.value !== undefined ? config.value : '';\n\n  if (FormProvider.ProcessRule(control, config)) {\n    if (config.isArrayControl) return arrayControlValidation(control, config, relationalOperatorName);\n    if (isValid$1(control, matchControlValue, relationalOperatorName) === false) return ObjectMaker.toJson(relationalOperatorName, config, [control.value, matchControlValue]);\n  }\n\n  return ObjectMaker.null();\n}\n\nfunction isValid$1(control, matchControlValue, relationalOperatorName) {\n  if (RegexValidator.isNotBlank(control.value) && RegexValidator.isNotBlank(matchControlValue)) {\n    let isValid = false;\n\n    switch (relationalOperatorName) {\n      case AnnotationTypes.greaterThan:\n        isValid = parseFloat(control.value) > parseFloat(matchControlValue);\n        break;\n\n      case AnnotationTypes.lessThan:\n        isValid = parseFloat(control.value) < parseFloat(matchControlValue);\n        break;\n\n      case AnnotationTypes.greaterThanEqualTo:\n        isValid = parseFloat(control.value) >= parseFloat(matchControlValue);\n        break;\n\n      case AnnotationTypes.lessThanEqualTo:\n        isValid = parseFloat(control.value) <= parseFloat(matchControlValue);\n        break;\n    }\n\n    return isValid;\n  }\n\n  return null;\n}\n\nfunction setTimeFunc(invalidateControls) {\n  let timeOut = setTimeout(() => {\n    invalidateControls.forEach(t => {\n      t.updateValueAndValidity();\n    });\n    clearTimeout(timeOut);\n  }, 200);\n}\n\nfunction arrayControlValidation(control, config, relationalOperatorName) {\n  let formArray = ApplicationUtil.getParentFormArray(control);\n  let parentFormGroup = control.parent ? control.parent : undefined;\n  let oppositeOperator = operatorOpposite[relationalOperatorName];\n  let updateValidityControls = [];\n\n  if (formArray && parentFormGroup && formArray.controls.length > 1) {\n    let indexOf = formArray.controls.indexOf(parentFormGroup);\n    let fieldName = ApplicationUtil.getFormControlName(control);\n    let valid = true;\n    if (indexOf > 0) valid = validateControl(formArray, control, indexOf - 1, fieldName, oppositeOperator, relationalOperatorName, updateValidityControls);\n    if (valid && formArray.controls.length > indexOf + 1) valid = validateControl(formArray, control, indexOf + 1, fieldName, relationalOperatorName, relationalOperatorName, updateValidityControls);\n    if (updateValidityControls.length > 0) setTimeFunc(updateValidityControls);\n    if (valid === false) return ObjectMaker.toJson(relationalOperatorName, config, [control.value]);\n  }\n\n  return ObjectMaker.null();\n}\n\nfunction validateControl(formArray, control, indexOf, fieldName, oppositeOperator, relationalOperatorName, updateValidityControls) {\n  let valid = false;\n  let formGroup = formArray.controls[indexOf];\n\n  if (formGroup && formGroup.controls) {\n    let formControl = formGroup.controls[fieldName];\n    valid = isValid$1(control, formControl.value, oppositeOperator);\n    if (valid && formControl.errors && formControl.errors[relationalOperatorName]) updateValidityControls.push(formControl);\n  }\n\n  return valid;\n}\n\nfunction greaterThanValidator(configModel) {\n  return control => {\n    return relationalCheck(control, configModel, AnnotationTypes.greaterThan);\n  };\n}\n\nfunction greaterThanEqualToValidator(configModel) {\n  return control => {\n    return relationalCheck(control, configModel, AnnotationTypes.greaterThanEqualTo);\n  };\n}\n\nfunction lessThanEqualToValidator(configModel) {\n  return control => {\n    return relationalCheck(control, configModel, AnnotationTypes.lessThanEqualTo);\n  };\n}\n\nfunction lessThanValidator(configModel) {\n  return control => {\n    return relationalCheck(control, configModel, AnnotationTypes.lessThan);\n  };\n}\n\nfunction choiceValidator(configModel) {\n  return control => {\n    let config = getConfigObject(configModel, control);\n\n    if (FormProvider.ProcessRule(control, config)) {\n      if (control.value instanceof Array) {\n        config.minLength = config.minLength == undefined ? 0 : config.minLength;\n        config.maxLength = config.maxLength == undefined ? 0 : config.maxLength;\n        if (control.value.length < config.minLength || config.maxLength !== 0 && control.value.length > config.maxLength) return ObjectMaker.toJson(AnnotationTypes.choice, config, [control.value]);\n      }\n    }\n\n    return ObjectMaker.null();\n  };\n}\n\nfunction differentValidator(configModel) {\n  return control => {\n    let config = getConfigObject(configModel, control, FIELD_CONFIG);\n\n    if (ValidatorValueChecker.pass(control, config)) {\n      const differentControl = ApplicationUtil.getFormControl(config.fieldName, control);\n      const differentControlValue = differentControl ? differentControl.value : '';\n      if (!(differentControl && differentControl.value != control.value)) return ObjectMaker.toJson(AnnotationTypes.different, config, [control.value, differentControlValue]);\n    }\n\n    return ObjectMaker.null();\n  };\n}\n\nfunction numericValidator(configModel) {\n  return control => {\n    if (configModel && (!control[VALIDATOR_CONFIG$2] || !control[VALIDATOR_CONFIG$2][AnnotationTypes.numeric])) ApplicationUtil.configureControl(control, configModel, AnnotationTypes.numeric);\n    let config = getConfigObject(configModel, control);\n\n    if (ValidatorValueChecker.pass(control, config)) {\n      if (!RegexValidator.isValid(control.value, ApplicationUtil.numericValidation(config.allowDecimal, config.acceptValue))) return ObjectMaker.toJson(AnnotationTypes.numeric, config, [control.value]);\n    }\n\n    return ObjectMaker.null();\n  };\n}\n\nfunction evenValidator(configModel) {\n  return control => {\n    let config = getConfigObject(configModel, control);\n\n    if (ValidatorValueChecker.pass(control, config)) {\n      if (!(control.value % 2 == 0)) return ObjectMaker.toJson(AnnotationTypes.even, config, [control.value]);\n    }\n\n    return ObjectMaker.null();\n  };\n}\n\nfunction oddValidator(configModel) {\n  return control => {\n    let config = getConfigObject(configModel, control);\n\n    if (ValidatorValueChecker.pass(control, config)) {\n      if (!!(control.value % 2 == 0) || !ApplicationUtil.isNumeric(control.value)) return ObjectMaker.toJson(AnnotationTypes.odd, config, [control.value]);\n    }\n\n    return ObjectMaker.null();\n  };\n}\n\nfunction factorValidator(configModel) {\n  function positiveFactors(dividend, value) {\n    let isPositive = false;\n\n    for (var index = 1; index <= Math.floor(Math.sqrt(dividend)); index += 1) {\n      if (dividend % index === 0) {\n        if (index == value) isPositive = true;\n        if (dividend / index !== index) if (dividend / index == value) isPositive = true;\n        if (isPositive) break;\n      }\n    }\n\n    return isPositive;\n  }\n\n  return control => {\n    let config = getConfigObject(configModel, control);\n    const dividendField = control.parent && config.fieldName ? ApplicationUtil.getFormControl(config.fieldName, control) : undefined;\n    const dividend = config.fieldName && dividendField ? dividendField.value : config.dividend;\n\n    if (FormProvider.ProcessRule(control, config)) {\n      if (RegexValidator.isNotBlank(control.value) && dividend > 0) {\n        if (!RegexValidator.isValid(control.value, RegExRule.onlyDigit) || !positiveFactors(dividend, parseInt(control.value))) return ObjectMaker.toJson(AnnotationTypes.factor, config, [control.value]);\n      }\n    }\n\n    return ObjectMaker.null();\n  };\n}\n\nfunction leapYearValidator(configModel) {\n  return control => {\n    let config = getConfigObject(configModel, control);\n\n    if (ValidatorValueChecker.pass(control, config)) {\n      var isValid = control.value % 100 === 0 ? control.value % 400 === 0 : control.value % 4 === 0;\n      if (!isValid) return ObjectMaker.toJson(AnnotationTypes.leapYear, config, [control.value]);\n    }\n\n    return ObjectMaker.null();\n  };\n}\n\nfunction allOfValidator(configModel) {\n  return control => {\n    let config = getConfigObject(configModel, control, ARRAY_CONFIG);\n\n    if (ValidatorValueChecker.passArrayValue(control, config)) {\n      var testResult = false;\n\n      for (let value of config.matchValues) {\n        testResult = control.value.some(y => y == value);\n        if (!testResult) break;\n      }\n\n      if (!testResult) return ObjectMaker.toJson(AnnotationTypes.allOf, config, [control.value]);\n    }\n\n    return ObjectMaker.null();\n  };\n}\n\nfunction oneOfValidator(configModel) {\n  return control => {\n    let config = getConfigObject(configModel, control, ARRAY_CONFIG);\n\n    if (ValidatorValueChecker.passArrayValue(control, config)) {\n      var testResult = false;\n\n      for (let value of config.matchValues) {\n        let matchValue = ApplicationUtil.lowerCaseWithTrim(value);\n        testResult = Array.isArray(control.value) ? control.value.some(y => ApplicationUtil.lowerCaseWithTrim(y) === matchValue) : ApplicationUtil.lowerCaseWithTrim(control.value) === matchValue;\n        if (testResult) break;\n      }\n\n      if (!testResult) return ObjectMaker.toJson(AnnotationTypes.oneOf, config, [control.value]);\n    }\n\n    return ObjectMaker.null();\n  };\n}\n\nfunction noneOfValidator(configModel) {\n  return control => {\n    let config = getConfigObject(configModel, control, ARRAY_CONFIG);\n\n    if (FormProvider.ProcessRule(control, config)) {\n      var testResult = false;\n\n      for (let value of config.matchValues) {\n        let matchValue = ApplicationUtil.lowerCaseWithTrim(value);\n        testResult = Array.isArray(control.value) ? control.value.some(y => ApplicationUtil.lowerCaseWithTrim(y) === matchValue) : ApplicationUtil.lowerCaseWithTrim(control.value) === matchValue;\n        if (testResult) break;\n      }\n\n      if (testResult) return ObjectMaker.toJson(AnnotationTypes.noneOf, config, [control.value]);\n    }\n\n    return ObjectMaker.null();\n  };\n}\n\nfunction macValidator(configModel) {\n  return control => {\n    return regexValidation(configModel, control, RegExRule.macId, AnnotationTypes.mac);\n  };\n}\n\nfunction asciiValidator(configModel) {\n  return control => {\n    return regexValidation(configModel, control, RegExRule.ascii, AnnotationTypes.ascii);\n  };\n}\n\nfunction dataUriValidator(configModel) {\n  return control => {\n    return regexValidation(configModel, control, RegExRule.dataUri, AnnotationTypes.dataUri);\n  };\n}\n\nfunction portValidator(configModel) {\n  return control => {\n    let config = getConfigObject(configModel, control);\n\n    if (ValidatorValueChecker.pass(control, config)) {\n      let isValid = RegexValidator.isValid(control.value, RegExRule.onlyDigit) && control.value >= 0 && control.value <= 65535;\n      if (!isValid) return ObjectMaker.toJson(AnnotationTypes.port, config, [control.value]);\n    }\n\n    return ObjectMaker.null();\n  };\n}\n\nfunction latLongValidator(configModel) {\n  return control => {\n    let config = getConfigObject(configModel, control);\n\n    if (ValidatorValueChecker.pass(control, config)) {\n      let splitText = control.value.split(',');\n      if (!(splitText.length > 1 && RegexValidator.isValid(splitText[0], RegExRule.lat) && RegexValidator.isValid(splitText[1], RegExRule.long))) return ObjectMaker.toJson(AnnotationTypes.latLong, config, [control.value]);\n    }\n\n    return ObjectMaker.null();\n  };\n}\n\nfunction extensionValidator(configModel) {\n  return (control, files) => {\n    let config = getConfigObject(configModel, control);\n    if (!control[VALIDATOR_CONFIG$2] || !control[VALIDATOR_CONFIG$2][AnnotationTypes.extension]) ApplicationUtil.configureControl(control, config, AnnotationTypes.extension);\n\n    if (files && FormProvider.ProcessRule(control, config)) {\n      if (RegexValidator.isNotBlank(control.value)) {\n        let testResult = true;\n        let extension = '';\n\n        for (var i = 0; i < files.length; i++) {\n          let file = files.item(i);\n          let splitText = file.name.split(\".\");\n          extension = splitText[splitText.length - 1];\n          let result = config.extensions.filter(t => {\n            return extension.toLowerCase() == t.toLowerCase();\n          })[0];\n\n          if (!result && !configModel.isExcludeExtensions) {\n            testResult = false;\n            break;\n          } else {\n            if (result && configModel.isExcludeExtensions) {\n              testResult = false;\n              break;\n            }\n          }\n        }\n\n        if (!testResult) return ObjectMaker.toJson(AnnotationTypes.extension, config, [extension, config.extensions.join(\",\")]);\n      }\n    }\n\n    return ObjectMaker.null();\n  };\n}\n\nfunction fileSizeValidator(configModel) {\n  return (control, files) => {\n    let config = getConfigObject(configModel, control);\n    if (!control[VALIDATOR_CONFIG$2] || !control[VALIDATOR_CONFIG$2][AnnotationTypes.fileSize]) ApplicationUtil.configureControl(control, config, AnnotationTypes.fileSize);\n\n    if (files && FormProvider.ProcessRule(control, config)) {\n      if (RegexValidator.isNotBlank(control.value)) {\n        let minFileSize = config.minSize ? config.minSize : 0;\n        let testResult = false;\n        let fileSize = 0;\n\n        for (var i = 0; i < files.length; i++) {\n          let file = files.item(i);\n          fileSize = file.size;\n          testResult = !(fileSize >= minFileSize && fileSize <= config.maxSize);\n          if (testResult) break;\n        }\n\n        if (testResult) return ObjectMaker.toJson(AnnotationTypes.fileSize, config, [fileSize, minFileSize, config.maxSize]);\n      }\n    }\n\n    return ObjectMaker.null();\n  };\n}\n\nfunction endsWithValidator(configModel) {\n  return control => {\n    let config = getConfigObject(configModel, control);\n\n    if (ValidatorValueChecker.pass(control, config)) {\n      let failed = false;\n      let values = config.values ? config.values : [config.value];\n\n      for (let value of values) {\n        var endString = String(control.value).substr(control.value.length - value.length, value.length);\n        failed = endString != value;\n        if (!failed) break;\n      }\n\n      if (failed) return ObjectMaker.toJson(AnnotationTypes.endsWith, config, [control.value, config.value]);\n    }\n\n    return ObjectMaker.null();\n  };\n}\n\nfunction startsWithValidator(configModel) {\n  return control => {\n    let config = getConfigObject(configModel, control);\n\n    if (ValidatorValueChecker.pass(control, config)) {\n      let failed = false;\n      let values = config.values ? config.values : [config.value];\n\n      for (let value of values) {\n        let startString = String(control.value).substr(0, value.length);\n        failed = config.isRestrict && String(startString).toLowerCase() == String(value).toLowerCase() || !config.isRestrict && startString != value;\n        if (!failed) break;\n      }\n\n      if (failed) return ObjectMaker.toJson(AnnotationTypes.startsWith, config, [control.value, config.value]);\n    }\n\n    return ObjectMaker.null();\n  };\n}\n\nfunction primeNumberValidator(configModel) {\n  function isPrime(value) {\n    let isPrimeNumber = value != 1;\n\n    for (var i = 2; i < value; i++) {\n      if (value % i == 0) {\n        isPrimeNumber = false;\n        break;\n      }\n    }\n\n    return isPrimeNumber;\n  }\n\n  return control => {\n    let config = getConfigObject(configModel, control);\n\n    if (ValidatorValueChecker.pass(control, config)) {\n      if (!ApplicationUtil.isNumeric(control.value) || !isPrime(control.value)) return ObjectMaker.toJson(AnnotationTypes.primeNumber, config, [control.value]);\n    }\n\n    return ObjectMaker.null();\n  };\n}\n\nfunction latitudeValidator(configModel) {\n  return control => {\n    return regexValidation(configModel, control, RegExRule.lat, AnnotationTypes.latitude);\n  };\n}\n\nfunction longitudeValidator(configModel) {\n  return control => {\n    return regexValidation(configModel, control, RegExRule.long, AnnotationTypes.longitude);\n  };\n}\n\nfunction composeValidator(configModel) {\n  return control => {\n    let config = getConfigObject(configModel, control);\n\n    if (FormProvider.ProcessRule(control, config)) {\n      if (config.validators) {\n        let result = undefined;\n\n        for (let validator of config.validators) {\n          result = validator(control);\n          if (result) break;\n        }\n\n        if (result) return config.messageKey || config.message ? ObjectMaker.toJson(config.messageKey || AnnotationTypes.compose, config, [control.value]) : result;\n      }\n    }\n\n    return ObjectMaker.null();\n  };\n}\n\nfunction ruleValidator(configModel, entity) {\n  return control => {\n    let config = getConfigObject(configModel, control);\n\n    if (FormProvider.ProcessRule(control, config)) {\n      let result = null;\n\n      for (let rule of config.customRules) {\n        result = rule(entity);\n        if (result) break;\n      }\n\n      if (result) return result;\n    }\n\n    return ObjectMaker.null();\n  };\n}\n\nfunction fileValidator(configModel) {\n  return (control, files) => {\n    let config = getConfigObject(configModel, control);\n    if (!control[VALIDATOR_CONFIG$2] || !control[VALIDATOR_CONFIG$2][AnnotationTypes.file]) ApplicationUtil.configureControl(control, config, AnnotationTypes.file);\n\n    if (files) {\n      if (FormProvider.ProcessRule(control, config)) {\n        if (RegexValidator.isNotBlank(control.value)) {\n          let minFiles = config.minFiles ? config.minFiles : 0;\n          let maxFiles = config.maxFiles ? config.maxFiles : files.length;\n          if (!(files.length > 0 && files[0] instanceof File && files.length >= minFiles && files.length <= maxFiles)) return ObjectMaker.toJson(AnnotationTypes.file, config, [files.length, minFiles, maxFiles]);\n        }\n      }\n    }\n\n    return ObjectMaker.null();\n  };\n}\n\nfunction customValidator(configModel) {\n  return control => {\n    let config = getConfigObject(configModel, control);\n\n    if (FormProvider.ProcessRule(control, config)) {\n      const formGroupValue = ApplicationUtil.getParentObjectValue(control);\n      const parentObject = control.parent ? control.parent.value : undefined;\n      let result = null;\n\n      for (let rule of config.customRules) {\n        result = rule(formGroupValue, parentObject, config.additionalValue);\n        if (result) break;\n      }\n\n      if (result) return result;\n    }\n\n    return ObjectMaker.null();\n  };\n}\n\nfunction uniqueValidator(configModel) {\n  var setTimeoutFunc = (invalidateControls, controlValues) => {\n    let timeOut = setTimeout(() => {\n      invalidateControls.forEach(t => {\n        let isMatched = controlValues.filter(x => x == t.value)[0];\n        if (!isMatched) t.updateValueAndValidity();\n      });\n      clearTimeout(timeOut);\n    }, 200);\n  };\n\n  var additionalValidation = (config, fieldName, formGroup, formArray, currentValue) => {\n    let indexOf = formArray.controls.indexOf(formGroup);\n    let formArrayValue = [];\n\n    if (indexOf != -1) {\n      formArray.value.forEach((t, i) => {\n        if (indexOf != i) formArrayValue.push(t);\n      });\n      return config.additionalValidation(currentValue, indexOf, fieldName, formGroup.value, formArrayValue);\n    }\n\n    return false;\n  };\n\n  return control => {\n    let config = getConfigObject(configModel, control);\n\n    if (FormProvider.ProcessRule(control, config)) {\n      if (RegexValidator.isNotBlank(control.value)) {\n        let formArray = ApplicationUtil.getParentFormArray(control);\n        let parentFormGroup = control.parent ? control.parent : undefined;\n        let invalidateControls = [];\n        let controlValues = [];\n\n        if (formArray && parentFormGroup) {\n          let currentValue = control.value;\n          let fieldName = ApplicationUtil.getFormControlName(control);\n          let isMatched = false;\n\n          for (let formGroup of formArray.controls) {\n            if (formGroup != parentFormGroup) {\n              isMatched = ApplicationUtil.toLower(formGroup.controls[fieldName].value) == ApplicationUtil.toLower(currentValue) && !(formGroup.controls[fieldName].errors && formGroup.controls[fieldName].errors[AnnotationTypes.unique]);\n\n              if (formGroup.controls[fieldName].errors && formGroup.controls[fieldName].errors[AnnotationTypes.unique]) {\n                var matchedControl = formArray.controls.filter(t => t.controls[fieldName] != formGroup.controls[fieldName] && ApplicationUtil.toLower(t.controls[fieldName].value) == ApplicationUtil.toLower(formGroup.controls[fieldName].value))[0];\n                if (!matchedControl) invalidateControls.push(formGroup.controls[fieldName]);\n              } else controlValues.push(formGroup.controls[fieldName].value);\n            }\n\n            if (isMatched) break;\n          }\n\n          if (invalidateControls.length > 0) setTimeoutFunc(invalidateControls, controlValues);\n          let validation = false;\n\n          if (config.additionalValidation) {\n            validation = additionalValidation(config, fieldName, parentFormGroup, formArray, currentValue);\n          }\n\n          if (isMatched && !validation) return ObjectMaker.toJson(AnnotationTypes.unique, config, [control.value]);\n        }\n      }\n    }\n\n    return ObjectMaker.null();\n  };\n}\n\nfunction imageValidator(configModel) {\n  return (control, files) => {\n    let config = getConfigObject(configModel, control);\n    if (!control[VALIDATOR_CONFIG$2] || !control[VALIDATOR_CONFIG$2][AnnotationTypes.image]) ApplicationUtil.configureControl(control, config, AnnotationTypes.image);\n    if (!files) return ObjectMaker.null();\n    return new Promise((resolve, reject) => {\n      if (FormProvider.ProcessRule(control, config)) {\n        if (RegexValidator.isNotBlank(control.value)) {\n          let testResult = false;\n\n          for (var i = 0; i < files.length; i++) {\n            let file = files.item(i);\n            let type = file.type ? file.type.split('/') : [];\n            testResult = type.length > 1 && type[0] == \"image\";\n            if (!testResult) break;\n            let image = new Image();\n            config.minWidth = config.minWidth ? config.minWidth : 0;\n            config.minHeight = config.minHeight ? config.minHeight : 0;\n\n            image.onload = () => {\n              testResult = image.width >= config.minWidth && image.height >= config.minHeight && image.width <= config.maxWidth && image.height <= config.maxHeight;\n              if (!testResult) resolve(ObjectMaker.toJson(AnnotationTypes.image, config, [image.width, image.height]));else resolve(ObjectMaker.null());\n            };\n\n            image.onerror = () => {\n              resolve(ObjectMaker.toJson(AnnotationTypes.image, config, []));\n            };\n\n            image.src = URL.createObjectURL(file);\n          }\n\n          if (!testResult) resolve(ObjectMaker.toJson(AnnotationTypes.image, config, []));\n        }\n      }\n\n      return ObjectMaker.null();\n    });\n  };\n}\n\nfunction notEmptyValidator(configModel) {\n  return control => {\n    let config = getConfigObject(configModel, control);\n\n    if (FormProvider.ProcessRule(control, config)) {\n      if (!RegexValidator.isNotBlank(control.value, true)) {\n        return ObjectMaker.toJson(AnnotationTypes.notEmpty, config, []);\n      }\n    }\n\n    return ObjectMaker.null();\n  };\n}\n\nfunction checkIpV4(value) {\n  let isValid = RegexValidator.isValid(value, RegExRule.ipV4);\n\n  if (isValid) {\n    const splitDots = value.split('.');\n\n    for (let ipNum of splitDots) {\n      isValid = ipNum <= 255;\n      if (!isValid) break;\n    }\n  }\n\n  return isValid;\n}\n\nfunction checkIpV6(value) {\n  return RegexValidator.isValid(value, RegExRule.ipV6);\n}\n\nfunction ipValidator(configModel) {\n  return control => {\n    let config = getConfigObject(configModel, control, IP_CONFIG);\n\n    if (ValidatorValueChecker.pass(control, config)) {\n      let values = config.isCidr ? control.value.split('/') : [control.value];\n      var isValid = config.version == IpVersion.V4 ? checkIpV4(values[0]) : config.version == IpVersion.V6 ? checkIpV6(values[0]) : checkIpV4(values[0]) || checkIpV6(values[0]);\n\n      if (config.isCidr && isValid) {\n        isValid = values.length > 1 ? config.version == IpVersion.V4 ? RegexValidator.isValid(values[1], RegExRule.cidrV4) : config.version == IpVersion.V6 ? RegexValidator.isValid(values[1], RegExRule.cidrV6) : RegexValidator.isValid(values[1], RegExRule.cidrV4) || RegexValidator.isValid(values[1], RegExRule.cidrV6) : false;\n      }\n\n      if (!isValid) return ObjectMaker.toJson(AnnotationTypes.ip, config, [control.value]);\n    }\n\n    return ObjectMaker.null();\n  };\n}\n\nfunction cusipValidator(configModel) {\n  return control => {\n    let config = getConfigObject(configModel, control);\n\n    if (ValidatorValueChecker.pass(control, config)) {\n      var controlValue = control.value.toUpperCase();\n      let isValid = RegexValidator.isValid(controlValue, RegExRule.cusip);\n\n      if (isValid) {\n        let numericValues = controlValue.split(\"\").map(value => {\n          var charCode = value.charCodeAt(0);\n          return charCode >= \"A\".charCodeAt(0) && charCode <= \"Z\".charCodeAt(0) ? charCode - \"A\".charCodeAt(0) + 10 : value;\n        });\n        let totalCount = 0;\n\n        for (var i = 0; i < numericValues.length - 1; i++) {\n          var numericValue = parseInt(numericValues[i], 10);\n\n          if (i % 2 !== 0) {\n            numericValue *= 2;\n          }\n\n          if (numericValue > 9) {\n            numericValue -= 9;\n          }\n\n          totalCount += numericValue;\n        }\n\n        totalCount = (10 - totalCount % 10) % 10;\n        isValid = totalCount == numericValues[numericValues.length - 1];\n      }\n\n      if (!isValid) return ObjectMaker.toJson(AnnotationTypes.cusip, config, [control.value]);\n    }\n\n    return ObjectMaker.null();\n  };\n}\n\nfunction gridValidator(configModel) {\n  return control => {\n    let config = getConfigObject(configModel, control);\n\n    if (ValidatorValueChecker.pass(control, config)) {\n      let controlValue = control.value.toUpperCase();\n      var isValid = RegexValidator.isValid(controlValue, RegExRule.grid);\n\n      if (isValid) {\n        controlValue = controlValue.replace(/\\s/g, '').replace(/-/g, '');\n\n        if ('GRID:' === controlValue.substr(0, 5)) {\n          controlValue = controlValue.substr(5);\n        }\n\n        let alphaNums = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n        var alphaNumLength = alphaNums.length,\n            length = controlValue.length,\n            check = Math.floor(alphaNumLength / 2);\n\n        for (var i = 0; i < length; i++) {\n          check = ((check || alphaNumLength) * 2 % (alphaNumLength + 1) + alphaNums.indexOf(controlValue.charAt(i))) % alphaNumLength;\n        }\n\n        isValid = check === 1;\n      }\n\n      if (!isValid) return ObjectMaker.toJson(AnnotationTypes.grid, config, [control.value]);\n    }\n\n    return ObjectMaker.null();\n  };\n}\n\nfunction dateValidator(configModel) {\n  return control => {\n    return validateDate(control, configModel, AnnotationTypes.date);\n  };\n}\n\nfunction runCondition(leftValue, rightValue, operator) {\n  let result = false;\n\n  switch (operator) {\n    case OPERATORS.lessThan:\n    case OPERATORS.greaterThan:\n      result = leftValue > rightValue;\n      break;\n\n    case OPERATORS.lessThanEqualTo:\n    case OPERATORS.greaterThanEqualTo:\n      result = leftValue >= rightValue;\n      break;\n  }\n\n  return result;\n}\n\nfunction isValid(control, config) {\n  return config.allowSeconds ? RegexValidator.isValid(control.value, RegExRule.timeWithSeconds) : RegexValidator.isValid(control.value, RegExRule.time);\n}\n\nfunction getTime(value) {\n  let splitTime = value ? value.split(':') : [];\n  return new Date(1970, 0, 1, splitTime[0] ? splitTime[0] : 0, splitTime[1] ? splitTime[1] : 0, splitTime[2] ? splitTime[2] : 0).getTime();\n}\n\nfunction timeChecker(control, config, operationType) {\n  config = getConfigObject(config, control);\n\n  if (FormProvider.ProcessRule(control, config)) {\n    if (RegexValidator.isNotBlank(control.value)) {\n      if (isValid(control, config)) {\n        let crossFormControl = config.fieldName ? ApplicationUtil.getFormControl(config.fieldName, control) : undefined;\n        let crossControlValue = crossFormControl ? getTime(crossFormControl.value) : getTime(config.value);\n        let currentControlValue = getTime(control.value);\n        let isValid = operationType == AnnotationTypes.minTime ? runCondition(currentControlValue, crossControlValue, config.operator || OPERATORS.greaterThanEqualTo) : runCondition(crossControlValue, currentControlValue, config.operator || OPERATORS.lessThanEqualTo);\n        if (!isValid) return ObjectMaker.toJson(operationType, config, [control.value]);\n      } else return ObjectMaker.toJson(operationType, config, [control.value]);\n    }\n  }\n\n  return ObjectMaker.null();\n}\n\nfunction minTimeValidator(configModel) {\n  return control => {\n    return timeChecker(control, configModel, AnnotationTypes.minTime);\n  };\n}\n\nfunction maxTimeValidator(configModel) {\n  return control => {\n    return timeChecker(control, configModel, AnnotationTypes.maxTime);\n  };\n}\n\nfunction requiredTrueValidator(configModel) {\n  return control => {\n    let config = getConfigObject(configModel, control);\n\n    if (FormProvider.ProcessRule(control, config)) {\n      if (control.value !== true) {\n        return ObjectMaker.toJson(AnnotationTypes.requiredTrue, config, []);\n      }\n    }\n\n    return ObjectMaker.null();\n  };\n}\n\nfunction maskValidator(configModel) {\n  return control => {\n    let config = getConfigObject(configModel, control);\n    if (!control[VALIDATOR_CONFIG$2] || !control[VALIDATOR_CONFIG$2][AnnotationTypes.mask]) ApplicationUtil.configureControl(control, config, AnnotationTypes.mask);\n    return null;\n  };\n}\n\nconst IBAN_COUNTRY_CODE_REGEX = {\n  AD: /^(AD[0-9]{2})\\d{8}[A-Z0-9]{12}$/,\n  AE: /^(AE[0-9]{2})\\d{3}\\d{16}$/,\n  AL: /^(AL[0-9]{2})\\d{8}[A-Z0-9]{16}$/,\n  AT: /^(AT[0-9]{2})\\d{16}$/,\n  AZ: /^(AZ[0-9]{2})[A-Z0-9]{4}\\d{20}$/,\n  BA: /^(BA[0-9]{2})\\d{16}$/,\n  BE: /^(BE[0-9]{2})\\d{12}$/,\n  BG: /^(BG[0-9]{2})[A-Z]{4}\\d{6}[A-Z0-9]{8}$/,\n  BH: /^(BH[0-9]{2})[A-Z]{4}[A-Z0-9]{14}$/,\n  BR: /^(BR[0-9]{2})\\d{23}[A-Z]{1}[A-Z0-9]{1}$/,\n  BY: /^(BY[0-9]{2})[A-Z0-9]{4}\\d{20}$/,\n  CH: /^(CH[0-9]{2})\\d{5}[A-Z0-9]{12}$/,\n  CR: /^(CR[0-9]{2})\\d{18}$/,\n  CY: /^(CY[0-9]{2})\\d{8}[A-Z0-9]{16}$/,\n  CZ: /^(CZ[0-9]{2})\\d{20}$/,\n  DE: /^(DE[0-9]{2})\\d{18}$/,\n  DK: /^(DK[0-9]{2})\\d{14}$/,\n  DO: /^(DO[0-9]{2})[A-Z]{4}\\d{20}$/,\n  EE: /^(EE[0-9]{2})\\d{16}$/,\n  EG: /^(EG[0-9]{2})\\d{25}$/,\n  ES: /^(ES[0-9]{2})\\d{20}$/,\n  FI: /^(FI[0-9]{2})\\d{14}$/,\n  FO: /^(FO[0-9]{2})\\d{14}$/,\n  FR: /^(FR[0-9]{2})\\d{10}[A-Z0-9]{11}\\d{2}$/,\n  GB: /^(GB[0-9]{2})[A-Z]{4}\\d{14}$/,\n  GE: /^(GE[0-9]{2})[A-Z0-9]{2}\\d{16}$/,\n  GI: /^(GI[0-9]{2})[A-Z]{4}[A-Z0-9]{15}$/,\n  GL: /^(GL[0-9]{2})\\d{14}$/,\n  GR: /^(GR[0-9]{2})\\d{7}[A-Z0-9]{16}$/,\n  GT: /^(GT[0-9]{2})[A-Z0-9]{4}[A-Z0-9]{20}$/,\n  HR: /^(HR[0-9]{2})\\d{17}$/,\n  HU: /^(HU[0-9]{2})\\d{24}$/,\n  IE: /^(IE[0-9]{2})[A-Z0-9]{4}\\d{14}$/,\n  IL: /^(IL[0-9]{2})\\d{19}$/,\n  IQ: /^(IQ[0-9]{2})[A-Z]{4}\\d{15}$/,\n  IR: /^(IR[0-9]{2})0\\d{2}0\\d{18}$/,\n  IS: /^(IS[0-9]{2})\\d{22}$/,\n  IT: /^(IT[0-9]{2})[A-Z]{1}\\d{10}[A-Z0-9]{12}$/,\n  JO: /^(JO[0-9]{2})[A-Z]{4}\\d{22}$/,\n  KW: /^(KW[0-9]{2})[A-Z]{4}[A-Z0-9]{22}$/,\n  KZ: /^(KZ[0-9]{2})\\d{3}[A-Z0-9]{13}$/,\n  LB: /^(LB[0-9]{2})\\d{4}[A-Z0-9]{20}$/,\n  LC: /^(LC[0-9]{2})[A-Z]{4}[A-Z0-9]{24}$/,\n  LI: /^(LI[0-9]{2})\\d{5}[A-Z0-9]{12}$/,\n  LT: /^(LT[0-9]{2})\\d{16}$/,\n  LU: /^(LU[0-9]{2})\\d{3}[A-Z0-9]{13}$/,\n  LV: /^(LV[0-9]{2})[A-Z]{4}[A-Z0-9]{13}$/,\n  MC: /^(MC[0-9]{2})\\d{10}[A-Z0-9]{11}\\d{2}$/,\n  MD: /^(MD[0-9]{2})[A-Z0-9]{20}$/,\n  ME: /^(ME[0-9]{2})\\d{18}$/,\n  MK: /^(MK[0-9]{2})\\d{3}[A-Z0-9]{10}\\d{2}$/,\n  MR: /^(MR[0-9]{2})\\d{23}$/,\n  MT: /^(MT[0-9]{2})[A-Z]{4}\\d{5}[A-Z0-9]{18}$/,\n  MU: /^(MU[0-9]{2})[A-Z]{4}\\d{19}[A-Z]{3}$/,\n  NL: /^(NL[0-9]{2})[A-Z]{4}\\d{10}$/,\n  NO: /^(NO[0-9]{2})\\d{11}$/,\n  PK: /^(PK[0-9]{2})[A-Z0-9]{4}\\d{16}$/,\n  PL: /^(PL[0-9]{2})\\d{24}$/,\n  PS: /^(PS[0-9]{2})[A-Z0-9]{4}\\d{21}$/,\n  PT: /^(PT[0-9]{2})\\d{21}$/,\n  QA: /^(QA[0-9]{2})[A-Z]{4}[A-Z0-9]{21}$/,\n  RO: /^(RO[0-9]{2})[A-Z]{4}[A-Z0-9]{16}$/,\n  RS: /^(RS[0-9]{2})\\d{18}$/,\n  SA: /^(SA[0-9]{2})\\d{2}[A-Z0-9]{18}$/,\n  SC: /^(SC[0-9]{2})[A-Z]{4}\\d{20}[A-Z]{3}$/,\n  SE: /^(SE[0-9]{2})\\d{20}$/,\n  SI: /^(SI[0-9]{2})\\d{15}$/,\n  SK: /^(SK[0-9]{2})\\d{20}$/,\n  SM: /^(SM[0-9]{2})[A-Z]{1}\\d{10}[A-Z0-9]{12}$/,\n  SV: /^(SV[0-9]{2})[A-Z0-9]{4}\\d{20}$/,\n  TL: /^(TL[0-9]{2})\\d{19}$/,\n  TN: /^(TN[0-9]{2})\\d{20}$/,\n  TR: /^(TR[0-9]{2})\\d{5}[A-Z0-9]{17}$/,\n  UA: /^(UA[0-9]{2})\\d{6}[A-Z0-9]{19}$/,\n  VA: /^(VA[0-9]{2})\\d{18}$/,\n  VG: /^(VG[0-9]{2})[A-Z0-9]{4}\\d{16}$/,\n  XK: /^(XK[0-9]{2})\\d{16}$/\n};\n\nfunction hasValidIbanFormat(value, countryCode) {\n  const strippedStr = value.replace(/[\\s\\-]+/gi, '').toUpperCase();\n  const isoCountryCode = countryCode || strippedStr.slice(0, 2).toUpperCase();\n  return isoCountryCode in IBAN_COUNTRY_CODE_REGEX && IBAN_COUNTRY_CODE_REGEX[isoCountryCode].test(strippedStr);\n}\n\nfunction hasValidIbanChecksum(str) {\n  const strippedStr = str.replace(/[^A-Z0-9]+/gi, '').toUpperCase(); // Keep only digits and A-Z latin alphabetic\n\n  const rearranged = strippedStr.slice(4) + strippedStr.slice(0, 4);\n  const alphaCapsReplacedWithDigits = rearranged.replace(/[A-Z]/g, char => char.charCodeAt(0) - 55);\n  const remainder = alphaCapsReplacedWithDigits.match(/\\d{1,7}/g).reduce((acc, value) => Number(acc + value) % 97, '');\n  return remainder === 1;\n}\n\nfunction ibanValidator(configModel) {\n  return control => {\n    let config = getConfigObject(configModel, control);\n\n    if (ValidatorValueChecker.pass(control, config)) {\n      if (!(hasValidIbanFormat(control.value, config.countryCode) && hasValidIbanChecksum(control.value))) return ObjectMaker.toJson(AnnotationTypes.iban, config, [control.value, config.countryCode]);\n    }\n\n    return ObjectMaker.null();\n  };\n}\n\nconst APP_VALIDATORS = {\n  \"alphaNumeric\": alphaNumericValidator,\n  \"alpha\": alphaValidator,\n  \"compare\": compareValidator,\n  \"email\": emailValidator,\n  \"hexColor\": hexColorValidator,\n  \"lowerCase\": lowercaseValidator,\n  \"maxDate\": maxDateValidator,\n  \"maxNumber\": maxNumberValidator,\n  \"minDate\": minDateValidator,\n  \"minNumber\": minNumberValidator,\n  \"contains\": containsValidator,\n  \"upperCase\": uppercaseValidator,\n  \"maxLength\": maxLengthValidator,\n  \"minLength\": minLengthValidator,\n  \"password\": passwordValidator,\n  \"range\": rangeValidator,\n  \"required\": requiredValidator,\n  \"creditCard\": creditCardValidator,\n  \"digit\": digitValidator,\n  \"pattern\": patternValidator,\n  \"time\": timeValidator,\n  \"url\": urlValidator,\n  \"json\": jsonValidator,\n  \"greaterThan\": greaterThanValidator,\n  \"greaterThanEqualTo\": greaterThanEqualToValidator,\n  \"lessThan\": lessThanValidator,\n  \"lessThanEqualTo\": lessThanEqualToValidator,\n  \"choice\": choiceValidator,\n  \"different\": differentValidator,\n  \"numeric\": numericValidator,\n  \"even\": evenValidator,\n  \"odd\": oddValidator,\n  \"factor\": factorValidator,\n  \"leapYear\": leapYearValidator,\n  \"allOf\": allOfValidator,\n  \"oneOf\": oneOfValidator,\n  \"noneOf\": noneOfValidator,\n  \"mac\": macValidator,\n  \"ascii\": asciiValidator,\n  \"dataUri\": dataUriValidator,\n  \"port\": portValidator,\n  \"latLong\": latLongValidator,\n  \"extension\": extensionValidator,\n  \"fileSize\": fileSizeValidator,\n  \"endsWith\": endsWithValidator,\n  \"startsWith\": startsWithValidator,\n  \"primeNumber\": primeNumberValidator,\n  \"latitude\": latitudeValidator,\n  \"longitude\": longitudeValidator,\n  \"compose\": composeValidator,\n  \"rule\": ruleValidator,\n  \"file\": fileValidator,\n  \"unique\": uniqueValidator,\n  \"image\": imageValidator,\n  \"notEmpty\": notEmptyValidator,\n  \"ip\": ipValidator,\n  \"cusip\": cusipValidator,\n  \"grid\": gridValidator,\n  \"date\": dateValidator,\n  \"minTime\": minTimeValidator,\n  \"maxTime\": maxTimeValidator,\n  \"requiredTrue\": requiredTrueValidator,\n  \"mask\": maskValidator,\n  \"iban\": ibanValidator\n};\n\nfunction andValidator(configModel) {\n  return control => {\n    let config = getConfigObject(configModel, control);\n\n    if (ValidatorValueChecker.pass(control, config)) {\n      let validatorNames = Object.keys(config.validation);\n      let failed = false;\n\n      for (var validatorName of validatorNames) {\n        failed = typeof config.validation[validatorName] == \"boolean\" ? APP_VALIDATORS[validatorName]()(control) : APP_VALIDATORS[validatorName](config.validation[validatorName])(control);\n        if (failed) break;\n      }\n\n      if (failed) return ObjectMaker.toJson(AnnotationTypes.and, config, [control.value]);\n    }\n\n    return ObjectMaker.null();\n  };\n}\n\nfunction orValidator(configModel) {\n  return control => {\n    let config = getConfigObject(configModel, control);\n\n    if (ValidatorValueChecker.pass(control, config)) {\n      let validatorNames = Object.keys(config.validation);\n      let failed = false;\n\n      for (var validatorName of validatorNames) {\n        failed = typeof config.validation[validatorName] == \"boolean\" ? APP_VALIDATORS[validatorName]()(control) : APP_VALIDATORS[validatorName](config.validation[validatorName])(control);\n        if (!failed) break;\n      }\n\n      if (failed) return ObjectMaker.toJson(AnnotationTypes.or, config, [control.value]);\n    }\n\n    return ObjectMaker.null();\n  };\n}\n\nfunction notValidator(configModel) {\n  return control => {\n    let config = getConfigObject(configModel, control);\n\n    if (ValidatorValueChecker.pass(control, config)) {\n      let validatorNames = Object.keys(config.validation);\n      let failed = false;\n\n      for (var validatorName of validatorNames) {\n        failed = typeof config.validation[validatorName] == \"boolean\" ? APP_VALIDATORS[validatorName]()(control) : APP_VALIDATORS[validatorName](config.validation[validatorName])(control);\n        if (!failed) break;\n      }\n\n      if (!failed) return ObjectMaker.toJson(AnnotationTypes.not, config, [control.value]);\n    }\n\n    return ObjectMaker.null();\n  };\n}\n\nconst LOGICAL_VALIDATORS = {\n  and: andValidator,\n  or: orValidator,\n  not: notValidator\n};\nconst ASYNC = \"async\";\nconst ENTITY_OBJECT = \"entityObject\";\nlet RxFormBuilder = /*#__PURE__*/(() => {\n  class RxFormBuilder extends BaseFormBuilder {\n    constructor() {\n      super();\n      this.conditionalObjectProps = [];\n      this.conditionalValidationInstance = {};\n      this.builderConfigurationConditionalObjectProps = [];\n      this.formGroupPropOtherValidator = {};\n      this.currentFormGroupPropOtherValidator = {};\n      this.isNested = false;\n      this.isGroupCalled = false;\n      this.isNestedBinding = false;\n    }\n\n    getInstanceContainer(instanceFunc, entityObject) {\n      return this.instaceProvider(instanceFunc, entityObject);\n    }\n\n    setValue(formGroup, object) {\n      for (var col in object) {\n        var control = formGroup.get([col]);\n        control.setValue(object[col]);\n        control.updateValueAndValidity();\n      }\n    }\n\n    extractExpressions(fomrBuilderConfiguration) {\n      if (fomrBuilderConfiguration && fomrBuilderConfiguration.dynamicValidation) {\n        for (var property in fomrBuilderConfiguration.dynamicValidation) {\n          for (var decorator in fomrBuilderConfiguration.dynamicValidation[property]) {\n            if (fomrBuilderConfiguration.dynamicValidation[property][decorator].conditionalExpression) {\n              let columns = Linq.expressionColumns(fomrBuilderConfiguration.dynamicValidation[property][decorator].conditionalExpression);\n              defaultContainer.addChangeValidation(this.conditionalValidationInstance, property, columns);\n            }\n          }\n        }\n      }\n\n      return null;\n    }\n\n    addAsyncValidation(property, propertyValidators, propValidationConfig) {\n      let asyncValidators = [];\n\n      if (propertyValidators) {\n        for (let propertyValidator of propertyValidators) {\n          if (propertyValidator.isAsync) propertyValidator.config.forEach(t => {\n            asyncValidators.push(t);\n          });\n        }\n      }\n\n      if (propValidationConfig && propValidationConfig[ASYNC]) {\n        propValidationConfig[ASYNC].forEach(t => {\n          asyncValidators.push(t);\n        });\n      }\n\n      return asyncValidators;\n    }\n\n    addFormControl(property, propertyValidators, propValidationConfig, instance, entity) {\n      let validators = [];\n      let columns = [];\n\n      if (instance.conditionalValidationProps && instance.conditionalValidationProps[property.name] || this.conditionalValidationInstance.conditionalValidationProps && this.conditionalValidationInstance.conditionalValidationProps[property.name]) {\n        let props = [];\n        if (instance.conditionalValidationProps && instance.conditionalValidationProps[property.name]) instance.conditionalValidationProps[property.name].forEach(t => props.push(t));\n        if (this.conditionalValidationInstance.conditionalValidationProps && this.conditionalValidationInstance.conditionalValidationProps[property.name]) this.conditionalValidationInstance.conditionalValidationProps[property.name].forEach(t => props.push(t));\n        validators.push(conditionalChangeValidator(props));\n      }\n\n      if (this.conditionalObjectProps.length > 0 || this.builderConfigurationConditionalObjectProps.length > 0) {\n        let propConditions = [];\n        if (this.conditionalObjectProps) propConditions = this.conditionalObjectProps.filter(t => t.propName == property.name);\n        if (this.builderConfigurationConditionalObjectProps) this.builderConfigurationConditionalObjectProps.filter(t => t.propName == property.name).forEach(t => propConditions.push(t));\n        propConditions.forEach(t => {\n          if (t.referencePropName && columns.indexOf(t.referencePropName) == -1) columns.push(t.referencePropName);\n        });\n        if (columns.length > 0) validators.push(conditionalChangeValidator(columns));\n      }\n\n      for (let propertyValidator of propertyValidators) {\n        if (!propertyValidator.isAsync) {\n          let config = propertyValidator.config;\n          if (property.messageNexus) config = config ? Object.assign({\n            messageNexus: property.messageNexus\n          }, config) : {\n            messageNexus: property.messageNexus\n          };\n\n          switch (propertyValidator.annotationType) {\n            case AnnotationTypes.rule:\n              validators.push(APP_VALIDATORS[propertyValidator.annotationType](config, entity));\n              break;\n\n            case AnnotationTypes.and:\n            case AnnotationTypes.or:\n            case AnnotationTypes.not:\n              validators.push(LOGICAL_VALIDATORS[propertyValidator.annotationType](config));\n              break;\n\n            default:\n              validators.push(APP_VALIDATORS[propertyValidator.annotationType](config));\n              break;\n          }\n        }\n      }\n\n      if (propValidationConfig) this.additionalValidation(validators, propValidationConfig);\n      if (this.currentFormGroupPropOtherValidator[property.name]) this.currentFormGroupPropOtherValidator[property.name].forEach(t => {\n        validators.push(t);\n      });\n      return validators;\n    }\n\n    additionalValidation(validations, propValidationConfig) {\n      for (var col in AnnotationTypes) {\n        if (propValidationConfig[AnnotationTypes[col]] && col != \"custom\") {\n          validations.push(APP_VALIDATORS[AnnotationTypes[col]](propValidationConfig[AnnotationTypes[col]]));\n        } else if (col == AnnotationTypes.custom && propValidationConfig[AnnotationTypes[col]]) validations.push(propValidationConfig[col]);\n      }\n    }\n\n    getEntity(object, formBuilderConfiguration, propertyName, isSameObjectConstructor = false) {\n      if (formBuilderConfiguration && formBuilderConfiguration.genericEntities && formBuilderConfiguration.genericEntities[propertyName]) return formBuilderConfiguration.genericEntities[propertyName];\n      return isSameObjectConstructor ? object.constructor : undefined;\n    }\n\n    getObjectPropertyInstance(object, propertyInfo, formBuilderConfiguration) {\n      if (propertyInfo.propertyType == OBJECT_PROPERTY && object[propertyInfo.name]) return object[propertyInfo.name].constructor;else if (propertyInfo.propertyType == ARRAY_PROPERTY && object[propertyInfo.name] && object[propertyInfo.name].length > 0) return object[propertyInfo.name][0].constructor;\n      return this.getEntity(object, formBuilderConfiguration, propertyInfo.name);\n    }\n\n    checkObjectPropAdditionalValidation(instanceContainer, object, formBuilderConfiguration) {\n      var props = instanceContainer.properties.filter(t => t.propertyType == OBJECT_PROPERTY || t.propertyType == ARRAY_PROPERTY);\n      props.forEach(t => {\n        let entity = t.entity;\n        if (!t.entity) entity = this.getObjectPropertyInstance(object, t, formBuilderConfiguration);\n\n        if (entity) {\n          let instance = this.getInstanceContainer(entity, null);\n\n          if (instance && instance.conditionalValidationProps) {\n            for (var key in instance.conditionalValidationProps) {\n              var prop = instanceContainer.properties.filter(t => t.name == key)[0];\n\n              if (prop) {\n                if (!instanceContainer.conditionalValidationProps) instanceContainer.conditionalValidationProps = {};\n                if (!instanceContainer.conditionalValidationProps[key]) instanceContainer.conditionalValidationProps[key] = [];\n                instance.conditionalValidationProps[key].forEach(x => {\n                  if (t.propertyType != ARRAY_PROPERTY) instanceContainer.conditionalValidationProps[key].push([t.name, x].join('.'));else instanceContainer.conditionalValidationProps[key].push([t.name, x].join('[]'));\n                });\n              }\n            }\n          }\n        }\n      });\n    }\n\n    getObject(model, entityObject, formBuilderConfiguration) {\n      let json = {};\n      if (typeof model == FUNCTION_STRING) json.model = model;\n\n      if (typeof model == FUNCTION_STRING && entityObject instanceof FormBuilderConfiguration) {\n        json.entityObject = this.createClassObject(json.model, entityObject);\n      }\n\n      if (entityObject && !(entityObject instanceof FormBuilderConfiguration)) json.entityObject = entityObject;\n      if (entityObject instanceof FormBuilderConfiguration && !formBuilderConfiguration) json.formBuilderConfiguration = entityObject;else if (!(entityObject instanceof FormBuilderConfiguration) && formBuilderConfiguration) {\n        json.formBuilderConfiguration = formBuilderConfiguration;\n        json.entityObject = this.createClassObject(json.model, json.formBuilderConfiguration, json.entityObject);\n      }\n\n      if (!entityObject) {\n        if (typeof model == OBJECT_STRING) json.model = model.constructor;\n        json.entityObject = this.createClassObject(json.model, json.formBuilderConfiguration, model);\n      } else if (model && entityObject instanceof FormBuilderConfiguration && typeof model == OBJECT_STRING) {\n        json[MODEL] = model.constructor;\n        json[ENTITY_OBJECT] = this.createClassObject(json.model, json.formBuilderConfiguration, model);\n      }\n\n      return json;\n    }\n\n    control(value, validators, asyncValidators) {\n      return new RxFormControl(value, validators, asyncValidators, {}, {}, '', []);\n    }\n\n    array(values, validatorConfig) {\n      let formArray = this.group({\n        temp: values\n      }, validatorConfig).get(\"temp\");\n      var formBuilder = new FormBuilder();\n      return formBuilder.array(formArray.controls);\n    }\n\n    group(groupObject, validatorConfig) {\n      let modelInstance = super.createInstance();\n      let entityObject = {};\n      this.formGroupPropOtherValidator = {};\n      this.currentFormGroupPropOtherValidator = this.formGroupPropOtherValidator;\n      this.createValidatorFormGroup(groupObject, entityObject, modelInstance, validatorConfig);\n      this.currentFormGroupPropOtherValidator = this.formGroupPropOtherValidator;\n      this.isGroupCalled = true;\n      let formGroup = this.formGroup(modelInstance.constructor, entityObject, validatorConfig);\n      this.isGroupCalled = false;\n      this.formGroupPropOtherValidator = {};\n      this.currentFormGroupPropOtherValidator = this.formGroupPropOtherValidator;\n      this.formGroupPropOtherValidator = {};\n      return formGroup;\n    }\n\n    applyAllPropValidator(propName, validatorConfig, modelInstance) {\n      if (validatorConfig && validatorConfig.applyAllProps) {\n        if (!(validatorConfig.excludeProps && validatorConfig.excludeProps.length > 0 && validatorConfig.excludeProps.indexOf(propName) == -1)) {\n          validatorConfig.applyAllProps.forEach(t => {\n            if (t.name == RX_WEB_VALIDATOR) {\n              t(propName, modelInstance);\n            } else {\n              if (!this.currentFormGroupPropOtherValidator[propName]) this.currentFormGroupPropOtherValidator[propName] = [];\n              this.currentFormGroupPropOtherValidator[propName].push(t);\n            }\n          });\n        }\n      }\n    }\n\n    dynamicValidationPropCheck(propName, validatorConfig) {\n      return validatorConfig == undefined ? true : !validatorConfig.dynamicValidationConfigurationPropertyName ? true : validatorConfig.dynamicValidationConfigurationPropertyName == propName ? false : true;\n    }\n\n    isNotObject(value) {\n      return value instanceof Date || value === null || typeof value != OBJECT_STRING;\n    }\n\n    createValidatorFormGroup(groupObject, entityObject, modelInstance, validatorConfig) {\n      for (var propName in groupObject) {\n        var prop = groupObject[propName];\n\n        if (prop instanceof Array && prop.length > 0 && this.isNotObject(prop[0])) {\n          let propValidators = prop.length > 1 && prop[1] instanceof Array ? prop[1] : prop.length == 2 ? [prop[1]] : [];\n          let propertyAdded = false;\n\n          for (var i = 0; i < propValidators.length; i++) {\n            if (propValidators[i].name == RX_WEB_VALIDATOR) {\n              propValidators[i](propName, modelInstance);\n              propertyAdded = true;\n            } else {\n              if (!this.currentFormGroupPropOtherValidator[propName]) this.currentFormGroupPropOtherValidator[propName] = [];\n              this.currentFormGroupPropOtherValidator[propName].push(propValidators[i]);\n            }\n          }\n\n          if (!propertyAdded) defaultContainer.initPropertyObject(propName, PROPERTY, undefined, typeof modelInstance == OBJECT_STRING ? modelInstance : {\n            constructor: modelInstance\n          });\n          this.applyAllPropValidator(propName, validatorConfig, modelInstance);\n        } else if (prop === null || prop === undefined || typeof prop == STRING || typeof prop == NUMBER || typeof prop == BOOLEAN$1 || prop instanceof Date) {\n          defaultContainer.initPropertyObject(propName, PROPERTY, undefined, typeof modelInstance == OBJECT_STRING ? modelInstance : {\n            constructor: modelInstance\n          });\n          this.applyAllPropValidator(propName, validatorConfig, modelInstance);\n        } else if (prop instanceof Array) {\n          if (prop instanceof FormArray) {\n            entityObject[propName] = prop;\n          } else {\n            let propModelInstance = super.createInstance();\n            if (typeof modelInstance == \"function\") modelInstance.constructor = modelInstance;\n            defaultContainer.initPropertyObject(propName, ARRAY_PROPERTY, propModelInstance.constructor, modelInstance);\n            entityObject[propName] = [];\n\n            for (let row of prop) {\n              let jObject = {};\n              entityObject[propName].push(jObject);\n              this.createValidatorFormGroup(row, jObject, propModelInstance.constructor, validatorConfig);\n            }\n          }\n        } else if (typeof prop == OBJECT_STRING && !(prop instanceof FormControl || prop instanceof RxFormControl)) {\n          let formGroup = prop instanceof FormArray ? prop.controls[0] : prop;\n\n          if (!formGroup.model && (prop instanceof FormGroup || prop instanceof RxFormGroup)) {\n            formGroup = this.group(formGroup.controls);\n          }\n\n          if (prop instanceof FormGroup || prop instanceof RxFormGroup) {\n            entityObject[propName] = prop;\n            defaultContainer.initPropertyObject(propName, OBJECT_PROPERTY, formGroup.model, modelInstance);\n          } else if (prop instanceof FormArray) {\n            entityObject[propName] = prop;\n            defaultContainer.initPropertyObject(propName, ARRAY_PROPERTY, formGroup.model, modelInstance);\n          } else {\n            if (this.dynamicValidationPropCheck(propName, validatorConfig)) {\n              this.formGroupPropOtherValidator[propName] = {};\n              this.currentFormGroupPropOtherValidator = this.formGroupPropOtherValidator[propName];\n              let propModelInstance = super.createInstance();\n              entityObject[propName] = {};\n              entityObject[propName].constructor = propModelInstance.constructor;\n              defaultContainer.initPropertyObject(propName, OBJECT_PROPERTY, entityObject[propName].constructor, modelInstance.constructor == Function ? {\n                constructor: modelInstance\n              } : modelInstance);\n              let objectValidationConfig = this.getValidatorConfig(validatorConfig, groupObject, propName + \".\");\n              this.createValidatorFormGroup(groupObject[propName], entityObject[propName], entityObject[propName].constructor, objectValidationConfig);\n            } else entityObject[propName] = groupObject[propName];\n          }\n        }\n\n        if (typeof prop == STRING || typeof prop == NUMBER || typeof prop == BOOLEAN$1 || prop instanceof Date) {\n          entityObject[propName] = prop;\n        } else if (prop && prop.length > 0 && this.isNotObject(prop[0]) && !(prop instanceof FormControl || prop instanceof RxFormControl) && !(prop instanceof FormArray)) {\n          entityObject[propName] = prop[0];\n        } else if (prop instanceof FormArray) {\n          entityObject[propName] = prop;\n        } else if (prop instanceof FormControl || prop instanceof RxFormControl) {\n          entityObject[propName] = prop;\n          defaultContainer.initPropertyObject(propName, PROPERTY, undefined, modelInstance.constructor ? modelInstance : {\n            constructor: modelInstance\n          });\n        }\n      }\n    }\n\n    getValidatorConfig(validatorConfig, entityObject, rootPropertyName, arrayPropertyName) {\n      let excludeProps = [];\n      let includeProps = [];\n      let ignoreUndefinedProps = [];\n      if (!validatorConfig) return {};\n      const validationProps = this.getObjectForProperty(validatorConfig.dynamicValidation, rootPropertyName, arrayPropertyName);\n      const abstractControlOptions = this.getObjectForProperty(validatorConfig.abstractControlOptions, rootPropertyName, arrayPropertyName);\n      if (validatorConfig.excludeProps) excludeProps = this.getProps(validatorConfig.excludeProps, rootPropertyName);\n      if (validatorConfig.includeProps) includeProps = this.getProps(validatorConfig.includeProps, rootPropertyName);\n      if (validatorConfig.ignoreUndefinedProps) ignoreUndefinedProps = this.getProps(validatorConfig.ignoreUndefinedProps, rootPropertyName, true);\n      if (!Object.keys(abstractControlOptions).length && rootPropertyName.endsWith('.') && validatorConfig.abstractControlOptions && validatorConfig.abstractControlOptions[rootPropertyName.substring(0, rootPropertyName.length - 1)]) abstractControlOptions['global'] = validatorConfig.abstractControlOptions[rootPropertyName.substring(0, rootPropertyName.length - 1)];\n      const dynamicValidation = validatorConfig.dynamicValidationConfigurationPropertyName && entityObject[validatorConfig.dynamicValidationConfigurationPropertyName] ? entityObject[validatorConfig.dynamicValidationConfigurationPropertyName] : validationProps;\n      return {\n        ignoreUndefinedProps: ignoreUndefinedProps,\n        includeProps: includeProps,\n        dynamicValidation: dynamicValidation,\n        excludeProps: excludeProps,\n        abstractControlOptions: abstractControlOptions\n      };\n    }\n\n    getObjectForProperty(rootObject, rootPropertyName, arrayPropertyName) {\n      const result = {};\n\n      for (let propName in rootObject) {\n        if (!propName.startsWith(rootPropertyName) && (!arrayPropertyName || !propName.startsWith(arrayPropertyName))) continue;\n        let splitProp = propName.split(\".\", 2)[1];\n        if (!splitProp) continue;\n        result[splitProp] = rootObject[propName];\n      }\n\n      return result;\n    }\n\n    getProps(properties, rootPropertyName, isIgnoreProp = false) {\n      let props = [];\n\n      for (let prop of properties) {\n        if (prop.indexOf(rootPropertyName) != -1) {\n          let splitProps = prop.split(\".\");\n\n          if (splitProps.length == 2) {\n            props.push(splitProps[1]);\n          } else if (splitProps.length > 2) {\n            splitProps.splice(0, 1);\n            props.push(splitProps.join(\".\"));\n          }\n        }\n      }\n\n      if (isIgnoreProp && properties.filter(x => x == rootPropertyName.replace('.', '')).length == 1) props.push(':self:');\n      return props;\n    }\n\n    formGroup(model, entityObject, formBuilderConfiguration) {\n      let json = this.getObject(model, entityObject, formBuilderConfiguration);\n      model = json.model;\n      entityObject = json.entityObject;\n\n      if (entityObject.constructor != model && !this.isGroupCalled) {\n        entityObject = json.entityObject = this.updateObject(model, json.entityObject, formBuilderConfiguration);\n      }\n\n      formBuilderConfiguration = json.formBuilderConfiguration;\n      if (formBuilderConfiguration) this.extractExpressions(formBuilderConfiguration);\n      let instanceContainer = this.getInstanceContainer(model, entityObject);\n      this.checkObjectPropAdditionalValidation(instanceContainer, entityObject, formBuilderConfiguration);\n      let formGroupObject = {};\n      let extendedProperties = {};\n      let formChildGroup = undefined;\n      let formArrayGroup = undefined;\n      var additionalValidations = {};\n      instanceContainer.properties.forEach(property => {\n        let isIncludeProp = true;\n\n        if (formBuilderConfiguration) {\n          if (formBuilderConfiguration.excludeProps && formBuilderConfiguration.excludeProps.length > 0) isIncludeProp = formBuilderConfiguration.excludeProps.indexOf(property.name) == -1;\n          if (formBuilderConfiguration.dynamicValidation) additionalValidations = formBuilderConfiguration.dynamicValidation;\n          if (formBuilderConfiguration.includeProps && formBuilderConfiguration.includeProps.length > 0) isIncludeProp = formBuilderConfiguration.includeProps.indexOf(property.name) != -1;\n\n          if (formBuilderConfiguration.ignoreUndefinedProps && formBuilderConfiguration.ignoreUndefinedProps.length > 0) {\n            isIncludeProp = !(property.propertyType == PROPERTY && !RegexValidator.isNotBlank(json.entityObject[property.name]) && (formBuilderConfiguration.ignoreUndefinedProps.indexOf(property.name) !== -1 || formBuilderConfiguration.ignoreUndefinedProps.indexOf(\":self:\") !== -1));\n          }\n        }\n\n        if (property.ignore) isIncludeProp = !property.ignore.call(json.entityObject, json.entityObject);\n\n        if (isIncludeProp) {\n          switch (property.propertyType) {\n            case PROPERTY:\n              if (!(entityObject[property.name] instanceof FormControl || entityObject[property.name] instanceof RxFormControl)) {\n                let propertyValidators = instanceContainer.propertyAnnotations.filter(t => t.propertyName == property.name && t.isValidator);\n                let updateOn = instanceContainer.propertyAnnotations.filter(t => t.propertyName == property.name && !t.isValidator && t.annotationType === \"updateOn\")[0];\n                let sanitizeValue = super.sanitizeValue(instanceContainer, property.name, super.getDefaultValue(property, entityObject[property.name], formBuilderConfiguration), json.entityObject, Object.assign({}, json.entityObject));\n                if (entityObject[property.name] === undefined && sanitizeValue) entityObject[property.name] = sanitizeValue;\n                let validators = this.addFormControl(property, propertyValidators, additionalValidations[property.name], instanceContainer, entityObject);\n                let abstractControlOptions = {\n                  validators: validators,\n                  asyncValidators: this.addAsyncValidation(property, propertyValidators, additionalValidations[property.name])\n                };\n                abstractControlOptions = this.getAbstractControlOptions(property.name, formBuilderConfiguration, abstractControlOptions);\n                if (updateOn && !abstractControlOptions.updateOn) abstractControlOptions.updateOn = updateOn.config.runOn;\n                formGroupObject[property.name] = new RxFormControl(sanitizeValue, abstractControlOptions, [], json.entityObject, Object.assign({}, json.entityObject), property.name, instanceContainer.sanitizers[property.name]);\n                this.isNested = false;\n              } else formGroupObject[property.name] = super.getDefaultValue(property, entityObject[property.name], formBuilderConfiguration);\n\n              extendedProperties[property.name] = true;\n              break;\n\n            case OBJECT_PROPERTY:\n              let objectValue = entityObject[property.name];\n              objectValue = !objectValue && property.defaultValue ? property.defaultValue : objectValue;\n              if (!objectValue && property.objectConfig && property.objectConfig.autoCreate) objectValue = this.createClassObject(property.entity, {});\n\n              if (objectValue && objectValue instanceof Object && !(objectValue instanceof FormGroup || objectValue instanceof RxFormGroup)) {\n                this.isNestedBinding = this.isNested = true;\n                if (instanceContainer && instanceContainer.conditionalObjectProps) this.conditionalObjectProps = instanceContainer.conditionalObjectProps.filter(t => t.objectPropName == property.name);\n                if (this.conditionalValidationInstance && this.conditionalValidationInstance.conditionalObjectProps) this.builderConfigurationConditionalObjectProps = this.conditionalValidationInstance.conditionalObjectProps.filter(t => t.objectPropName == property.name);\n                if (this.formGroupPropOtherValidator[property.name]) this.currentFormGroupPropOtherValidator = this.formGroupPropOtherValidator[property.name];\n                let objectValidationConfig = this.getValidatorConfig(formBuilderConfiguration, objectValue, `${property.name}.`);\n                let entity = property.entityProvider ? property.entityProvider.call(entityObject) : undefined;\n                formGroupObject[property.name] = this.formGroup(entity || property.entity || this.getEntity(objectValue, formBuilderConfiguration, property.name, true), objectValue, objectValidationConfig);\n                this.conditionalObjectProps = [];\n                this.builderConfigurationConditionalObjectProps = [];\n                this.isNestedBinding = this.isNested = false;\n              } else if (objectValue instanceof FormGroup || objectValue instanceof RxFormGroup) formGroupObject[property.name] = objectValue;\n\n              break;\n\n            case ARRAY_PROPERTY:\n              let arrayObjectValue = entityObject[property.name];\n\n              if (arrayObjectValue && arrayObjectValue instanceof Array && !(arrayObjectValue instanceof FormArray)) {\n                this.isNestedBinding = this.isNested = true;\n                var formArrayGroup = [];\n                let index = 0;\n                let entity = property.entityProvider ? property.entityProvider.call(entityObject) : undefined;\n                let objectValidationConfig = null;\n\n                for (let subObject of arrayObjectValue) {\n                  if (instanceContainer && instanceContainer.conditionalObjectProps) this.conditionalObjectProps = instanceContainer.conditionalObjectProps.filter(t => t.objectPropName == property.name && t.arrayIndex == index);\n                  if (this.conditionalValidationInstance && this.conditionalValidationInstance.conditionalObjectProps) this.builderConfigurationConditionalObjectProps = this.conditionalValidationInstance.conditionalObjectProps.filter(t => t.objectPropName == property.name && t.arrayIndex == index);\n                  if (this.formGroupPropOtherValidator[property.name]) this.currentFormGroupPropOtherValidator = this.formGroupPropOtherValidator[property.name];\n                  objectValidationConfig = this.getValidatorConfig(formBuilderConfiguration, subObject, `${property.name}.`, `${property.name}[${index}].`);\n                  formArrayGroup.push(this.formGroup(entity || property.entity || this.getEntity(subObject, formBuilderConfiguration, property.name, true), subObject, objectValidationConfig));\n                  index++;\n                  this.conditionalObjectProps = [];\n                  this.builderConfigurationConditionalObjectProps = [];\n                }\n\n                let abstractControlOptions = this.getAbstractControlOptions(property.name, formBuilderConfiguration, {});\n                formGroupObject[property.name] = new RxFormArray(arrayObjectValue, formArrayGroup, abstractControlOptions, null, property.arrayConfig);\n\n                if (ReactiveFormConfig.autoInstancePush) {\n                  arrayObjectValue.push = instance => {\n                    let formGroup = this.formGroup(instance.constructor, instance, objectValidationConfig);\n                    formGroupObject[property.name].push(formGroup, {\n                      isAddedInstance: true\n                    });\n                    return 0;\n                  };\n\n                  arrayObjectValue.splice = (start, deleteCount) => {\n                    let end = start + deleteCount - 1;\n\n                    for (var i = start; i <= end; i++) {\n                      formGroupObject[property.name].removeAt(i, {\n                        isRemovedInstance: true\n                      });\n                    }\n\n                    return [];\n                  };\n                }\n\n                this.isNestedBinding = this.isNested = false;\n              } else if (arrayObjectValue instanceof FormArray) formGroupObject[property.name] = arrayObjectValue;else if (property.arrayConfig && property.arrayConfig.createBlank) formGroupObject[property.name] = new RxFormArray([], [], null, null, property.arrayConfig);\n\n              break;\n          }\n        }\n      });\n\n      if (!this.isNested) {\n        this.conditionalValidationInstance = {};\n        this.builderConfigurationConditionalObjectProps = [];\n      }\n\n      let abstractControlOptions = {\n        validators: [],\n        asyncValidators: [],\n        updateOn: formBuilderConfiguration && formBuilderConfiguration.abstractControlOptions && formBuilderConfiguration.abstractControlOptions['global'] ? formBuilderConfiguration.abstractControlOptions['global'] : undefined\n      };\n      abstractControlOptions = this.getAbstractControlOptions(\"global\", formBuilderConfiguration, abstractControlOptions);\n      let formGroup = new RxFormGroup(json.model, json.entityObject, formGroupObject, abstractControlOptions);\n\n      if (defaultContainer.isExperimental) {\n        json.entityObject[\"formGroup\"] = formGroup;\n        this.overrideProperties(formGroup, json.entityObject, extendedProperties);\n      }\n\n      if (!this.isNestedBinding && !this.isGroupCalled) formGroup.refreshDisable();\n      return formGroup;\n    }\n\n    overrideProperties(formGroup, entityObject, properties) {\n      Object.keys(properties).forEach(t => {\n        this.overrideProp(entityObject, t, formGroup);\n      });\n    }\n\n    getAbstractControlOptions(name, formBuilderConfiguration, abstractControlOptions) {\n      if (formBuilderConfiguration && formBuilderConfiguration.abstractControlOptions && formBuilderConfiguration.abstractControlOptions[name]) abstractControlOptions.updateOn = formBuilderConfiguration.abstractControlOptions[name];\n      const controlOptions = formBuilderConfiguration ? formBuilderConfiguration.baseAbstractControlOptions : null;\n\n      if (controlOptions && controlOptions[name]) {\n        if (controlOptions[name].updateOn) abstractControlOptions.updateOn = controlOptions[name].updateOn;\n\n        if (controlOptions[name].validators) {\n          if (Array.isArray(controlOptions[name].validators)) controlOptions[name].validators.forEach(validator => abstractControlOptions.validators.push(validator));else abstractControlOptions.validators.push(controlOptions[name].validators);\n        }\n\n        if (controlOptions[name].asyncValidators) {\n          if (Array.isArray(controlOptions[name].asyncValidators)) controlOptions[name].asyncValidators.forEach(validator => abstractControlOptions.asyncValidators.push(validator));else abstractControlOptions.asyncValidators.push(controlOptions[name].validators);\n        }\n      }\n\n      return abstractControlOptions;\n    }\n\n    overrideProp(entityObject, propName, formGroup) {\n      let descriptor = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(entityObject), propName);\n      let value = entityObject[propName];\n      let oldValue = null;\n      Object.defineProperty(entityObject, propName, {\n        get: () => {\n          return descriptor ? descriptor.get.call(entityObject) : value;\n        },\n        set: v => {\n          value = v;\n\n          if (oldValue != v) {\n            if (descriptor) descriptor.set.call(entityObject, v);\n\n            if (!formGroup.changing && formGroup.controls[propName]) {\n              formGroup.controls[propName].setValue(v);\n            }\n          }\n\n          oldValue = v;\n        }\n      });\n    }\n\n  }\n\n  RxFormBuilder.ɵfac = function RxFormBuilder_Factory(t) {\n    return new (t || RxFormBuilder)();\n  };\n\n  RxFormBuilder.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: RxFormBuilder,\n    factory: RxFormBuilder.ɵfac\n  });\n  return RxFormBuilder;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet BaseDirective = /*#__PURE__*/(() => {\n  class BaseDirective {\n    applyValidations(controls, model = null) {\n      if (this.model) {\n        let modelConfig = defaultContainer.get(model || this.model.constructor);\n\n        if (modelConfig) {\n          modelConfig.properties.forEach(property => {\n            if (controls[property.name]) {\n              switch (property.propertyType) {\n                case PROPERTY:\n                  this.setValidatorConfig(controls[property.name], modelConfig, property);\n                  break;\n\n                case OBJECT_PROPERTY:\n                  this.applyValidations(controls[property.name].controls, property.entity);\n                  break;\n              }\n            }\n          });\n        }\n      }\n    }\n\n    setValidatorConfig(control, modelConfig, property) {\n      let annotations = modelConfig.propertyAnnotations.filter(t => t.propertyName == property.name);\n      annotations.forEach(annotation => {\n        if (!control[TEMPLATE_VALIDATION_CONFIG]) control[TEMPLATE_VALIDATION_CONFIG] = {};\n        ApplicationUtil.configureControl(control, annotation.config ? annotation.config : \"\", annotation.annotationType);\n      });\n    }\n\n  }\n\n  BaseDirective.ɵfac = function BaseDirective_Factory(t) {\n    return new (t || BaseDirective)();\n  };\n\n  BaseDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: BaseDirective,\n    inputs: {\n      model: \"model\"\n    }\n  });\n  return BaseDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet RxwebFormDirective = /*#__PURE__*/(() => {\n  class RxwebFormDirective extends BaseDirective {\n    constructor() {\n      super(...arguments);\n      this.clearTimeoutNumber = 0;\n      this.validationRule = {};\n    }\n\n    ngAfterContentInit() {\n      if (this.formGroup && !this.formGroup[MODEL] && this.formGroup.parent == null) {\n        this.expressionProcessor(this.formGroup.controls);\n        this.setConditionalValidator(this.formGroup.controls);\n      } else if (this.formGroup && !this.formGroup[MODEL] && this.formGroup.parent instanceof FormArray) {\n        this.expressionProcessor(this.formGroup.controls);\n        this.setConditionalValidator(this.formGroup.controls);\n      } else if (this.ngForm) {\n        this.configureModelValidations();\n      }\n    }\n\n    configureModelValidations() {\n      this.clearTimeoutNumber = setTimeout(() => {\n        clearTimeout(this.clearTimeoutNumber);\n        this.applyValidations(this.ngForm.form.controls);\n        this.expressionProcessor(this.ngForm.form.controls);\n        this.setConditionalValidator(this.ngForm.form.controls);\n        this.updateValueAndValidity(this.ngForm.form.controls);\n      }, 500);\n    }\n\n    updateValueAndValidity(controls) {\n      Object.keys(controls).forEach(key => {\n        if (controls[key] instanceof FormGroup) this.updateValueAndValidity(controls[key].controls);else if (controls[key] instanceof FormArray) this.updateValueAndValidity(controls[key].controls);else controls[key].updateValueAndValidity();\n      });\n    }\n\n    expressionProcessor(controls, rootFieldName = \"\") {\n      Object.keys(controls).forEach(fieldName => {\n        let formControl = controls[fieldName];\n\n        if (formControl.validatorConfig) {\n          Object.keys(AnnotationTypes).forEach(validatorName => {\n            if (formControl.validatorConfig[validatorName] && formControl.validatorConfig[validatorName].disableExpression) {\n              formControl[\"disableExpression\"] = formControl.validatorConfig[validatorName].disableExpression;\n              let columns = Linq.expressionColumns(formControl.validatorConfig[validatorName].disableExpression);\n              columns.forEach(t => {\n                defaultContainer.setConditionalValueProp(this.validationRule, rootFieldName + t.propName, fieldName);\n              });\n            }\n\n            if (formControl.validatorConfig[validatorName] && formControl.validatorConfig[validatorName].conditionalExpression) {\n              let columns = Linq.expressionColumns(formControl.validatorConfig[validatorName].conditionalExpression);\n              columns.forEach(t => {\n                defaultContainer.setConditionalValueProp(this.validationRule, rootFieldName + t.propName, fieldName);\n              });\n            }\n\n            if (formControl.validatorConfig[validatorName] && formControl.validatorConfig[validatorName].dynamicConfig) {\n              let columns = Linq.dynamicConfigParser(formControl.validatorConfig[validatorName].dynamicConfig, fieldName);\n              columns.forEach(t => {\n                defaultContainer.setConditionalValueProp(this.validationRule, rootFieldName + t.propName, fieldName);\n              });\n            }\n\n            if (formControl.validatorConfig[validatorName] && (validatorName == AnnotationTypes.and || validatorName == AnnotationTypes.or || validatorName == AnnotationTypes.not)) {\n              Object.keys(formControl.validatorConfig[validatorName].validation).forEach(t => {\n                if (typeof formControl.validatorConfig[validatorName].validation[t] !== \"boolean\") defaultContainer.setLogicalConditional(this.validationRule, t, formControl.validatorConfig[validatorName].validation[t].fieldName, fieldName);\n              });\n            } else if (formControl.validatorConfig[validatorName] && (validatorName == AnnotationTypes.compare || validatorName == AnnotationTypes.greaterThan || validatorName == AnnotationTypes.greaterThanEqualTo || validatorName == AnnotationTypes.lessThan || validatorName == AnnotationTypes.lessThanEqualTo || validatorName == AnnotationTypes.different || validatorName == AnnotationTypes.factor || validatorName == AnnotationTypes.minTime || validatorName == AnnotationTypes.maxTime || validatorName == AnnotationTypes.creditCard && formControl.validatorConfig[validatorName].fieldName || (validatorName == AnnotationTypes.minDate || validatorName == AnnotationTypes.maxDate) && formControl.validatorConfig[validatorName].fieldName)) {\n              defaultContainer.setConditionalValueProp(this.validationRule, formControl.validatorConfig[validatorName].fieldName, fieldName);\n            }\n          });\n        } else if (formControl instanceof FormGroup) {\n          this.expressionProcessor(formControl.controls, `${fieldName}.`);\n        } else if (formControl instanceof FormArray) {\n          if (formControl.controls) formControl.controls.forEach((t, i) => {\n            if (t.controls) this.expressionProcessor(t.controls, `${fieldName}[]`);\n          });\n        }\n      });\n    }\n\n    setConditionalValidator(controls) {\n      Object.keys(controls).forEach(fieldName => {\n        if (this.validationRule.conditionalValidationProps && this.validationRule.conditionalValidationProps[fieldName]) {\n          controls[fieldName][CONDITIONAL_VALIDATOR] = conditionalChangeValidator(this.validationRule.conditionalValidationProps[fieldName]);\n        } else if (controls[fieldName] instanceof FormGroup && this.validationRule.conditionalObjectProps) {\n          var fields = this.validationRule.conditionalObjectProps.filter(t => t.objectPropName == fieldName);\n          let nestedFormGroup = controls[fieldName];\n          let propWiseConditionalControls = {};\n          fields.forEach(x => {\n            if (!propWiseConditionalControls[x.propName]) propWiseConditionalControls[x.propName] = [];\n            propWiseConditionalControls[x.propName].push(x.referencePropName);\n          });\n          Object.keys(propWiseConditionalControls).forEach(key => {\n            nestedFormGroup.controls[key][CONDITIONAL_VALIDATOR] = conditionalChangeValidator(propWiseConditionalControls[key]);\n          });\n        } else if (controls[fieldName] instanceof FormArray) {\n          //fix https://github.com/rxweb/rxweb/issues/274\n          controls[fieldName].controls.forEach((t, i) => {\n            if (t.controls == undefined) this.setConditionalValidator({\n              [i]: t\n            });else this.setConditionalValidator(t.controls);\n          });\n        }\n      });\n    }\n\n    ngOnDestroy() {}\n\n  }\n\n  RxwebFormDirective.ɵfac = /*@__PURE__*/function () {\n    let ɵRxwebFormDirective_BaseFactory;\n    return function RxwebFormDirective_Factory(t) {\n      return (ɵRxwebFormDirective_BaseFactory || (ɵRxwebFormDirective_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(RxwebFormDirective)))(t || RxwebFormDirective);\n    };\n  }();\n\n  RxwebFormDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: RxwebFormDirective,\n    selectors: [[\"\", \"formGroup\", \"\"], [\"\", \"rxwebForm\", \"\"]],\n    inputs: {\n      formGroup: \"formGroup\",\n      ngForm: [\"rxwebForm\", \"ngForm\"]\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n  return RxwebFormDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet DecimalProvider = /*#__PURE__*/(() => {\n  class DecimalProvider {\n    constructor(decimalPipe, localeId) {\n      this.decimalPipe = decimalPipe;\n      this.localeId = localeId;\n      this.decimalSeperator = \".\";\n      this.groupSeperator = \",\";\n      this.isSetConfig = false;\n      this.decimalSeperator = getLocaleNumberSymbol(localeId, NumberSymbol.Decimal);\n      ;\n      this.groupSeperator = getLocaleNumberSymbol(localeId, NumberSymbol.Group);\n      this.setSymbolInConfig();\n    }\n\n    replacer(value) {\n      value = String(value);\n      if (!this.isSetConfig) this.bindConfig();\n      value = value.split(this.groupSeperator).join(BLANK);\n      if (this.allowDecimalSymbol) value = value.replace(this.decimalSeperator, this.allowDecimalSymbol);\n      var splitValue = value.split(this.decimalSeperator);\n      value = splitValue.length > 1 && splitValue[1] && RegexValidator.isZero(splitValue[1]) ? splitValue[0] : value;\n      return value;\n    }\n\n    transFormDecimal(value, digitsInfo, persistZero) {\n      value = String(value);\n\n      if (!value) {\n        return value;\n      }\n\n      let transformedValue = this.decimalPipe.transform(value.replace(ReactiveFormConfig.number.groupSymbol, \"\").replace(this.decimalSeperator, \".\"), digitsInfo, this.localeId);\n\n      if (persistZero && value.indexOf(this.decimalSeperator)) {\n        let splitTransformed = transformedValue.split(\".\");\n        let splitDigitsInfo = digitsInfo ? digitsInfo.split(\"-\") : [];\n        let digits = splitDigitsInfo.length > 1 ? parseInt(splitDigitsInfo[splitDigitsInfo.length - 1]) : 0;\n\n        if (splitTransformed.length > 1 && splitDigitsInfo.length > 0 && digits !== 0 && splitTransformed[1].length !== digits) {\n          let diff = digits - splitTransformed[1].length;\n\n          for (let i = 0; i < diff; i++) {\n            transformedValue += \"0\";\n          }\n        }\n      }\n\n      return transformedValue;\n    }\n\n    setSymbolInConfig() {\n      ReactiveFormConfig.number = {\n        decimalSymbol: this.decimalSeperator,\n        groupSymbol: this.groupSeperator\n      };\n    }\n\n    bindConfig() {\n      if (ReactiveFormConfig.json) {\n        if (ReactiveFormConfig.json.localeId) this.localeId = ReactiveFormConfig.json.localeId;\n        if (ReactiveFormConfig.json.allowDecimalSymbol) this.allowDecimalSymbol = ReactiveFormConfig.json.allowDecimalSymbol;\n      }\n\n      this.isSetConfig = true;\n    }\n\n  }\n\n  DecimalProvider.ɵfac = function DecimalProvider_Factory(t) {\n    return new (t || DecimalProvider)(ɵngcc0.ɵɵinject(ɵngcc1.DecimalPipe), ɵngcc0.ɵɵinject(LOCALE_ID));\n  };\n\n  DecimalProvider.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: DecimalProvider,\n    factory: DecimalProvider.ɵfac\n  });\n  return DecimalProvider;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet HtmlControlTemplateDirective = /*#__PURE__*/(() => {\n  class HtmlControlTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  HtmlControlTemplateDirective.ɵfac = function HtmlControlTemplateDirective_Factory(t) {\n    return new (t || HtmlControlTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef));\n  };\n\n  HtmlControlTemplateDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: HtmlControlTemplateDirective,\n    selectors: [[\"\", \"htmlControlTemplate\", \"\"]],\n    inputs: {\n      type: [\"htmlControlTemplate\", \"type\"]\n    }\n  });\n  return HtmlControlTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet ControlHostDirective = /*#__PURE__*/(() => {\n  class ControlHostDirective {\n    constructor(viewContainerRef) {\n      this.viewContainerRef = viewContainerRef;\n    }\n\n    set portal(context) {\n      if (context.templateRef) {\n        if (this.view) {\n          this.view.destroy();\n          this.view = undefined;\n        }\n\n        this.view = this.viewContainerRef.createEmbeddedView(context.templateRef, context);\n      }\n    }\n\n    ngOnDestroy() {\n      if (this.view) this.view.destroy();\n      if (this.viewContainerRef) this.viewContainerRef.clear();\n    }\n\n  }\n\n  ControlHostDirective.ɵfac = function ControlHostDirective_Factory(t) {\n    return new (t || ControlHostDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef));\n  };\n\n  ControlHostDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: ControlHostDirective,\n    selectors: [[\"\", \"controlHost\", \"\"]],\n    inputs: {\n      portal: [\"controlHost\", \"portal\"]\n    }\n  });\n  return ControlHostDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet ControlExpressionProcess = /*#__PURE__*/(() => {\n  class ControlExpressionProcess {\n    constructor() {\n      this.controlConfig = {};\n      this.isProcessed = false;\n    }\n\n    setModelConfig(control) {\n      this.isProcessed = true;\n\n      if (this.controlConfig && this.controlConfig.validatorConfig) {\n        control[VALIDATOR_CONFIG$2] = this.controlConfig.validatorConfig;\n        this.controlConfig = undefined;\n      }\n    }\n\n  }\n\n  ControlExpressionProcess.ɵfac = function ControlExpressionProcess_Factory(t) {\n    return new (t || ControlExpressionProcess)();\n  };\n\n  ControlExpressionProcess.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: ControlExpressionProcess,\n    inputs: {\n      name: \"name\",\n      formControlName: \"formControlName\"\n    }\n  });\n  return ControlExpressionProcess;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet BaseValidator = /*#__PURE__*/(() => {\n  class BaseValidator extends ControlExpressionProcess {\n    constructor() {\n      super(...arguments);\n      this.validators = [];\n    }\n\n    validation(control) {\n      let result = null;\n\n      for (let validator of this.validators) {\n        result = validator(control);\n        if (result) break;\n      }\n\n      if (!result && this.maskProvider) result = this.maskProvider.validate();\n      return result;\n    }\n\n    setEventName() {\n      var eventName = '';\n\n      switch (this.element.tagName) {\n        case INPUT:\n        case TEXTAREA:\n          eventName = this.element.type == CHECKBOX || this.element.type == RADIO || this.element.type == FILE ? CHANGE : INPUT;\n          break;\n\n        case SELECT:\n          eventName = CHANGE;\n          break;\n      }\n\n      this.eventName = eventName.toLowerCase();\n    }\n\n  }\n\n  BaseValidator.ɵfac = /*@__PURE__*/function () {\n    let ɵBaseValidator_BaseFactory;\n    return function BaseValidator_Factory(t) {\n      return (ɵBaseValidator_BaseFactory || (ɵBaseValidator_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(BaseValidator)))(t || BaseValidator);\n    };\n  }();\n\n  BaseValidator.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: BaseValidator,\n    inputs: {\n      formControl: \"formControl\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n  return BaseValidator;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst SIMPLE_EMAIL_VALIDATION = \"simple-email-validation\";\nconst ADVANCED_EMAIL_VALIDATION = \"advanced-email-validation\";\n\nclass MaskProvider {\n  constructor(input, mask, renderer, formControl, config) {\n    this.input = input;\n    this.mask = mask;\n    this.renderer = renderer;\n    this.formControl = formControl;\n    this.config = config;\n    this.eventListeners = [];\n    this.oldValue = '';\n    this.type = 'text';\n    this.slotChar = '_';\n    this.autoClear = false;\n    this.isInvalid = false;\n    this.internalProcess = false;\n    this.bind();\n  }\n\n  bind() {\n    if (RegexValidator.isNotBlank(this.formControl.value)) this.input.value = this.formControl.value;\n    this.tests = [];\n    this.partialPosition = this.mask.length;\n    this.len = this.mask.length;\n    this.firstNonMaskPos = null;\n    this.defs = {\n      '9': '[0-9]',\n      'a': '[A-Za-z]',\n      '*': '[A-Za-z0-9]'\n    };\n    this.androidChrome = false;\n    let maskTokens = this.mask.split('');\n\n    for (let i = 0; i < maskTokens.length; i++) {\n      let c = maskTokens[i];\n\n      if (c == '?') {\n        this.len--;\n        this.partialPosition = i;\n      } else if (this.defs[c]) {\n        this.tests.push(new RegExp(this.defs[c]));\n\n        if (this.firstNonMaskPos === null) {\n          this.firstNonMaskPos = this.tests.length - 1;\n        }\n\n        if (i < this.partialPosition) {\n          this.lastRequiredNonMaskPos = this.tests.length - 1;\n        }\n      } else {\n        this.tests.push(null);\n      }\n    }\n\n    this.minLength = this.config.minLength ? this.lastRequiredNonMaskPos - (this.lastRequiredNonMaskPos - this.config.minLength) : this.lastRequiredNonMaskPos;\n    this.buffer = [];\n\n    for (let i = 0; i < maskTokens.length; i++) {\n      let c = maskTokens[i];\n\n      if (c != '?') {\n        if (this.defs[c]) this.buffer.push(this.getPlaceholder(i));else this.buffer.push(c);\n      }\n    }\n\n    this.defaultBuffer = this.buffer.join('');\n    this.focusText = this.input.value;\n    this.bindEvents();\n    this.checkVal();\n  }\n\n  bindEvents() {\n    this.eventListeners.push(this.renderer.listen(this.input, FOCUS, this.onFocus.bind(this)));\n    this.eventListeners.push(this.renderer.listen(this.input, BLUR, this.onBlur.bind(this)));\n    this.eventListeners.push(this.renderer.listen(this.input, KEY_DOWN, this.onKeyDown.bind(this)));\n    this.eventListeners.push(this.renderer.listen(this.input, KEY_PRESS, this.onKeyPress.bind(this)));\n    this.eventListeners.push(this.renderer.listen(this.input, \"input\", this.onInput.bind(this)));\n    this.eventListeners.push(this.renderer.listen(this.input, PASTE, this.handleInputChange.bind(this)));\n  }\n\n  validate() {\n    if (this.input.value && this.oldValue != this.input.value) {\n      this.checkVal(true);\n      this.isCompleted(null, true);\n      this.oldValue = this.input.value;\n    }\n\n    let config = getConfigObject(this.config, this.formControl);\n\n    if (RegexValidator.isNotBlank(this.getUnmaskedValue()) && FormProvider.ProcessRule(this.formControl, config)) {\n      if (this.isInvalid) {\n        return ObjectMaker.toJson(AnnotationTypes.mask, config, [this.formControl.value]);\n      }\n    }\n\n    return ObjectMaker.null();\n  }\n\n  writeValue(value) {\n    this.value = value;\n\n    if (this.input) {\n      if (this.value == undefined || this.value == null) {\n        this.input.value = '';\n      }\n\n      this.checkVal();\n    }\n\n    this.updateFilledState();\n  }\n\n  caret(first, last) {\n    let range, begin, end;\n\n    if (!this.input.offsetParent || this.input !== document.activeElement) {\n      return;\n    }\n\n    if (typeof first == 'number') {\n      begin = first;\n      end = typeof last === 'number' ? last : begin;\n\n      if (this.input.setSelectionRange) {\n        this.input.setSelectionRange(begin, end);\n      } else if (this.input['createTextRange']) {\n        range = this.input['createTextRange']();\n        range.collapse(true);\n        range.moveEnd('character', end);\n        range.moveStart('character', begin);\n        range.select();\n      }\n    } else {\n      if (this.input.setSelectionRange) {\n        begin = this.input.selectionStart;\n        end = this.input.selectionEnd;\n      } else if (document['selection'] && document['selection'].createRange) {\n        range = document['selection'].createRange();\n        begin = 0 - range.duplicate().moveStart('character', -100000);\n        end = begin + range.text.length;\n      }\n\n      return {\n        begin: begin,\n        end: end\n      };\n    }\n  }\n\n  isCompleted(lastRequiredNonMaskPos, isNotRunValidator) {\n    let completed;\n    lastRequiredNonMaskPos = lastRequiredNonMaskPos || this.lastRequiredNonMaskPos;\n\n    for (let i = this.firstNonMaskPos; i <= lastRequiredNonMaskPos; i++) {\n      if (this.tests[i] && this.buffer[i] === this.getPlaceholder(i)) {\n        return false;\n      }\n    }\n\n    this.isInvalid = false;\n    if (!isNotRunValidator) this.formControl.updateValueAndValidity();\n    return true;\n  }\n\n  getPlaceholder(i) {\n    if (i < this.slotChar.length) {\n      return this.slotChar.charAt(i);\n    }\n\n    return this.slotChar.charAt(0);\n  }\n\n  seekNext(pos) {\n    while (++pos < this.len && !this.tests[pos]);\n\n    return pos;\n  }\n\n  seekPrev(pos) {\n    while (--pos >= 0 && !this.tests[pos]);\n\n    return pos;\n  }\n\n  shiftL(begin, end) {\n    let i, j;\n\n    if (begin < 0) {\n      return;\n    }\n\n    for (i = begin, j = this.seekNext(end); i < this.len; i++) {\n      if (this.tests[i]) {\n        if (j < this.len && this.tests[i].test(this.buffer[j])) {\n          this.buffer[i] = this.buffer[j];\n          this.buffer[j] = this.getPlaceholder(j);\n        } else {\n          break;\n        }\n\n        j = this.seekNext(j);\n      }\n    }\n\n    this.writeBuffer();\n    this.caret(Math.max(this.firstNonMaskPos, begin));\n  }\n\n  shiftR(pos) {\n    let i, c, j, t;\n\n    for (i = pos, c = this.getPlaceholder(pos); i < this.len; i++) {\n      if (this.tests[i]) {\n        j = this.seekNext(i);\n        t = this.buffer[i];\n        this.buffer[i] = c;\n\n        if (j < this.len && this.tests[j].test(t)) {\n          c = t;\n        } else {\n          break;\n        }\n      }\n    }\n  }\n\n  handleAndroidInput(e) {\n    var curVal = this.input.value;\n    var pos = this.caret();\n\n    if (this.oldVal && this.oldVal.length && this.oldVal.length > curVal.length) {\n      this.checkVal(true);\n\n      while (pos.begin > 0 && !this.tests[pos.begin - 1]) pos.begin--;\n\n      if (pos.begin === 0) {\n        while (pos.begin < this.firstNonMaskPos && !this.tests[pos.begin]) pos.begin++;\n      }\n\n      this.caret(pos.begin, pos.begin);\n    } else {\n      var pos2 = this.checkVal(true);\n\n      while (pos.begin < this.len && !this.tests[pos.begin]) pos.begin++;\n\n      this.caret(pos.begin, pos.begin);\n    }\n\n    if (this.isCompleted()) {\n      this.isInvalid = false;\n    } else {\n      this.isInvalid = true;\n      this.formControl.updateValueAndValidity();\n    }\n  }\n\n  onBlur(e) {\n    this.focus = false;\n    this.checkVal();\n    this.updateModel(e);\n    this.updateFilledState();\n\n    if (this.input.value != this.focusText) {\n      let event = document.createEvent('HTMLEvents');\n      event.initEvent('change', true, false);\n      this.input.dispatchEvent(event);\n      let maskedValue = this.input.value;\n      this.formControl.setValue(this.config.valueWithMask ? maskedValue : this.getUnmaskedValue());\n      this.input.value = maskedValue;\n    }\n  }\n\n  onKeyDown(e) {\n    let k = e.which || e.keyCode,\n        pos,\n        begin,\n        end;\n    let iPhone = false;\n    this.oldVal = this.input.value;\n    let controlValid = this.config.minLength ? this.isCompleted(this.minLength + 1) : false;\n\n    if (k === 8 || k === 46 || iPhone && k === 127) {\n      pos = this.caret();\n      begin = pos.begin;\n      end = pos.end;\n\n      if (end - begin === 0) {\n        begin = k !== 46 ? this.seekPrev(begin) : end = this.seekNext(begin - 1);\n        end = k === 46 ? this.seekNext(end) : end;\n      }\n\n      this.clearBuffer(begin, end);\n      this.shiftL(begin, end - 1);\n      this.setControlValue(e, false, controlValid);\n      this.updateModel(e);\n      e.preventDefault();\n    } else if (k === 13) {\n      this.onBlur(e);\n      this.setControlValue(e, false, controlValid);\n      this.updateModel(e);\n    } else if (k === 27) {\n      this.input.value = this.focusText;\n      this.caret(0, this.checkVal());\n      this.updateModel(e);\n      this.setControlValue(e, false, controlValid);\n      e.preventDefault();\n    }\n  }\n\n  onKeyPress(e) {\n    var k = e.which || e.keyCode,\n        pos = this.caret(),\n        p,\n        c,\n        next,\n        completed;\n\n    if (e.ctrlKey || e.altKey || e.metaKey || k < 32) {\n      return;\n    } else if (k && k !== 13) {\n      if (pos.end - pos.begin !== 0) {\n        this.clearBuffer(pos.begin, pos.end);\n        this.shiftL(pos.begin, pos.end - 1);\n      }\n\n      p = this.seekNext(pos.begin - 1);\n\n      if (p < this.len) {\n        c = String.fromCharCode(k);\n\n        if (this.tests[p].test(c)) {\n          this.shiftR(p);\n          this.buffer[p] = c;\n          this.writeBuffer();\n          next = this.seekNext(p);\n          this.caret(next);\n\n          if (pos.begin <= this.lastRequiredNonMaskPos) {\n            completed = this.isCompleted();\n          }\n        }\n      }\n\n      e.preventDefault();\n    }\n\n    this.updateModel(e);\n    if (completed === undefined) completed = this.isCompleted();\n    this.setControlValue(e, completed, this.config.minLength ? this.isCompleted(this.minLength) : false);\n  }\n\n  clearBuffer(start, end) {\n    let i;\n\n    for (i = start; i < end && i < this.len; i++) {\n      if (this.tests[i]) {\n        this.buffer[i] = this.getPlaceholder(i);\n      }\n    }\n  }\n\n  writeBuffer() {\n    this.input.value = this.buffer.join('');\n  }\n\n  checkVal(allow) {\n    let test = this.input.value,\n        lastMatch = -1,\n        i,\n        c,\n        pos;\n\n    for (i = 0, pos = 0; i < this.len; i++) {\n      if (this.tests[i]) {\n        this.buffer[i] = this.getPlaceholder(i);\n\n        while (pos++ < test.length) {\n          c = test.charAt(pos - 1);\n\n          if (this.tests[i].test(c)) {\n            this.buffer[i] = c;\n            lastMatch = i;\n            break;\n          }\n        }\n\n        if (pos > test.length) {\n          this.clearBuffer(i + 1, this.len);\n          break;\n        }\n      } else {\n        if (this.buffer[i] === test.charAt(pos)) {\n          pos++;\n        }\n\n        if (i < this.partialPosition) {\n          lastMatch = i;\n        }\n      }\n    }\n\n    if (allow) {\n      this.writeBuffer();\n    } else if (lastMatch + 1 < this.partialPosition && (!this.config.minLength || !(lastMatch >= this.minLength))) {\n      if (this.autoClear || this.buffer.join('') === this.defaultBuffer) {\n        this.isInvalid = true;\n      } else {\n        this.isInvalid = true;\n        this.writeBuffer();\n      }\n    } else {\n      this.writeBuffer();\n      this.input.value = this.input.value.substring(0, lastMatch + 1);\n    }\n\n    return this.partialPosition ? i : this.firstNonMaskPos;\n  }\n\n  onFocus(event) {\n    this.focus = true;\n    clearTimeout(this.caretTimeoutId);\n    let pos;\n    this.focusText = this.input.value;\n    pos = this.checkVal();\n    this.caretTimeoutId = setTimeout(() => {\n      if (this.input !== document.activeElement) {\n        return;\n      }\n\n      this.writeBuffer();\n\n      if (pos == this.mask.replace(\"?\", \"\").length) {\n        this.caret(0, pos);\n      } else {\n        this.caret(pos);\n      }\n\n      this.updateFilledState();\n    }, 10);\n  }\n\n  onInput(event) {\n    if (this.androidChrome) this.handleAndroidInput(event);else this.handleInputChange(event);\n  }\n\n  setControlValue(e, isValid, isValidControl) {\n    this.isInvalid = isValidControl ? !isValidControl : !isValid;\n    let value = this.input.value;\n    let controlValue = '';\n    if (!this.isInvalid) controlValue = this.config.valueWithMask ? value : this.getUnmaskedValue();\n    this.formControl.setValue(controlValue);\n    this.oldValue = this.input.value = value;\n    if (!isValid) this.onFocus(e);\n  }\n\n  handleInputChange(event) {\n    setTimeout(() => {\n      var pos = this.checkVal(true);\n      this.caret(pos);\n      this.updateModel(event);\n      this.setControlValue(event, this.isCompleted());\n    }, 0);\n  }\n\n  getUnmaskedValue() {\n    let unmaskedBuffer = [];\n\n    for (let i = 0; i < this.buffer.length; i++) {\n      let c = this.buffer[i];\n\n      if (this.tests[i] && c != this.getPlaceholder(i)) {\n        unmaskedBuffer.push(c);\n      }\n    }\n\n    return unmaskedBuffer.join('');\n  }\n\n  updateModel(e) {}\n\n  updateFilledState() {\n    this.filled = this.input && this.input.value != '';\n  }\n\n  onDestroy() {\n    let eventCount = this.eventListeners.length;\n\n    for (var i = 0; i < eventCount; i++) {\n      this.eventListeners[0]();\n      this.eventListeners.splice(0, 1);\n    }\n\n    this.eventListeners = [];\n  }\n\n}\n\nconst NGMODEL_BINDING = {\n  provide: NG_VALIDATORS,\n  useExisting: forwardRef(() => RxFormControlDirective),\n  multi: true\n};\nconst ALLOW_VALIDATOR_WITHOUT_CONFIG = ['required', 'notEmpty', 'alpha', 'alphaNumeric', 'ascii', 'dataUri', 'digit', 'email', 'even', 'hexColor', 'json', 'latitude', 'latLong', 'leapYear', 'longitude', 'lowerCase', 'mac', 'odd', 'port', 'primeNumber', 'time', 'upperCase', 'url', 'unique', 'cusip', 'gird'];\nconst NUMERIC = \"numeric\";\nconst IS_FORMAT = \"isFormat\";\nconst DIGITS_INFO = \"digitsInfo\";\nlet RxFormControlDirective = /*#__PURE__*/(() => {\n  class RxFormControlDirective extends BaseValidator {\n    constructor(elementRef, renderer, decimalProvider) {\n      super();\n      this.elementRef = elementRef;\n      this.renderer = renderer;\n      this.decimalProvider = decimalProvider;\n      this.eventListeners = [];\n      this.isNumericSubscribed = false;\n      this.isFocusCalled = false;\n      this.isMasked = false;\n      this.element = elementRef.nativeElement;\n      this.setEventName();\n    }\n\n    set validationControls(value) {\n      this.controls = value;\n    }\n\n    get validationControls() {\n      return this.controls;\n    }\n\n    ngOnInit() {\n      let validators = [];\n      Object.keys(APP_VALIDATORS).forEach(validatorName => {\n        if (this[`rx${validatorName}`] || ALLOW_VALIDATOR_WITHOUT_CONFIG.indexOf(validatorName) != -1 && this[`rx${validatorName}`] == BLANK) {\n          validators.push(APP_VALIDATORS[validatorName](this[`rx${validatorName}`]));\n\n          if (this.name && !(this.formControlName && this.formControl)) {\n            ApplicationUtil.configureControl(this.controlConfig, this[`rx${validatorName}`], validatorName);\n          }\n        }\n      });\n      if (validators.length > 0) this.validators = validators;\n\n      if (this.rxnumeric && (this.rxnumeric.isFormat || this.rxnumeric.digitsInfo)) {\n        this.bindNumericElementEvent();\n      }\n    }\n\n    blurEvent() {\n      if (!(this.formControl && this.formControl.errors && this.formControl.errors.numeric)) {\n        if (this.formControl.value !== null && this.formControl.value !== undefined) {\n          let value = this.decimalProvider.transFormDecimal(this.formControl.value, this.rxnumeric.digitsInfo, this.rxnumeric.persistZero);\n          value = !this.rxnumeric.isFormat ? this.decimalProvider.replacer(value) : value;\n          this.setValueOnElement(value);\n        }\n\n        this.isFocusCalled = false;\n      }\n    }\n\n    bindNumericElementEvent(config) {\n      if (config) this.rxnumeric = config;\n      let listener = this.renderer.listen(this.element, BLUR, this.blurEvent.bind(this));\n      this.eventListeners.push(listener);\n      listener = this.renderer.listen(this.element, FOCUS, event => {\n        this.isFocusCalled = true;\n\n        if (!(this.formControl && this.formControl.errors && this.formControl.errors.numeric) && this.formControl.value != null) {\n          let value = this.decimalProvider.replacer(this.element.value);\n          this.setValueOnElement(value);\n        }\n      });\n      this.eventListeners.push(listener);\n    }\n\n    bindValueChangeEvent() {\n      if (this.eventName != BLANK) {\n        let listener = this.renderer.listen(this.element, this.eventName, () => {\n          Object.keys(this.validationControls).forEach(fieldName => {\n            this.validationControls[fieldName].updateValueAndValidity();\n          });\n        });\n        this.eventListeners.push(listener);\n      }\n    }\n\n    subscribeNumericFormatter() {\n      if (this.formControl[VALIDATOR_CONFIG$2] && this.formControl[VALIDATOR_CONFIG$2][NUMERIC] && (this.formControl[VALIDATOR_CONFIG$2][NUMERIC][IS_FORMAT] || this.formControl[VALIDATOR_CONFIG$2][NUMERIC][DIGITS_INFO])) {\n        if (!this.isNumericSubscribed) {\n          this.bindNumericElementEvent(this.formControl[VALIDATOR_CONFIG$2][NUMERIC]);\n          this.isNumericSubscribed = true;\n        }\n\n        if (!this.isFocusCalled && RegexValidator.isNotBlank(this.formControl.value)) {\n          this.blurEvent();\n        }\n      }\n    }\n\n    subscribeMaskValidator() {\n      if (this.formControl[VALIDATOR_CONFIG$2] && this.formControl[VALIDATOR_CONFIG$2][\"mask\"] && !this.isMasked) {\n        let config = this.formControl[VALIDATOR_CONFIG$2][\"mask\"];\n        this.maskProvider = new MaskProvider(this.element, config.mask, this.renderer, this.formControl, config);\n        this.isMasked = true;\n      }\n    }\n\n    setValueOnElement(value) {\n      this.renderer.setProperty(this.element, ELEMENT_VALUE, value);\n    }\n\n    setTemplateValidators(control) {\n      for (let validatorName in control[VALIDATOR_CONFIG$2]) {\n        this[validatorName] = control[VALIDATOR_CONFIG$2][validatorName];\n      }\n\n      delete control[TEMPLATE_VALIDATION_CONFIG];\n      delete control[VALIDATOR_CONFIG$2];\n      this.ngOnInit();\n    }\n\n    updateOnElementClass(element) {\n      var previousClassName = '';\n      return function (className) {\n        if (previousClassName) element.classList.remove(previousClassName);\n        if (className) element.classList.add(className);\n        previousClassName = className;\n      };\n    }\n\n    setValidatorConfig(control) {\n      if (!this.formControl) {\n        this.formControl = control;\n        let rxFormControl = this.formControl;\n        if (rxFormControl.updateOnElementClass) rxFormControl.updateOnElementClass = this.updateOnElementClass(this.element);\n      }\n\n      this.subscribeMaskValidator();\n      this.subscribeNumericFormatter();\n      if (control[TEMPLATE_VALIDATION_CONFIG]) this.setTemplateValidators(control);\n\n      if (control[CONDITIONAL_VALIDATOR]) {\n        this.conditionalValidator = control[CONDITIONAL_VALIDATOR];\n        delete control[CONDITIONAL_VALIDATOR];\n      }\n    }\n\n    validate(control) {\n      this.setValidatorConfig(control);\n      if (this.conditionalValidator) this.conditionalValidator(control);\n      if (!this.isProcessed) this.setModelConfig(control);\n      return this.validators && this.validators.length > 0 || this.maskProvider ? this.validation(control) : null;\n    }\n\n    ngOnDestroy() {\n      this.controls = undefined;\n      let eventCount = this.eventListeners.length;\n\n      for (var i = 0; i < eventCount; i++) {\n        this.eventListeners[0]();\n        this.eventListeners.splice(0, 1);\n      }\n\n      this.eventListeners = [];\n      if (this.maskProvider) this.maskProvider.onDestroy();\n    }\n\n  }\n\n  RxFormControlDirective.ɵfac = function RxFormControlDirective_Factory(t) {\n    return new (t || RxFormControlDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(DecimalProvider));\n  };\n\n  RxFormControlDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: RxFormControlDirective,\n    selectors: [[\"\", \"ngModel\", \"\"], [\"\", \"formControlName\", \"\"], [\"\", \"formControl\", \"\"]],\n    inputs: {\n      rxnumeric: \"rxnumeric\",\n      rxalpha: \"rxalpha\",\n      rxalphaNumeric: \"rxalphaNumeric\",\n      rxascii: \"rxascii\",\n      rxcompare: \"rxcompare\",\n      rxcompose: \"rxcompose\",\n      rxcontains: \"rxcontains\",\n      rxcreditCard: \"rxcreditCard\",\n      rxdataUri: \"rxdataUri\",\n      rxdifferent: \"rxdifferent\",\n      rxdigit: \"rxdigit\",\n      rxemail: \"rxemail\",\n      rxendsWith: \"rxendsWith\",\n      rxeven: \"rxeven\",\n      rxextension: \"rxextension\",\n      rxfactor: \"rxfactor\",\n      rxfileSize: \"rxfileSize\",\n      rxgreaterThanEqualTo: \"rxgreaterThanEqualTo\",\n      rxgreaterThan: \"rxgreaterThan\",\n      rxhexColor: \"rxhexColor\",\n      rxjson: \"rxjson\",\n      rxlatitude: \"rxlatitude\",\n      rxlatLong: \"rxlatLong\",\n      rxleapYear: \"rxleapYear\",\n      rxlessThan: \"rxlessThan\",\n      rxlessThanEqualTo: \"rxlessThanEqualTo\",\n      rxlongitude: \"rxlongitude\",\n      rxlowerCase: \"rxlowerCase\",\n      rxmac: \"rxmac\",\n      rxmaxDate: \"rxmaxDate\",\n      rxmaxLength: \"rxmaxLength\",\n      rxmaxNumber: \"rxmaxNumber\",\n      rxminDate: \"rxminDate\",\n      rxminLength: \"rxminLength\",\n      rxminNumber: \"rxminNumber\",\n      rxodd: \"rxodd\",\n      rxpassword: \"rxpassword\",\n      rxport: \"rxport\",\n      rxprimeNumber: \"rxprimeNumber\",\n      rxrequired: \"rxrequired\",\n      rxrange: \"rxrange\",\n      rxrule: \"rxrule\",\n      rxstartsWith: \"rxstartsWith\",\n      rxtime: \"rxtime\",\n      rxupperCase: \"rxupperCase\",\n      rxurl: \"rxurl\",\n      rxunique: \"rxunique\",\n      rxnotEmpty: \"rxnotEmpty\",\n      rxcusip: \"rxcusip\",\n      rxgrid: \"rxgrid\",\n      rxdate: \"rxdate\"\n    },\n    features: [ɵngcc0.ɵɵProvidersFeature([NGMODEL_BINDING]), ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n  return RxFormControlDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst VALIDATOR_CONFIG$1 = \"validatorConfig\";\nconst FILE_VALIDATOR_NAMES = [\"extension\", \"fileSize\", \"file\"];\nlet FileControlDirective = /*#__PURE__*/(() => {\n  class FileControlDirective {\n    constructor(elementRef) {\n      this.elementRef = elementRef;\n      this.isProcessed = false;\n      this.validators = [];\n\n      this.onChange = _ => {};\n\n      this.onTouched = () => {};\n\n      this.element = elementRef.nativeElement;\n    }\n\n    onChangeCall(element) {\n      let files = element.files;\n      if (this.writeFile) this.onChange(files);else {\n        if (files.length > 0) this.onChange(element.value);else this.onChange(undefined);\n      }\n    }\n\n    writeValue(value) {}\n\n    registerOnChange(invocation) {\n      this.onChange = invocation;\n    }\n\n    registerOnTouched(invocation) {\n      this.onTouched = invocation;\n    }\n\n    set extension(config) {\n      this.pushValidator(FILE_VALIDATOR_NAMES[0], config);\n    }\n\n    set fileSize(config) {\n      this.pushValidator(FILE_VALIDATOR_NAMES[1], config);\n    }\n\n    set file(config) {\n      this.pushValidator(FILE_VALIDATOR_NAMES[2], config);\n    }\n\n    setConfig(control) {\n      FILE_VALIDATOR_NAMES.forEach(t => {\n        if (!this[t] && control[VALIDATOR_CONFIG$1] && control[VALIDATOR_CONFIG$1][t]) this[t] = control[VALIDATOR_CONFIG$1][t];\n      });\n      this.isProcessed = true;\n    }\n\n    pushValidator(validatorName, config) {\n      if (config) this.validators.push(APP_VALIDATORS[validatorName](config));\n    }\n\n    validate(control) {\n      if (!this.isProcessed) this.setConfig(control);\n      var result = null;\n\n      for (var validator of this.validators) {\n        result = validator(control, this.element.files);\n        if (result) break;\n      }\n\n      return result;\n    }\n\n  }\n\n  FileControlDirective.ɵfac = function FileControlDirective_Factory(t) {\n    return new (t || FileControlDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n\n  FileControlDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: FileControlDirective,\n    selectors: [[\"input\", \"type\", \"file\"]],\n    hostBindings: function FileControlDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"change\", function FileControlDirective_change_HostBindingHandler($event) {\n          return ctx.onChangeCall($event.target);\n        })(\"blur\", function FileControlDirective_blur_HostBindingHandler() {\n          return ctx.onTouched();\n        });\n      }\n    },\n    inputs: {\n      extension: \"extension\",\n      fileSize: \"fileSize\",\n      file: \"file\",\n      writeFile: \"writeFile\"\n    },\n    features: [ɵngcc0.ɵɵProvidersFeature([{\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: FileControlDirective,\n      multi: true\n    }, {\n      provide: NG_VALIDATORS,\n      useExisting: forwardRef(() => FileControlDirective),\n      multi: true\n    }])]\n  });\n  return FileControlDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst VALIDATOR_CONFIG = \"validatorConfig\";\nlet ImageFileControlDirective = /*#__PURE__*/(() => {\n  class ImageFileControlDirective {\n    constructor(elementRef) {\n      this.elementRef = elementRef;\n      this.isProcessed = false;\n      this.element = elementRef.nativeElement;\n    }\n\n    set image(config) {\n      this.imageValidation = APP_VALIDATORS.image(config);\n    }\n\n    setConfig(control) {\n      let image = \"image\";\n      if (!this[image] && control[VALIDATOR_CONFIG] && control[VALIDATOR_CONFIG][image]) this[image] = control[VALIDATOR_CONFIG][image];\n      this.isProcessed = true;\n    }\n\n    validate(control) {\n      if (!this.isProcessed) this.setConfig(control);\n\n      if (this.imageValidation) {\n        return this.imageValidation(control, this.element.files);\n      }\n\n      return of(null);\n    }\n\n  }\n\n  ImageFileControlDirective.ɵfac = function ImageFileControlDirective_Factory(t) {\n    return new (t || ImageFileControlDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n\n  ImageFileControlDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: ImageFileControlDirective,\n    selectors: [[\"input\", \"type\", \"file\"]],\n    inputs: {\n      image: \"image\"\n    },\n    features: [ɵngcc0.ɵɵProvidersFeature([{\n      provide: NG_ASYNC_VALIDATORS,\n      useExisting: forwardRef(() => ImageFileControlDirective),\n      multi: true\n    }])]\n  });\n  return ImageFileControlDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet AsyncValidationDirective = /*#__PURE__*/(() => {\n  class AsyncValidationDirective {\n    validate(control) {\n      if (this.async) return this.async(control);\n      return of(null);\n    }\n\n  }\n\n  AsyncValidationDirective.ɵfac = function AsyncValidationDirective_Factory(t) {\n    return new (t || AsyncValidationDirective)();\n  };\n\n  AsyncValidationDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: AsyncValidationDirective,\n    selectors: [[\"\", \"ngModel\", \"\"], [\"\", \"formControlName\", \"\"], [\"\", \"formControl\", \"\"]],\n    inputs: {\n      async: \"async\"\n    },\n    features: [ɵngcc0.ɵɵProvidersFeature([{\n      provide: NG_ASYNC_VALIDATORS,\n      useExisting: forwardRef(() => AsyncValidationDirective),\n      multi: true\n    }])]\n  });\n  return AsyncValidationDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet TypedFormBuilder = /*#__PURE__*/(() => {\n  class TypedFormBuilder {\n    constructor() {\n      this.formBuilder = new FormBuilder();\n      this.rxFormBuilder = new RxFormBuilder();\n    }\n\n    group(controlsConfig, options) {\n      let paramOptions = options || {};\n      if (typeof controlsConfig == FUNCTION_STRING) return !(paramOptions && paramOptions.isInstance) ? this.rxFormBuilder.formGroup(controlsConfig, paramOptions.data, paramOptions.config) : this.rxFormBuilder.formGroup(controlsConfig, paramOptions.data, paramOptions.config).modelInstance;\n      return this.formBuilder.group(controlsConfig, options);\n    }\n\n  }\n\n  TypedFormBuilder.ɵfac = function TypedFormBuilder_Factory(t) {\n    return new (t || TypedFormBuilder)();\n  };\n\n  TypedFormBuilder.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: TypedFormBuilder,\n    factory: TypedFormBuilder.ɵfac\n  });\n  return TypedFormBuilder;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet RxReactiveFormsModule = /*#__PURE__*/(() => {\n  class RxReactiveFormsModule {\n    static forRoot() {\n      return {\n        ngModule: RxReactiveFormsModule,\n        providers: []\n      };\n    }\n\n  }\n\n  RxReactiveFormsModule.ɵfac = function RxReactiveFormsModule_Factory(t) {\n    return new (t || RxReactiveFormsModule)();\n  };\n\n  RxReactiveFormsModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: RxReactiveFormsModule\n  });\n  RxReactiveFormsModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: [RxFormBuilder, DecimalProvider, DecimalPipe],\n    imports: [CommonModule, FormsModule, ReactiveFormsModule]\n  });\n  return RxReactiveFormsModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(RxReactiveFormsModule, {\n    declarations: function () {\n      return [RxwebFormDirective, HtmlControlTemplateDirective, ControlHostDirective, RxFormControlDirective, FileControlDirective, ImageFileControlDirective, AsyncValidationDirective];\n    },\n    imports: function () {\n      return [CommonModule, FormsModule, ReactiveFormsModule];\n    },\n    exports: function () {\n      return [AsyncValidationDirective, RxwebFormDirective, HtmlControlTemplateDirective, RxFormControlDirective, FileControlDirective, ImageFileControlDirective];\n    }\n  });\n})(); // Experimental\n\n\nlet ReactiveTypedFormsModule = /*#__PURE__*/(() => {\n  class ReactiveTypedFormsModule {\n    constructor() {\n      defaultContainer.isExperimental = true;\n      ReactiveFormConfig.autoInstancePush = true;\n    }\n\n    static forRoot() {\n      return {\n        ngModule: ReactiveTypedFormsModule,\n        providers: []\n      };\n    }\n\n  }\n\n  ReactiveTypedFormsModule.ɵfac = function ReactiveTypedFormsModule_Factory(t) {\n    return new (t || ReactiveTypedFormsModule)();\n  };\n\n  ReactiveTypedFormsModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: ReactiveTypedFormsModule\n  });\n  ReactiveTypedFormsModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: [{\n      provide: FormBuilder,\n      useClass: TypedFormBuilder\n    }, TypedFormBuilder],\n    imports: [CommonModule, FormsModule, ReactiveFormsModule, RxReactiveFormsModule.forRoot(), ReactiveFormsModule, FormsModule, ReactiveFormsModule]\n  });\n  return ReactiveTypedFormsModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ReactiveTypedFormsModule, {\n    imports: function () {\n      return [CommonModule, FormsModule, ReactiveFormsModule, RxReactiveFormsModule];\n    },\n    exports: function () {\n      return [ReactiveFormsModule, FormsModule, ReactiveFormsModule];\n    }\n  });\n})();\n\nfunction baseDecoratorFunction(annotationType, config, isAsync = false) {\n  return function (target, propertyKey, parameterIndex) {\n    defaultContainer.init(target, parameterIndex, propertyKey, annotationType, config, isAsync);\n  };\n}\n\nfunction baseAsyncValidator(configModel, validatorName) {\n  return control => {\n    configModel = configModel || {};\n\n    if (configModel.validatorConfig) {\n      if (FormProvider.ProcessRule(control, configModel)) {\n        return configModel.validatorConfig.pipe(map(resolveConfig(configModel, validatorName, control)));\n      }\n\n      return of(null);\n    } else return of(resolveConfig(configModel, validatorName, control)(configModel));\n  };\n}\n\nfunction resolveConfig(configModel, validatorName, control) {\n  return config => {\n    let configClone = Object.assign(Object.assign(Object.assign({}, configModel), config), {\n      expressionProcessed: true\n    });\n    return APP_VALIDATORS[validatorName](configClone)(control);\n  };\n}\n\nfunction alpha(config) {\n  return baseDecoratorFunction(AnnotationTypes.alpha, config);\n}\n\nfunction alphaAsync(config) {\n  return baseDecoratorFunction(AnnotationTypes.alpha, [baseAsyncValidator(config, AnnotationTypes.alpha)], true);\n}\n\nfunction alphaNumeric(config) {\n  return baseDecoratorFunction(AnnotationTypes.alphaNumeric, config);\n}\n\nfunction alphaNumericAsync(config) {\n  return baseDecoratorFunction(AnnotationTypes.alphaNumeric, [baseAsyncValidator(config, AnnotationTypes.alphaNumeric)], true);\n}\n\nfunction compare(config) {\n  return baseDecoratorFunction(AnnotationTypes.compare, config);\n}\n\nfunction contains(config) {\n  return baseDecoratorFunction(AnnotationTypes.contains, config);\n}\n\nfunction containsAsync(config) {\n  return baseDecoratorFunction(AnnotationTypes.contains, [baseAsyncValidator(config, AnnotationTypes.contains)], true);\n}\n\nfunction creditCard(config) {\n  return baseDecoratorFunction(AnnotationTypes.creditCard, config);\n}\n\nfunction creditCardAsync(config) {\n  return baseDecoratorFunction(AnnotationTypes.creditCard, [baseAsyncValidator(config, AnnotationTypes.creditCard)], true);\n}\n\nfunction digit(config) {\n  return baseDecoratorFunction(AnnotationTypes.digit, config);\n}\n\nfunction email(config) {\n  return baseDecoratorFunction(AnnotationTypes.email, config);\n}\n\nfunction hexColor(config) {\n  return baseDecoratorFunction(AnnotationTypes.hexColor, config);\n}\n\nfunction lowerCase(config) {\n  return baseDecoratorFunction(AnnotationTypes.lowerCase, config);\n}\n\nfunction maxDate(config) {\n  return baseDecoratorFunction(AnnotationTypes.maxDate, config);\n}\n\nfunction maxDateAsync(config) {\n  return baseDecoratorFunction(AnnotationTypes.maxDate, [baseAsyncValidator(config, AnnotationTypes.maxDate)], true);\n}\n\nfunction maxLength(config) {\n  return baseDecoratorFunction(AnnotationTypes.maxLength, config);\n}\n\nfunction maxLengthAsync(config) {\n  return baseDecoratorFunction(AnnotationTypes.maxLength, [baseAsyncValidator(config, AnnotationTypes.maxLength)], true);\n}\n\nfunction minDate(config) {\n  return baseDecoratorFunction(AnnotationTypes.minDate, config);\n}\n\nfunction minDateAsync(config) {\n  return baseDecoratorFunction(AnnotationTypes.minDate, [baseAsyncValidator(config, AnnotationTypes.minDate)], true);\n}\n\nfunction maxNumber(config) {\n  return baseDecoratorFunction(AnnotationTypes.maxNumber, config);\n}\n\nfunction maxNumberAsync(config) {\n  return baseDecoratorFunction(AnnotationTypes.maxNumber, [baseAsyncValidator(config, AnnotationTypes.maxNumber)], true);\n}\n\nfunction minLength(config) {\n  return baseDecoratorFunction(AnnotationTypes.minLength, config);\n}\n\nfunction minLengthAsync(config) {\n  return baseDecoratorFunction(AnnotationTypes.minLength, [baseAsyncValidator(config, AnnotationTypes.minLength)], true);\n}\n\nfunction minNumber(config) {\n  return baseDecoratorFunction(AnnotationTypes.minNumber, config);\n}\n\nfunction minNumberAsync(config) {\n  return baseDecoratorFunction(AnnotationTypes.minNumber, [baseAsyncValidator(config, AnnotationTypes.minNumber)], true);\n}\n\nfunction password(config) {\n  return baseDecoratorFunction(AnnotationTypes.password, config);\n}\n\nfunction passwordAsync(config) {\n  return baseDecoratorFunction(AnnotationTypes.password, [baseAsyncValidator(config, AnnotationTypes.password)], true);\n}\n\nfunction pattern(config) {\n  return baseDecoratorFunction(AnnotationTypes.pattern, config);\n}\n\nfunction patternAsync(config) {\n  return baseDecoratorFunction(AnnotationTypes.pattern, [baseAsyncValidator(config, AnnotationTypes.pattern)], true);\n}\n\nfunction propArray(entity, config) {\n  return function (target, propertyKey, parameterIndex) {\n    var propertyInfo = {\n      name: propertyKey,\n      propertyType: ARRAY_PROPERTY,\n      entity: entity,\n      dataPropertyName: config ? config.name : undefined,\n      entityProvider: config ? config.entityProvider : undefined,\n      arrayConfig: config ? {\n        allowMaxIndex: config.allowMaxIndex,\n        messageKey: config.messageKey,\n        createBlank: config.createBlank\n      } : undefined\n    };\n    defaultContainer.addProperty(target.constructor, propertyInfo);\n  };\n}\n\nfunction propObject(entity, config) {\n  return function (target, propertyKey, parameterIndex) {\n    defaultContainer.initPropertyObject(propertyKey, OBJECT_PROPERTY, entity, target, config);\n  };\n}\n\nfunction prop(config) {\n  return function (target, propertyKey, parameterIndex) {\n    var propertyInfo = {\n      name: propertyKey,\n      propertyType: PROPERTY,\n      dataPropertyName: config ? config.name : undefined,\n      defaultValue: config ? config.defaultValue : undefined,\n      ignore: config ? config.ignore : undefined,\n      isPrimaryKey: config ? config.isPrimaryKey : undefined,\n      messageNexus: config ? config.messageNexus : undefined\n    };\n    defaultContainer.addProperty(target.constructor, propertyInfo);\n  };\n}\n\nfunction range(config) {\n  return baseDecoratorFunction(AnnotationTypes.range, config);\n}\n\nfunction rangeAsync(config) {\n  return baseDecoratorFunction(AnnotationTypes.range, [baseAsyncValidator(config, AnnotationTypes.range)], true);\n}\n\nfunction required(config) {\n  return baseDecoratorFunction(AnnotationTypes.required, config);\n}\n\nfunction upperCase(config) {\n  return baseDecoratorFunction(AnnotationTypes.upperCase, config);\n}\n\nfunction time(config) {\n  return baseDecoratorFunction(AnnotationTypes.time, config);\n}\n\nfunction timeAsync(config) {\n  return baseDecoratorFunction(AnnotationTypes.time, [baseAsyncValidator(config, AnnotationTypes.time)], true);\n}\n\nfunction url(config) {\n  return baseDecoratorFunction(AnnotationTypes.url, config);\n}\n\nfunction urlAsync(config) {\n  return baseDecoratorFunction(AnnotationTypes.url, [baseAsyncValidator(config, AnnotationTypes.url)], true);\n}\n\nfunction json(config) {\n  return baseDecoratorFunction(AnnotationTypes.json, config);\n}\n\nfunction greaterThan(config) {\n  return baseDecoratorFunction(AnnotationTypes.greaterThan, config);\n}\n\nfunction greaterThanAsync(config) {\n  return baseDecoratorFunction(AnnotationTypes.greaterThan, [baseAsyncValidator(config, AnnotationTypes.greaterThan)], true);\n}\n\nfunction greaterThanEqualTo(config) {\n  return baseDecoratorFunction(AnnotationTypes.greaterThanEqualTo, config);\n}\n\nfunction greaterThanEqualToAsync(config) {\n  return baseDecoratorFunction(AnnotationTypes.greaterThanEqualTo, [baseAsyncValidator(config, AnnotationTypes.greaterThanEqualTo)], true);\n}\n\nfunction lessThanEqualTo(config) {\n  return baseDecoratorFunction(AnnotationTypes.lessThanEqualTo, config);\n}\n\nfunction lessThanEqualToAsync(config) {\n  return baseDecoratorFunction(AnnotationTypes.lessThanEqualTo, [baseAsyncValidator(config, AnnotationTypes.lessThanEqualTo)], true);\n}\n\nfunction lessThan(config) {\n  return baseDecoratorFunction(AnnotationTypes.lessThan, config);\n}\n\nfunction lessThanAsync(config) {\n  return baseDecoratorFunction(AnnotationTypes.lessThan, [baseAsyncValidator(config, AnnotationTypes.lessThan)], true);\n}\n\nfunction choice(config) {\n  return baseDecoratorFunction(AnnotationTypes.choice, config);\n}\n\nfunction choiceAsync(config) {\n  return baseDecoratorFunction(AnnotationTypes.choice, [baseAsyncValidator(config, AnnotationTypes.choice)], true);\n}\n\nfunction different(config) {\n  return baseDecoratorFunction(AnnotationTypes.different, config);\n}\n\nfunction numeric(config) {\n  return baseDecoratorFunction(AnnotationTypes.numeric, config);\n}\n\nfunction numericAsync(config) {\n  return baseDecoratorFunction(AnnotationTypes.numeric, [baseAsyncValidator(config, AnnotationTypes.numeric)], true);\n}\n\nfunction even(config) {\n  return baseDecoratorFunction(AnnotationTypes.even, config);\n}\n\nfunction odd(config) {\n  return baseDecoratorFunction(AnnotationTypes.odd, config);\n}\n\nfunction factor(config) {\n  return baseDecoratorFunction(AnnotationTypes.factor, config);\n}\n\nfunction factorAsync(config) {\n  return baseDecoratorFunction(AnnotationTypes.factor, [baseAsyncValidator(config, AnnotationTypes.factor)], true);\n}\n\nfunction leapYear(config) {\n  return baseDecoratorFunction(AnnotationTypes.leapYear, config);\n}\n\nfunction allOf(config) {\n  return baseDecoratorFunction(AnnotationTypes.allOf, config);\n}\n\nfunction allOfAsync(config) {\n  return baseDecoratorFunction(AnnotationTypes.allOf, [baseAsyncValidator(config, AnnotationTypes.allOf)], true);\n}\n\nfunction oneOf(config) {\n  return baseDecoratorFunction(AnnotationTypes.oneOf, config);\n}\n\nfunction oneOfAsync(config) {\n  return baseDecoratorFunction(AnnotationTypes.oneOf, [baseAsyncValidator(config, AnnotationTypes.oneOf)], true);\n}\n\nfunction noneOf(config) {\n  return baseDecoratorFunction(AnnotationTypes.noneOf, config);\n}\n\nfunction noneOfAsync(config) {\n  return baseDecoratorFunction(AnnotationTypes.noneOf, [baseAsyncValidator(config, AnnotationTypes.noneOf)], true);\n}\n\nfunction mac(config) {\n  return baseDecoratorFunction(AnnotationTypes.mac, config);\n}\n\nfunction ascii(config) {\n  return baseDecoratorFunction(AnnotationTypes.ascii, config);\n}\n\nfunction dataUri(config) {\n  return baseDecoratorFunction(AnnotationTypes.dataUri, config);\n}\n\nfunction port(config) {\n  return baseDecoratorFunction(AnnotationTypes.port, config);\n}\n\nfunction latLong(config) {\n  return baseDecoratorFunction(AnnotationTypes.latLong, config);\n}\n\nfunction extension(config) {\n  return baseDecoratorFunction(AnnotationTypes.extension, config);\n}\n\nfunction extensionAsync(config) {\n  return baseDecoratorFunction(AnnotationTypes.extension, [baseAsyncValidator(config, AnnotationTypes.extension)], true);\n}\n\nfunction fileSize(config) {\n  return baseDecoratorFunction(AnnotationTypes.fileSize, config);\n}\n\nfunction fileSizeAsync(config) {\n  return baseDecoratorFunction(AnnotationTypes.fileSize, [baseAsyncValidator(config, AnnotationTypes.fileSize)], true);\n}\n\nfunction endsWith(config) {\n  return baseDecoratorFunction(AnnotationTypes.endsWith, config);\n}\n\nfunction endsWithAsync(config) {\n  return baseDecoratorFunction(AnnotationTypes.endsWith, [baseAsyncValidator(config, AnnotationTypes.endsWith)], true);\n}\n\nfunction startsWith(config) {\n  return baseDecoratorFunction(AnnotationTypes.startsWith, config);\n}\n\nfunction startsWithAsync(config) {\n  return baseDecoratorFunction(AnnotationTypes.startsWith, [baseAsyncValidator(config, AnnotationTypes.startsWith)], true);\n}\n\nfunction primeNumber(config) {\n  return baseDecoratorFunction(AnnotationTypes.primeNumber, config);\n}\n\nfunction latitude(config) {\n  return baseDecoratorFunction(AnnotationTypes.latitude, config);\n}\n\nfunction longitude(config) {\n  return baseDecoratorFunction(AnnotationTypes.longitude, config);\n}\n\nfunction rule(config) {\n  return baseDecoratorFunction(AnnotationTypes.rule, config);\n}\n\nfunction file(config) {\n  return baseDecoratorFunction(AnnotationTypes.file, config);\n}\n\nfunction fileAsync(config) {\n  return baseDecoratorFunction(AnnotationTypes.file, [baseAsyncValidator(config, AnnotationTypes.file)], true);\n}\n\nfunction custom(config) {\n  return baseDecoratorFunction(AnnotationTypes.custom, config);\n}\n\nfunction customAsync(config) {\n  return baseDecoratorFunction(AnnotationTypes.custom, [baseAsyncValidator(config, AnnotationTypes.custom)], true);\n}\n\nfunction unique(config) {\n  return baseDecoratorFunction(AnnotationTypes.unique, config);\n}\n\nfunction image(config) {\n  return baseDecoratorFunction(AnnotationTypes.image, config);\n}\n\nfunction imageAsync(config) {\n  return baseDecoratorFunction(AnnotationTypes.image, [baseAsyncValidator(config, AnnotationTypes.image)], true);\n}\n\nfunction notEmpty(config) {\n  return baseDecoratorFunction(AnnotationTypes.notEmpty, config);\n}\n\nfunction async(validators) {\n  return baseDecoratorFunction(AnnotationTypes.async, validators, true);\n}\n\nfunction cusip(config) {\n  return baseDecoratorFunction(AnnotationTypes.cusip, config);\n}\n\nfunction grid(config) {\n  return baseDecoratorFunction(AnnotationTypes.grid, config);\n}\n\nfunction date(config) {\n  return baseDecoratorFunction(AnnotationTypes.date, config);\n}\n\nfunction dateAsync(config) {\n  return baseDecoratorFunction(AnnotationTypes.date, [baseAsyncValidator(config, AnnotationTypes.date)], true);\n}\n\nfunction disable(config) {\n  return function (target, propertyKey, parameterIndex) {\n    defaultContainer.addDecoratorConfig(target, parameterIndex, propertyKey, config, DECORATORS.disabled);\n  };\n}\n\nfunction error(config) {\n  return function (target, propertyKey, parameterIndex) {\n    defaultContainer.addDecoratorConfig(target, parameterIndex, propertyKey, config, DECORATORS.error);\n  };\n}\n\nfunction and(config) {\n  return baseDecoratorFunction(AnnotationTypes.and, config);\n}\n\nfunction or(config) {\n  return baseDecoratorFunction(AnnotationTypes.or, config);\n}\n\nfunction not(config) {\n  return baseDecoratorFunction(AnnotationTypes.not, config);\n}\n\nfunction trim() {\n  return function (target, propertyKey, parameterIndex) {\n    defaultContainer.addSanitizer(target, parameterIndex, propertyKey, DECORATORS.trim);\n  };\n}\n\nfunction ltrim() {\n  return function (target, propertyKey, parameterIndex) {\n    defaultContainer.addSanitizer(target, parameterIndex, propertyKey, DECORATORS.ltrim);\n  };\n}\n\nfunction rtrim() {\n  return function (target, propertyKey, parameterIndex) {\n    defaultContainer.addSanitizer(target, parameterIndex, propertyKey, DECORATORS.rtrim);\n  };\n}\n\nfunction blacklist(chars) {\n  return function (target, propertyKey, parameterIndex) {\n    defaultContainer.addSanitizer(target, parameterIndex, propertyKey, DECORATORS.blacklist, chars);\n  };\n}\n\nfunction stripLow(keepNewLines) {\n  return function (target, propertyKey, parameterIndex) {\n    defaultContainer.addSanitizer(target, parameterIndex, propertyKey, DECORATORS.stripLow, keepNewLines);\n  };\n}\n\nfunction toBoolean(strict) {\n  return function (target, propertyKey, parameterIndex) {\n    defaultContainer.addSanitizer(target, parameterIndex, propertyKey, DECORATORS.toBoolean, strict);\n  };\n}\n\nfunction toDouble() {\n  return function (target, propertyKey, parameterIndex) {\n    defaultContainer.addSanitizer(target, parameterIndex, propertyKey, DECORATORS.toDouble);\n  };\n}\n\nfunction toFloat() {\n  return function (target, propertyKey, parameterIndex) {\n    defaultContainer.addSanitizer(target, parameterIndex, propertyKey, DECORATORS.toFloat);\n  };\n}\n\nfunction toInt(radix) {\n  return function (target, propertyKey, parameterIndex) {\n    defaultContainer.addSanitizer(target, parameterIndex, propertyKey, DECORATORS.toInt, radix);\n  };\n}\n\nfunction toString() {\n  return function (target, propertyKey, parameterIndex) {\n    defaultContainer.addSanitizer(target, parameterIndex, propertyKey, DECORATORS.string);\n  };\n}\n\nfunction whitelist(chars) {\n  return function (target, propertyKey, parameterIndex) {\n    defaultContainer.addSanitizer(target, parameterIndex, propertyKey, DECORATORS.whitelist, chars);\n  };\n}\n\nfunction toDate(config) {\n  return function (target, propertyKey, parameterIndex) {\n    defaultContainer.addSanitizer(target, parameterIndex, propertyKey, DECORATORS.toDate, config);\n  };\n}\n\nfunction escape() {\n  return function (target, propertyKey, parameterIndex) {\n    defaultContainer.addSanitizer(target, parameterIndex, propertyKey, DECORATORS.escape);\n  };\n}\n\nfunction prefix(text) {\n  return function (target, propertyKey, parameterIndex) {\n    defaultContainer.addSanitizer(target, parameterIndex, propertyKey, DECORATORS.prefix, text);\n  };\n}\n\nfunction suffix(text) {\n  return function (target, propertyKey, parameterIndex) {\n    defaultContainer.addSanitizer(target, parameterIndex, propertyKey, DECORATORS.suffix, text);\n  };\n}\n\nfunction model(config) {\n  return function (target) {\n    defaultContainer.addPropsConfig(target, config);\n  };\n}\n\nfunction sanitize(config) {\n  return function (target, propertyKey, parameterIndex) {\n    defaultContainer.addSanitizer(target, parameterIndex, propertyKey, DECORATORS.sanitize, config);\n  };\n}\n\nfunction elementClass(config) {\n  return function (target, propertyKey, parameterIndex) {\n    defaultContainer.addDecoratorConfig(target, parameterIndex, propertyKey, config, DECORATORS.elementClass);\n  };\n}\n\nfunction minTime(config) {\n  return baseDecoratorFunction(AnnotationTypes.minTime, config);\n}\n\nfunction minTimeAsync(config) {\n  return baseDecoratorFunction(AnnotationTypes.minTime, [baseAsyncValidator(config, AnnotationTypes.minTime)], true);\n}\n\nfunction maxTime(config) {\n  return baseDecoratorFunction(AnnotationTypes.maxTime, config);\n}\n\nfunction maxTimeAsync(config) {\n  return baseDecoratorFunction(AnnotationTypes.maxTime, [baseAsyncValidator(config, AnnotationTypes.maxTime)], true);\n}\n\nfunction compose(config) {\n  return baseDecoratorFunction(AnnotationTypes.compose, config);\n}\n\nfunction requiredTrue(config) {\n  return baseDecoratorFunction(AnnotationTypes.requiredTrue, config);\n}\n\nfunction mask(config) {\n  return baseDecoratorFunction(AnnotationTypes.mask, config);\n}\n\nfunction updateOn(config) {\n  return baseDecoratorFunction(AnnotationTypes.updateOn, config);\n}\n\nfunction baseValidator(config, type, validator) {\n  var rxwebValidator = (control, target) => {\n    if (typeof control == STRING) defaultContainer.init(target, 0, control, type, config, false);else {\n      if (config && (!control.validatorConfig || !control.validatorConfig[type])) ApplicationUtil.configureControl(control, config, type);\n      return validator(control);\n    }\n    return null;\n  };\n\n  Object.defineProperty(rxwebValidator, \"name\", {\n    value: RX_WEB_VALIDATOR\n  });\n  return rxwebValidator;\n}\n\nfunction baseAsyncValidatorExtension(config, type, validator) {\n  var rxwebValidator = (control, target) => {\n    if (typeof control == STRING) defaultContainer.init(target, 0, control, type, config, true);else {\n      if (config && (!control.validatorConfig || !control.validatorConfig[type])) ApplicationUtil.configureControl(control, config, type);\n      return validator(control);\n    }\n    return null;\n  };\n\n  Object.defineProperty(rxwebValidator, \"name\", {\n    value: RX_WEB_VALIDATOR\n  });\n  return rxwebValidator;\n}\n\nfunction alphaValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.alpha, alphaValidator(config));\n}\n\nfunction alphaAsyncValidatorExtension(config) {\n  return baseAsyncValidatorExtension(config, AnnotationTypes.alpha, baseAsyncValidator(config, AnnotationTypes.alpha));\n}\n\nfunction allOfValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.allOf, allOfValidator(config));\n}\n\nfunction allOfAsyncValidatorExtension(config) {\n  return baseAsyncValidatorExtension(config, AnnotationTypes.allOf, baseAsyncValidator(config, AnnotationTypes.allOf));\n}\n\nfunction alphaNumericValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.alphaNumeric, alphaNumericValidator(config));\n}\n\nfunction alphaNumericAsyncValidatorExtension(config) {\n  return baseAsyncValidatorExtension(config, AnnotationTypes.alphaNumeric, baseAsyncValidator(config, AnnotationTypes.alphaNumeric));\n}\n\nfunction choiceValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.choice, choiceValidator(config));\n}\n\nfunction choiceAsyncValidatorExtension(config) {\n  return baseAsyncValidatorExtension(config, AnnotationTypes.choice, baseAsyncValidator(config, AnnotationTypes.choice));\n}\n\nfunction compareValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.compare, compareValidator(config));\n}\n\nfunction containsValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.contains, containsValidator(config));\n}\n\nfunction containsAsyncValidatorExtension(config) {\n  return baseAsyncValidatorExtension(config, AnnotationTypes.contains, baseAsyncValidator(config, AnnotationTypes.contains));\n}\n\nfunction creditCardValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.creditCard, creditCardValidator(config));\n}\n\nfunction creditCardAsyncValidatorExtension(config) {\n  return baseAsyncValidatorExtension(config, AnnotationTypes.creditCard, baseAsyncValidator(config, AnnotationTypes.creditCard));\n}\n\nfunction differentValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.different, differentValidator(config));\n}\n\nfunction digitValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.digit, digitValidator(config));\n}\n\nfunction emailValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.email, emailValidator(config));\n}\n\nfunction evenValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.even, evenValidator(config));\n}\n\nfunction factorValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.factor, factorValidator(config));\n}\n\nfunction factorAsyncValidatorExtension(config) {\n  return baseAsyncValidatorExtension(config, AnnotationTypes.factor, baseAsyncValidator(config, AnnotationTypes.factor));\n}\n\nfunction greaterThanEqualToValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.greaterThanEqualTo, greaterThanEqualToValidator(config));\n}\n\nfunction greaterThanEqualToAsyncValidatorExtension(config) {\n  return baseAsyncValidatorExtension(config, AnnotationTypes.greaterThanEqualTo, baseAsyncValidator(config, AnnotationTypes.greaterThanEqualTo));\n}\n\nfunction greaterThanValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.greaterThan, greaterThanValidator(config));\n}\n\nfunction greaterThanAsyncValidatorExtension(config) {\n  return baseAsyncValidatorExtension(config, AnnotationTypes.greaterThan, baseAsyncValidator(config, AnnotationTypes.greaterThan));\n}\n\nfunction hexColorValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.hexColor, hexColorValidator(config));\n}\n\nfunction jsonValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.json, jsonValidator(config));\n}\n\nfunction leapYearValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.leapYear, leapYearValidator(config));\n}\n\nfunction lessThanEqualToValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.lessThanEqualTo, lessThanEqualToValidator(config));\n}\n\nfunction lessThanEqualToAsyncValidatorExtension(config) {\n  return baseAsyncValidatorExtension(config, AnnotationTypes.lessThanEqualTo, baseAsyncValidator(config, AnnotationTypes.lessThanEqualTo));\n}\n\nfunction lessThanValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.lessThan, lessThanValidator(config));\n}\n\nfunction lessThanAsyncValidatorExtension(config) {\n  return baseAsyncValidatorExtension(config, AnnotationTypes.lessThan, baseAsyncValidator(config, AnnotationTypes.lessThan));\n}\n\nfunction lowerCaseValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.lowerCase, lowercaseValidator(config));\n}\n\nfunction macValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.mac, macValidator(config));\n}\n\nfunction maxDateValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.maxDate, maxDateValidator(config));\n}\n\nfunction maxDateAsyncValidatorExtension(config) {\n  return baseAsyncValidatorExtension(config, AnnotationTypes.maxDate, baseAsyncValidator(config, AnnotationTypes.maxDate));\n}\n\nfunction maxLengthValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.maxLength, maxLengthValidator(config));\n}\n\nfunction maxLengthAsyncValidatorExtension(config) {\n  return baseAsyncValidatorExtension(config, AnnotationTypes.maxLength, baseAsyncValidator(config, AnnotationTypes.maxLength));\n}\n\nfunction maxNumberValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.maxNumber, maxNumberValidator(config));\n}\n\nfunction maxNumberAsyncValidatorExtension(config) {\n  return baseAsyncValidatorExtension(config, AnnotationTypes.maxNumber, baseAsyncValidator(config, AnnotationTypes.maxNumber));\n}\n\nfunction minDateValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.minDate, minDateValidator(config));\n}\n\nfunction minDateAsyncValidatorExtension(config) {\n  return baseAsyncValidatorExtension(config, AnnotationTypes.minDate, baseAsyncValidator(config, AnnotationTypes.minDate));\n}\n\nfunction minLengthValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.minLength, minLengthValidator(config));\n}\n\nfunction minLengthAsyncValidatorExtension(config) {\n  return baseAsyncValidatorExtension(config, AnnotationTypes.minLength, baseAsyncValidator(config, AnnotationTypes.minLength));\n}\n\nfunction minNumberValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.minNumber, minNumberValidator(config));\n}\n\nfunction minNumberAsyncValidatorExtension(config) {\n  return baseAsyncValidatorExtension(config, AnnotationTypes.minNumber, baseAsyncValidator(config, AnnotationTypes.minNumber));\n}\n\nfunction noneOfValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.noneOf, noneOfValidator(config));\n}\n\nfunction noneOfAsyncValidatorExtension(config) {\n  return baseAsyncValidatorExtension(config, AnnotationTypes.noneOf, baseAsyncValidator(config, AnnotationTypes.noneOf));\n}\n\nfunction numericValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.numeric, numericValidator(config));\n}\n\nfunction numericAsyncValidatorExtension(config) {\n  return baseAsyncValidatorExtension(config, AnnotationTypes.numeric, baseAsyncValidator(config, AnnotationTypes.numeric));\n}\n\nfunction oddValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.odd, oddValidator(config));\n}\n\nfunction oneOfValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.oneOf, oneOfValidator(config));\n}\n\nfunction oneOfAsyncValidatorExtension(config) {\n  return baseAsyncValidatorExtension(config, AnnotationTypes.oneOf, baseAsyncValidator(config, AnnotationTypes.oneOf));\n}\n\nfunction passwordcValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.password, passwordValidator(config));\n}\n\nfunction passwordAsyncValidatorExtension(config) {\n  return baseAsyncValidatorExtension(config, AnnotationTypes.password, baseAsyncValidator(config, AnnotationTypes.password));\n}\n\nfunction patternValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.pattern, patternValidator(config));\n}\n\nfunction patternAsyncValidatorExtension(config) {\n  return baseAsyncValidatorExtension(config, AnnotationTypes.pattern, baseAsyncValidator(config, AnnotationTypes.pattern));\n}\n\nfunction rangeValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.range, rangeValidator(config));\n}\n\nfunction rangeAsyncValidatorExtension(config) {\n  return baseAsyncValidatorExtension(config, AnnotationTypes.range, baseAsyncValidator(config, AnnotationTypes.range));\n}\n\nfunction requiredValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.required, requiredValidator(config));\n}\n\nfunction timeValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.time, timeValidator(config));\n}\n\nfunction timeAsyncValidatorExtension(config) {\n  return baseAsyncValidatorExtension(config, AnnotationTypes.time, baseAsyncValidator(config, AnnotationTypes.time));\n}\n\nfunction upperCaseValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.upperCase, uppercaseValidator(config));\n}\n\nfunction urlValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.url, urlValidator(config));\n}\n\nfunction urlAsyncValidatorExtension(config) {\n  return baseAsyncValidatorExtension(config, AnnotationTypes.url, baseAsyncValidator(config, AnnotationTypes.url));\n}\n\nfunction asciiValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.ascii, asciiValidator(config));\n}\n\nfunction dataUriValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.dataUri, dataUriValidator(config));\n}\n\nfunction portValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.port, portValidator(config));\n}\n\nfunction latLongValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.latLong, latLongValidator(config));\n}\n\nfunction extensionValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.extension, control => {\n    return null;\n  });\n}\n\nfunction extensionAsyncValidatorExtension(config) {\n  return baseAsyncValidatorExtension(config, AnnotationTypes.extension, baseAsyncValidator(config, AnnotationTypes.extension));\n}\n\nfunction fileSizeValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.fileSize, control => {\n    return null;\n  });\n}\n\nfunction fileSizeAsyncValidatorExtension(config) {\n  return baseAsyncValidatorExtension(config, AnnotationTypes.fileSize, baseAsyncValidator(config, AnnotationTypes.fileSize));\n}\n\nfunction endsWithValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.endsWith, endsWithValidator(config));\n}\n\nfunction endsWithAsyncValidatorExtension(config) {\n  return baseAsyncValidatorExtension(config, AnnotationTypes.endsWith, baseAsyncValidator(config, AnnotationTypes.endsWith));\n}\n\nfunction startsWithValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.startsWithWith, startsWithValidator(config));\n}\n\nfunction startsWithAsyncValidatorExtension(config) {\n  return baseAsyncValidatorExtension(config, AnnotationTypes.startsWithWith, baseAsyncValidator(config, AnnotationTypes.startsWith));\n}\n\nfunction primeNumberValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.primeNumber, primeNumberValidator(config));\n}\n\nfunction latitudeValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.latitude, latitudeValidator(config));\n}\n\nfunction longitudeValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.longitude, longitudeValidator(config));\n}\n\nfunction composeValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.compose, composeValidator(config));\n}\n\nfunction fileValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.file, control => {\n    return null;\n  });\n}\n\nfunction fileAsyncValidatorExtension(config) {\n  return baseAsyncValidatorExtension(config, AnnotationTypes.file, baseAsyncValidator(config, AnnotationTypes.file));\n}\n\nfunction customValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.custom, customValidator(config));\n}\n\nfunction customAsyncValidatorExtension(config) {\n  return baseAsyncValidatorExtension(config, AnnotationTypes.custom, baseAsyncValidator(config, AnnotationTypes.custom));\n}\n\nfunction uniqueValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.unique, uniqueValidator(config));\n}\n\nfunction imageValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.image, control => {\n    return null;\n  });\n}\n\nfunction imageAsyncValidatorExtension(config) {\n  return baseAsyncValidatorExtension(config, AnnotationTypes.image, baseAsyncValidator(config, AnnotationTypes.image));\n}\n\nfunction notEmptyValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.notEmpty, notEmptyValidator(config));\n}\n\nfunction ipValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.ip, ipValidator(config));\n}\n\nfunction ipAsyncValidatorExtension(config) {\n  return baseAsyncValidatorExtension(config, AnnotationTypes.ip, baseAsyncValidator(config, AnnotationTypes.ip));\n}\n\nfunction cusipValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.cusip, cusipValidator(config));\n}\n\nfunction gridValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.grid, gridValidator(config));\n}\n\nfunction dateValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.date, dateValidator(config));\n}\n\nfunction dateAsyncValidatorExtension(config) {\n  return baseAsyncValidatorExtension(config, AnnotationTypes.date, baseAsyncValidator(config, AnnotationTypes.date));\n}\n\nfunction andValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.and, andValidator(config));\n}\n\nfunction orValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.or, orValidator(config));\n}\n\nfunction notValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.not, notValidator(config));\n}\n\nfunction minTimeValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.minTime, minTimeValidator(config));\n}\n\nfunction minTimeAsyncValidatorExtension(config) {\n  return baseAsyncValidatorExtension(config, AnnotationTypes.minTime, baseAsyncValidator(config, AnnotationTypes.minTime));\n}\n\nfunction maxTimeValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.maxTime, maxTimeValidator(config));\n}\n\nfunction maxTimeAsyncValidatorExtension(config) {\n  return baseAsyncValidatorExtension(config, AnnotationTypes.maxTime, baseAsyncValidator(config, AnnotationTypes.maxTime));\n}\n\nfunction requiredTrueValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.requiredTrue, requiredTrueValidator(config));\n}\n\nfunction maskValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.mask, maskValidator(config));\n}\n\nfunction ibanValidatorExtension(config) {\n  return baseValidator(config, AnnotationTypes.iban, ibanValidator(config));\n}\n\nfunction ibanAsyncValidatorExtension(config) {\n  return baseAsyncValidatorExtension(config, AnnotationTypes.iban, baseAsyncValidator(config, AnnotationTypes.iban));\n}\n\nlet RxwebValidators = /*#__PURE__*/(() => {\n  class RxwebValidators {}\n\n  RxwebValidators.alpha = alphaValidatorExtension;\n  RxwebValidators.allOf = allOfValidatorExtension;\n  RxwebValidators.alphaNumeric = alphaNumericValidatorExtension;\n  RxwebValidators.choice = choiceValidatorExtension;\n  RxwebValidators.compare = compareValidatorExtension;\n  RxwebValidators.contains = containsValidatorExtension;\n  RxwebValidators.creditCard = creditCardValidatorExtension;\n  RxwebValidators.different = differentValidatorExtension;\n  RxwebValidators.digit = digitValidatorExtension;\n  RxwebValidators.email = emailValidatorExtension;\n  RxwebValidators.even = evenValidatorExtension;\n  RxwebValidators.factor = factorValidatorExtension;\n  RxwebValidators.greaterThanEqualTo = greaterThanEqualToValidatorExtension;\n  RxwebValidators.greaterThan = greaterThanValidatorExtension;\n  RxwebValidators.hexColor = hexColorValidatorExtension;\n  RxwebValidators.json = jsonValidatorExtension;\n  RxwebValidators.leapYear = leapYearValidatorExtension;\n  RxwebValidators.lessThanEqualTo = lessThanEqualToValidatorExtension;\n  RxwebValidators.lessThan = lessThanValidatorExtension;\n  RxwebValidators.lowerCase = lowerCaseValidatorExtension;\n  RxwebValidators.mac = macValidatorExtension;\n  RxwebValidators.maxDate = maxDateValidatorExtension;\n  RxwebValidators.maxLength = maxLengthValidatorExtension;\n  RxwebValidators.maxNumber = maxNumberValidatorExtension;\n  RxwebValidators.minDate = minDateValidatorExtension;\n  RxwebValidators.minLength = minLengthValidatorExtension;\n  RxwebValidators.minNumber = minNumberValidatorExtension;\n  RxwebValidators.noneOf = noneOfValidatorExtension;\n  RxwebValidators.numeric = numericValidatorExtension;\n  RxwebValidators.odd = oddValidatorExtension;\n  RxwebValidators.oneOf = oneOfValidatorExtension;\n  RxwebValidators.password = passwordcValidatorExtension;\n  RxwebValidators.pattern = patternValidatorExtension;\n  RxwebValidators.range = rangeValidatorExtension;\n  RxwebValidators.required = requiredValidatorExtension;\n  RxwebValidators.time = timeValidatorExtension;\n  RxwebValidators.upperCase = upperCaseValidatorExtension;\n  RxwebValidators.url = urlValidatorExtension;\n  RxwebValidators.ascii = asciiValidatorExtension;\n  RxwebValidators.dataUri = dataUriValidatorExtension;\n  RxwebValidators.port = portValidatorExtension;\n  RxwebValidators.latLong = latLongValidatorExtension;\n  RxwebValidators.extension = extensionValidatorExtension;\n  RxwebValidators.fileSize = fileSizeValidatorExtension;\n  RxwebValidators.endsWith = endsWithValidatorExtension;\n  RxwebValidators.startsWith = startsWithValidatorExtension;\n  RxwebValidators.primeNumber = primeNumberValidatorExtension;\n  RxwebValidators.latitude = latitudeValidatorExtension;\n  RxwebValidators.longitude = longitudeValidatorExtension;\n  RxwebValidators.compose = composeValidatorExtension;\n  RxwebValidators.file = fileValidatorExtension;\n  RxwebValidators.custom = customValidatorExtension;\n  RxwebValidators.unique = uniqueValidatorExtension;\n  RxwebValidators.image = imageValidatorExtension;\n  RxwebValidators.notEmpty = notEmptyValidatorExtension;\n  RxwebValidators.ip = ipValidatorExtension;\n  RxwebValidators.cusip = cusipValidatorExtension;\n  RxwebValidators.grid = gridValidatorExtension;\n  RxwebValidators.date = dateValidatorExtension;\n  RxwebValidators.and = andValidatorExtension;\n  RxwebValidators.or = orValidatorExtension;\n  RxwebValidators.not = notValidatorExtension;\n  RxwebValidators.minTime = minTimeValidatorExtension;\n  RxwebValidators.maxTime = maxTimeValidatorExtension;\n  RxwebValidators.requiredTrue = requiredTrueValidatorExtension;\n  RxwebValidators.mask = maskValidatorExtension;\n  RxwebValidators.iban = ibanValidatorExtension;\n  RxwebValidators.alphaAsync = alphaAsyncValidatorExtension;\n  RxwebValidators.alphaNumericAsync = alphaNumericAsyncValidatorExtension;\n  RxwebValidators.allOfAsync = allOfAsyncValidatorExtension;\n  RxwebValidators.choiceAsync = choiceAsyncValidatorExtension;\n  RxwebValidators.containsAsync = containsAsyncValidatorExtension;\n  RxwebValidators.creditCardAsync = creditCardAsyncValidatorExtension;\n  RxwebValidators.customAsync = customAsyncValidatorExtension;\n  RxwebValidators.dateAsync = dateAsyncValidatorExtension;\n  RxwebValidators.endsWithAsync = endsWithAsyncValidatorExtension;\n  RxwebValidators.extensionAsync = extensionAsyncValidatorExtension;\n  RxwebValidators.factorAsync = factorAsyncValidatorExtension;\n  RxwebValidators.fileSizeAsync = fileSizeAsyncValidatorExtension;\n  RxwebValidators.fileAsync = fileAsyncValidatorExtension;\n  RxwebValidators.greaterThanEqualToAsync = greaterThanEqualToAsyncValidatorExtension;\n  RxwebValidators.greaterThanAsync = greaterThanAsyncValidatorExtension;\n  RxwebValidators.imageAsync = imageAsyncValidatorExtension;\n  RxwebValidators.ipAsync = ipAsyncValidatorExtension;\n  RxwebValidators.lessThanEqualToAsync = lessThanEqualToAsyncValidatorExtension;\n  RxwebValidators.lessThanAsync = lessThanAsyncValidatorExtension;\n  RxwebValidators.maxDateAsync = maxDateAsyncValidatorExtension;\n  RxwebValidators.maxLengthAsync = maxLengthAsyncValidatorExtension;\n  RxwebValidators.maxNumberAsync = maxNumberAsyncValidatorExtension;\n  RxwebValidators.maxTimeAsync = maxTimeAsyncValidatorExtension;\n  RxwebValidators.minDateAsync = minDateAsyncValidatorExtension;\n  RxwebValidators.minLengthAsync = minLengthAsyncValidatorExtension;\n  RxwebValidators.minNumberAsync = minNumberAsyncValidatorExtension;\n  RxwebValidators.minTimeAsync = minTimeAsyncValidatorExtension;\n  RxwebValidators.noneOfAsync = noneOfAsyncValidatorExtension;\n  RxwebValidators.numericAsync = numericAsyncValidatorExtension;\n  RxwebValidators.oneOfAsync = oneOfAsyncValidatorExtension;\n  RxwebValidators.passwordAsync = passwordAsyncValidatorExtension;\n  RxwebValidators.patternAsync = patternAsyncValidatorExtension;\n  RxwebValidators.rangeAsync = rangeAsyncValidatorExtension;\n  RxwebValidators.startsWithAsync = startsWithAsyncValidatorExtension;\n  RxwebValidators.timeAsync = timeAsyncValidatorExtension;\n  RxwebValidators.urlAsync = urlAsyncValidatorExtension;\n  RxwebValidators.ibanAsync = ibanAsyncValidatorExtension;\n  return RxwebValidators;\n})();\n\nclass IAbstractControl extends AbstractControl {}\n\nclass TypedForm {}\n\nvar UrlValidationType = /*#__PURE__*/(() => {\n  (function (UrlValidationType) {\n    UrlValidationType[UrlValidationType[\"FQDN\"] = 1] = \"FQDN\";\n    UrlValidationType[UrlValidationType[\"LocalHost\"] = 2] = \"LocalHost\";\n    UrlValidationType[UrlValidationType[\"IntranetServer\"] = 3] = \"IntranetServer\";\n  })(UrlValidationType || (UrlValidationType = {}));\n\n  return UrlValidationType;\n})();\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\nexport { ErrorMessageBindingStrategy, FormBuilderConfiguration, IAbstractControl, IpVersion, NumericValueType, ReactiveFormConfig, ReactiveTypedFormsModule, ResetFormType, RxFormArray, RxFormBuilder, RxFormControl, RxFormGroup, RxReactiveFormsModule, RxwebValidators, TypedForm, TypedFormBuilder, UrlValidationType, ValidationAlphabetLocale, allOf, allOfAsync, alpha, alphaAsync, alphaNumeric, alphaNumericAsync, and, ascii, async, blacklist, choice, choiceAsync, compare, compose, contains, containsAsync, creditCard, creditCardAsync, cusip, custom, customAsync, dataUri, date, dateAsync, different, digit, disable, elementClass, email, endsWith, endsWithAsync, error, escape, even, extension, extensionAsync, factor, factorAsync, file, fileAsync, fileSize, fileSizeAsync, greaterThan, greaterThanAsync, greaterThanEqualTo, greaterThanEqualToAsync, grid, hexColor, image, imageAsync, json, latLong, latitude, leapYear, lessThan, lessThanAsync, lessThanEqualTo, lessThanEqualToAsync, longitude, lowerCase, ltrim, mac, mask, maxDate, maxDateAsync, maxLength, maxLengthAsync, maxNumber, maxNumberAsync, maxTime, maxTimeAsync, minDate, minDateAsync, minLength, minLengthAsync, minNumber, minNumberAsync, minTime, minTimeAsync, model, noneOf, noneOfAsync, not, notEmpty, numeric, numericAsync, odd, oneOf, oneOfAsync, or, password, passwordAsync, pattern, patternAsync, port, prefix, primeNumber, prop, propArray, propObject, range, rangeAsync, required, requiredTrue, rtrim, rule, sanitize, startsWith, startsWithAsync, stripLow, suffix, time, timeAsync, toBoolean, toDate, toDouble, toFloat, toInt, toString, trim, unique, updateOn, upperCase, url, urlAsync, whitelist, RxwebFormDirective as ɵa, BaseDirective as ɵb, HtmlControlTemplateDirective as ɵc, ControlHostDirective as ɵd, RxFormControlDirective as ɵe, BaseValidator as ɵf, ControlExpressionProcess as ɵg, DecimalProvider as ɵh, FileControlDirective as ɵi, ImageFileControlDirective as ɵj, AsyncValidationDirective as ɵk, BaseFormBuilder as ɵl }; //# sourceMappingURL=rxweb-reactive-form-validators.js.map","map":null,"metadata":{},"sourceType":"module"}